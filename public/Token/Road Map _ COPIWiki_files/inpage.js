(()=>{var __webpack_modules__={24:module=>{"use strict";let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(__){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1,module.exports.string2buf=str=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(str);let buf,c,c2,m_pos,i,str_len=str.length,buf_len=0;for(m_pos=0;m_pos<str_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),buf_len+=c<128?1:c<2048?2:c<65536?3:4;for(buf=new Uint8Array(buf_len),i=0,m_pos=0;i<buf_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),c<128?buf[i++]=c:c<2048?(buf[i++]=192|c>>>6,buf[i++]=128|63&c):c<65536?(buf[i++]=224|c>>>12,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c):(buf[i++]=240|c>>>18,buf[i++]=128|c>>>12&63,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c);return buf};module.exports.buf2string=(buf,max)=>{const len=max||buf.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(buf.subarray(0,max));let i,out;const utf16buf=new Array(2*len);for(out=0,i=0;i<len;){let c=buf[i++];if(c<128){utf16buf[out++]=c;continue}let c_len=_utf8len[c];if(c_len>4)utf16buf[out++]=65533,i+=c_len-1;else{for(c&=2===c_len?31:3===c_len?15:7;c_len>1&&i<len;)c=c<<6|63&buf[i++],c_len--;c_len>1?utf16buf[out++]=65533:c<65536?utf16buf[out++]=c:(c-=65536,utf16buf[out++]=55296|c>>10&1023,utf16buf[out++]=56320|1023&c)}}return((buf,len)=>{if(len<65534&&buf.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,buf.length===len?buf:buf.subarray(0,len));let result="";for(let i=0;i<len;i++)result+=String.fromCharCode(buf[i]);return result})(utf16buf,out)},module.exports.utf8border=(buf,max)=>{(max=max||buf.length)>buf.length&&(max=buf.length);let pos=max-1;for(;pos>=0&&128==(192&buf[pos]);)pos--;return pos<0||0===pos?max:pos+_utf8len[buf[pos]]>max?pos:max}},78:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},251:(__unused_webpack_module,exports)=>{exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m,eLen=8*nBytes-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,nBits=-7,i=isLE?nBytes-1:0,d=isLE?-1:1,s=buffer[offset+i];for(i+=d,e=s&(1<<-nBits)-1,s>>=-nBits,nBits+=eLen;nBits>0;e=256*e+buffer[offset+i],i+=d,nBits-=8);for(m=e&(1<<-nBits)-1,e>>=-nBits,nBits+=mLen;nBits>0;m=256*m+buffer[offset+i],i+=d,nBits-=8);if(0===e)e=1-eBias;else{if(e===eMax)return m?NaN:1/0*(s?-1:1);m+=Math.pow(2,mLen),e-=eBias}return(s?-1:1)*m*Math.pow(2,e-mLen)},exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c,eLen=8*nBytes-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,rt=23===mLen?Math.pow(2,-24)-Math.pow(2,-77):0,i=isLE?0:nBytes-1,d=isLE?1:-1,s=value<0||0===value&&1/value<0?1:0;for(value=Math.abs(value),isNaN(value)||value===1/0?(m=isNaN(value)?1:0,e=eMax):(e=Math.floor(Math.log(value)/Math.LN2),value*(c=Math.pow(2,-e))<1&&(e--,c*=2),(value+=e+eBias>=1?rt/c:rt*Math.pow(2,1-eBias))*c>=2&&(e++,c/=2),e+eBias>=eMax?(m=0,e=eMax):e+eBias>=1?(m=(value*c-1)*Math.pow(2,mLen),e+=eBias):(m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen),e=0));mLen>=8;buffer[offset+i]=255&m,i+=d,m/=256,mLen-=8);for(e=e<<mLen|m,eLen+=mLen;eLen>0;buffer[offset+i]=255&e,i+=d,e/=256,eLen-=8);buffer[offset+i-d]|=128*s}},1238:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.crypto=void 0,exports.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},1819:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},1956:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TypedDataRevision=void 0,exports.TypedDataRevision={ACTIVE:"1",LEGACY:"0"}},2695:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TokenVerifier=void 0;const base64url=__webpack_require__(35921),cryptoClients_1=__webpack_require__(61161),errors_1=__webpack_require__(68886),sha256_1=__webpack_require__(97990);exports.TokenVerifier=class{constructor(signingAlgorithm,rawPublicKey){if(!signingAlgorithm||!rawPublicKey)throw new errors_1.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof signingAlgorithm)throw"signing algorithm parameter must be a string";if(signingAlgorithm=signingAlgorithm.toUpperCase(),!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=cryptoClients_1.cryptoClients[signingAlgorithm],this.rawPublicKey=rawPublicKey}verify(token){return"string"==typeof token?this.verifyCompact(token,!1):"object"==typeof token&&this.verifyExpanded(token,!1)}verifyAsync(token){return"string"==typeof token?this.verifyCompact(token,!0):"object"==typeof token?this.verifyExpanded(token,!0):Promise.resolve(!1)}verifyCompact(token,async){const tokenParts=token.split("."),signingInput=tokenParts[0]+"."+tokenParts[1],performVerify=signingInputHash=>{const derSignatureBytes=this.cryptoClient.loadSignature(tokenParts[2]);return this.cryptoClient.verifyHash(signingInputHash,derSignatureBytes,this.rawPublicKey)};if(async)return(0,sha256_1.hashSha256Async)(signingInput).then((signingInputHash=>performVerify(signingInputHash)));{const signingInputHash=(0,sha256_1.hashSha256)(signingInput);return performVerify(signingInputHash)}}verifyExpanded(token,async){const signingInput=[token.header.join("."),base64url.encode(token.payload)].join(".");let verified=!0;const performVerify=signingInputHash=>(token.signature.map((signature=>{const derSignatureBytes=this.cryptoClient.loadSignature(signature);this.cryptoClient.verifyHash(signingInputHash,derSignatureBytes,this.rawPublicKey)||(verified=!1)})),verified);if(async)return(0,sha256_1.hashSha256Async)(signingInput).then((signingInputHash=>performVerify(signingInputHash)));{const signingInputHash=(0,sha256_1.hashSha256)(signingInput);return performVerify(signingInputHash)}}}},2731:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},3483:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ETransactionVersion3=exports.ETransactionVersion2=exports.ETransactionVersion=exports.EDAMode=exports.EDataAvailabilityMode=exports.EBlockTag=exports.ETransactionExecutionStatus=exports.ETransactionFinalityStatus=exports.ETransactionStatus=exports.ESimulationFlag=exports.ETransactionType=void 0,exports.ETransactionType={DECLARE:"DECLARE",DEPLOY:"DEPLOY",DEPLOY_ACCOUNT:"DEPLOY_ACCOUNT",INVOKE:"INVOKE",L1_HANDLER:"L1_HANDLER"},exports.ESimulationFlag={SKIP_VALIDATE:"SKIP_VALIDATE",SKIP_FEE_CHARGE:"SKIP_FEE_CHARGE"},exports.ETransactionStatus={RECEIVED:"RECEIVED",REJECTED:"REJECTED",ACCEPTED_ON_L2:"ACCEPTED_ON_L2",ACCEPTED_ON_L1:"ACCEPTED_ON_L1"},exports.ETransactionFinalityStatus={ACCEPTED_ON_L2:"ACCEPTED_ON_L2",ACCEPTED_ON_L1:"ACCEPTED_ON_L1"},exports.ETransactionExecutionStatus={SUCCEEDED:"SUCCEEDED",REVERTED:"REVERTED"},exports.EBlockTag={LATEST:"latest",PENDING:"pending"},exports.EDataAvailabilityMode={L1:"L1",L2:"L2"},exports.EDAMode={L1:0,L2:1},exports.ETransactionVersion={V0:"0x0",V1:"0x1",V2:"0x2",V3:"0x3",F0:"0x100000000000000000000000000000000",F1:"0x100000000000000000000000000000001",F2:"0x100000000000000000000000000000002",F3:"0x100000000000000000000000000000003"},exports.ETransactionVersion2={V0:"0x0",V1:"0x1",V2:"0x2",F0:"0x100000000000000000000000000000000",F1:"0x100000000000000000000000000000001",F2:"0x100000000000000000000000000000002"},exports.ETransactionVersion3={V3:"0x3",F3:"0x100000000000000000000000000000003"}},4246:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.poseidonSmall=exports.Fp251=exports.keccak=exports.computeHashOnElements=exports.utils=exports.Signature=exports.ProjectivePoint=exports.CURVE=exports._starkCurve=exports.MAX_VALUE=void 0,exports.normalizePrivateKey=normalizePrivateKey,exports.getPublicKey=getPublicKey,exports.getSharedSecret=function(privKeyA,pubKeyB){return curve.getSharedSecret(normalizePrivateKey(privKeyA),pubKeyB)},exports.sign=function(msgHash,privKey,opts){const sig=curve.sign(checkMessage(msgHash),normalizePrivateKey(privKey),opts);return checkSignature(sig),sig},exports.verify=function(signature,msgHash,pubKey){if(!(signature instanceof Signature)){const bytes=ensureBytes(signature);try{signature=Signature.fromDER(bytes)}catch(derError){if(!(derError instanceof weierstrass_1.DER.Err))throw derError;signature=Signature.fromCompact(bytes)}}return checkSignature(signature),curve.verify(signature,checkMessage(msgHash),ensureBytes(pubKey))},exports.grindKey=grindKey,exports.getStarkKey=function(privateKey){return extractX(getPublicKey(privateKey,!0))},exports.ethSigToPrivate=function(signature){if(130!==(signature=strip0x(signature)).length)throw new Error("Wrong ethereum signature");return grindKey(signature.substring(0,64))},exports.getAccountPath=function(layer,application,ethereumAddress,index){const layerNum=int31(sha256Num(layer)),applicationNum=int31(sha256Num(application)),eth=u.hexToNumber(strip0x(ethereumAddress));return`m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth>>31n)}'/${index}`},exports.pedersen=pedersen,exports._poseidonMDS=_poseidonMDS,exports.poseidonBasic=poseidonBasic,exports.poseidonCreate=function(opts,mdsAttempt=0){const m=opts.rate+opts.capacity;if(!Number.isSafeInteger(mdsAttempt))throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);return poseidonBasic(opts,_poseidonMDS(opts.Fp,"HadesMDS",m,mdsAttempt))},exports.poseidonHash=poseidonHash,exports.poseidonHashFunc=function(x,y,fn=exports.poseidonSmall){return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x),u.bytesToNumberBE(y),fn))},exports.poseidonHashSingle=function(x,fn=exports.poseidonSmall){return fn([x,0n,1n])[0]},exports.poseidonHashMany=function(values,fn=exports.poseidonSmall){const{m,rate}=fn;if(!Array.isArray(values))throw new Error("bigint array expected in values");const padded=Array.from(values);padded.push(1n);for(;padded.length%rate!=0;)padded.push(0n);let state=new Array(m).fill(0n);for(let i=0;i<padded.length;i+=rate){for(let j=0;j<rate;j++){const item=padded[i+j];if(void 0===item)throw new Error("invalid index");if(void 0===state[j])throw new Error("state[j] is undefined");state[j]=state[j]+item}state=fn(state)}return state[0]};const sha3_1=__webpack_require__(27240),sha256_1=__webpack_require__(78112),utils_1=__webpack_require__(14762),modular_1=__webpack_require__(24967),poseidon_1=__webpack_require__(45920),weierstrass_1=__webpack_require__(91705),u=__webpack_require__(91484),_shortw_utils_1=__webpack_require__(73562),CURVE_ORDER=BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583");exports.MAX_VALUE=BigInt("0x800000000000000000000000000000000000000000000000000000000000000");function bits2int(bytes){for(;0===bytes[0];)bytes=bytes.subarray(1);const delta=8*bytes.length-252,num=u.bytesToNumberBE(bytes);return delta>0?num>>BigInt(delta):num}function hex0xToBytes(hex){return"string"==typeof hex&&1&(hex=strip0x(hex)).length&&(hex="0"+hex),u.hexToBytes(hex)}const curve=(0,weierstrass_1.weierstrass)({a:BigInt(1),b:BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),Fp:(0,modular_1.Field)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),n:CURVE_ORDER,nBitLength:252,Gx:BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),Gy:BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),h:BigInt(1),lowS:!1,...(0,_shortw_utils_1.getHash)(sha256_1.sha256),bits2int,bits2int_modN:bytes=>{const hex=u.bytesToNumberBE(bytes).toString(16);return 63===hex.length&&(bytes=hex0xToBytes(hex+"0")),(0,modular_1.mod)(bits2int(bytes),CURVE_ORDER)}});function ensureBytes(hex){return u.ensureBytes("","string"==typeof hex?hex0xToBytes(hex):hex)}function normalizePrivateKey(privKey){return u.bytesToHex(ensureBytes(privKey)).padStart(64,"0")}function getPublicKey(privKey,isCompressed=!1){return curve.getPublicKey(normalizePrivateKey(privKey),isCompressed)}function checkSignature(signature){const{r,s}=signature;if(r<0n||r>=exports.MAX_VALUE)throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);const w=(0,modular_1.invert)(s,CURVE_ORDER);if(w<0n||w>=exports.MAX_VALUE)throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`)}function checkMessage(msgHash){const bytes=ensureBytes(msgHash);if(u.bytesToNumberBE(bytes)>=exports.MAX_VALUE)throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);return bytes}exports._starkCurve=curve;const{CURVE,ProjectivePoint,Signature,utils}=curve;function extractX(bytes){return`0x${u.bytesToHex(bytes.subarray(1)).replace(/^0+/gm,"")}`}function strip0x(hex){return hex.replace(/^0x/i,"")}function grindKey(seed){const _seed=ensureBytes(seed),sha256mask=2n**256n,limit=sha256mask-(0,modular_1.mod)(sha256mask,CURVE_ORDER);for(let i=0;;i++){const key=sha256Num(u.concatBytes(_seed,u.numberToVarBytesBE(BigInt(i))));if(key<limit)return(0,modular_1.mod)(key,CURVE_ORDER).toString(16);if(1e5===i)throw new Error("grindKey is broken: tried 100k vals")}}exports.CURVE=CURVE,exports.ProjectivePoint=ProjectivePoint,exports.Signature=Signature,exports.utils=utils;const int31=n=>Number(2147483647n&n);const PEDERSEN_POINTS=[new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n,1713931329540660377023406109199410414810705867260802078187082345529207694986n,1n),new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n,1668503676786377725805489344771023921079126552019160156920634619255970485781n,1n),new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n,1798716007562728905295480679789526322175868328062420237419143593021674992973n,1n),new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n,113410276730064486255102093846540133784865286929052426931474106396135072156n,1n),new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n,776496453633298175483985398648758586525933812536653089401905292063708816422n,1n)];function pedersenPrecompute(p1,p2){const out=[];let p=p1;for(let i=0;i<248;i++)out.push(p),p=p.double();p=p2;for(let i=0;i<4;i++)out.push(p),p=p.double();return out}const PEDERSEN_POINTS1=pedersenPrecompute(PEDERSEN_POINTS[1],PEDERSEN_POINTS[2]),PEDERSEN_POINTS2=pedersenPrecompute(PEDERSEN_POINTS[3],PEDERSEN_POINTS[4]);function pedersenSingle(point,value,constants){let x=function(arg){let value;if("bigint"==typeof arg)value=arg;else if("number"==typeof arg){if(!Number.isSafeInteger(arg))throw new Error(`Invalid pedersenArg: ${arg}`);value=BigInt(arg)}else value=u.bytesToNumberBE(ensureBytes(arg));if(!(0n<=value&&value<curve.CURVE.Fp.ORDER))throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);return value}(value);for(let j=0;j<252;j++){const pt=constants[j];if(!pt)throw new Error("invalid constant index");if(pt.equals(point))throw new Error("Same point");0n!==(1n&x)&&(point=point.add(pt)),x>>=1n}return point}function pedersen(x,y){let point=PEDERSEN_POINTS[0];return point=pedersenSingle(point,x,PEDERSEN_POINTS1),point=pedersenSingle(point,y,PEDERSEN_POINTS2),extractX(point.toRawBytes(!0))}exports.computeHashOnElements=(data,fn=pedersen)=>[0,...data,data.length].reduce(((x,y)=>fn(x,y)));const MASK_250=u.bitMask(250);exports.keccak=data=>u.bytesToNumberBE((0,sha3_1.keccak_256)(data))&MASK_250;const sha256Num=data=>u.bytesToNumberBE((0,sha256_1.sha256)(data));function poseidonRoundConstant(Fp,name,idx){const val=Fp.fromBytes((0,sha256_1.sha256)((0,utils_1.utf8ToBytes)(`${name}${idx}`)));return Fp.create(val)}function _poseidonMDS(Fp,name,m,attempt=0){const x_values=[],y_values=[];for(let i=0;i<m;i++)x_values.push(poseidonRoundConstant(Fp,`${name}x`,attempt*m+i)),y_values.push(poseidonRoundConstant(Fp,`${name}y`,attempt*m+i));if(new Set([...x_values,...y_values]).size!==2*m)throw new Error("X and Y values are not distinct");return x_values.map((x=>y_values.map((y=>Fp.inv(Fp.sub(x,y))))))}exports.Fp251=(0,modular_1.Field)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));const MDS_SMALL=[[3,1,1],[1,-1,1],[1,1,-2]].map((i=>i.map(BigInt)));function poseidonBasic(opts,mds){if((0,modular_1.validateField)(opts.Fp),!Number.isSafeInteger(opts.rate)||!Number.isSafeInteger(opts.capacity))throw new Error(`Wrong poseidon opts: ${opts}`);const m=opts.rate+opts.capacity,rounds=opts.roundsFull+opts.roundsPartial,roundConstants=[];for(let i=0;i<rounds;i++){const row=[];for(let j=0;j<m;j++)row.push(poseidonRoundConstant(opts.Fp,"Hades",m*i+j));roundConstants.push(row)}const res=(0,poseidon_1.poseidon)({...opts,t:m,sboxPower:3,reversePartialPowIdx:!0,mds,roundConstants});return res.m=m,res.rate=opts.rate,res.capacity=opts.capacity,res}function poseidonHash(x,y,fn=exports.poseidonSmall){return fn([x,y,2n])[0]}exports.poseidonSmall=poseidonBasic({Fp:exports.Fp251,rate:2,capacity:1,roundsFull:8,roundsPartial:83},MDS_SMALL)},4862:module=>{"use strict";module.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},5142:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},5901:(module,__unused_webpack_exports,__webpack_require__)=>{var arrayLikeToArray=__webpack_require__(70079);module.exports=function(r){if(Array.isArray(r))return arrayLikeToArray(r)},module.exports.__esModule=!0,module.exports.default=module.exports},6993:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Mixin:()=>Mixin,decorate:()=>decorate,hasMixin:()=>hasMixin,mix:()=>mix,settings:()=>settings});const copyProps=(dest,src,exclude=[])=>{const props=Object.getOwnPropertyDescriptors(src);for(let prop of exclude)delete props[prop];Object.defineProperties(dest,props)},protoChain=(obj,currentChain=[obj])=>{const proto=Object.getPrototypeOf(obj);return null===proto?currentChain:protoChain(proto,[...currentChain,proto])},hardMixProtos=(ingredients,constructor,exclude=[])=>{var _a;const base=null!==(_a=((...objs)=>{if(0===objs.length)return;let commonProto;const protoChains=objs.map((obj=>protoChain(obj)));for(;protoChains.every((protoChain=>protoChain.length>0));){const protos=protoChains.map((protoChain=>protoChain.pop())),potentialCommonProto=protos[0];if(!protos.every((proto=>proto===potentialCommonProto)))break;commonProto=potentialCommonProto}return commonProto})(...ingredients))&&void 0!==_a?_a:Object.prototype,mixedProto=Object.create(base),visitedProtos=protoChain(base);for(let prototype of ingredients){let protos=protoChain(prototype);for(let i=protos.length-1;i>=0;i--){let newProto=protos[i];-1===visitedProtos.indexOf(newProto)&&(copyProps(mixedProto,newProto,["constructor",...exclude]),visitedProtos.push(newProto))}}return mixedProto.constructor=constructor,mixedProto},unique=arr=>arr.filter(((e,i)=>arr.indexOf(e)==i)),getIngredientWithProp=(prop,ingredients)=>{const protoChains=ingredients.map((ingredient=>protoChain(ingredient)));let protoDepth=0,protosAreLeftToSearch=!0;for(;protosAreLeftToSearch;){protosAreLeftToSearch=!1;for(let i=ingredients.length-1;i>=0;i--){const searchTarget=protoChains[i][protoDepth];if(null!=searchTarget&&(protosAreLeftToSearch=!0,null!=Object.getOwnPropertyDescriptor(searchTarget,prop)))return protoChains[i][0]}protoDepth++}},proxyMix=(ingredients,prototype=Object.prototype)=>new Proxy({},{getPrototypeOf:()=>prototype,setPrototypeOf(){throw Error("Cannot set prototype of Proxies created by ts-mixer")},getOwnPropertyDescriptor:(_,prop)=>Object.getOwnPropertyDescriptor(getIngredientWithProp(prop,ingredients)||{},prop),defineProperty(){throw new Error("Cannot define new properties on Proxies created by ts-mixer")},has:(_,prop)=>void 0!==getIngredientWithProp(prop,ingredients)||void 0!==prototype[prop],get:(_,prop)=>(getIngredientWithProp(prop,ingredients)||prototype)[prop],set(_,prop,val){const ingredientWithProp=getIngredientWithProp(prop,ingredients);if(void 0===ingredientWithProp)throw new Error("Cannot set new properties on Proxies created by ts-mixer");return ingredientWithProp[prop]=val,!0},deleteProperty(){throw new Error("Cannot delete properties on Proxies created by ts-mixer")},ownKeys:()=>ingredients.map(Object.getOwnPropertyNames).reduce(((prev,curr)=>curr.concat(prev.filter((key=>curr.indexOf(key)<0)))))}),softMixProtos=(ingredients,constructor)=>proxyMix([...ingredients,{constructor}]),settings={initFunction:null,staticsStrategy:"copy",prototypeStrategy:"copy",decoratorInheritance:"deep"},mixins=new Map,getMixinsForClass=clazz=>mixins.get(clazz),registerMixins=(mixedClass,constituents)=>mixins.set(mixedClass,constituents),hasMixin=(instance,mixin)=>{if(instance instanceof mixin)return!0;const constructor=instance.constructor,visited=new Set;let frontier=new Set;for(frontier.add(constructor);frontier.size>0;){if(frontier.has(mixin))return!0;frontier.forEach((item=>visited.add(item)));const newFrontier=new Set;frontier.forEach((item=>{var _a;const itemConstituents=null!==(_a=mixins.get(item))&&void 0!==_a?_a:protoChain(item.prototype).map((proto=>proto.constructor)).filter((item=>null!==item));itemConstituents&&itemConstituents.forEach((constituent=>{visited.has(constituent)||frontier.has(constituent)||newFrontier.add(constituent)}))})),frontier=newFrontier}return!1},mergeObjectsOfDecorators=(o1,o2)=>{var _a,_b;const allKeys=unique([...Object.getOwnPropertyNames(o1),...Object.getOwnPropertyNames(o2)]),mergedObject={};for(let key of allKeys)mergedObject[key]=unique([...null!==(_a=null==o1?void 0:o1[key])&&void 0!==_a?_a:[],...null!==(_b=null==o2?void 0:o2[key])&&void 0!==_b?_b:[]]);return mergedObject},mergePropertyAndMethodDecorators=(d1,d2)=>{var _a,_b,_c,_d;return{property:mergeObjectsOfDecorators(null!==(_a=null==d1?void 0:d1.property)&&void 0!==_a?_a:{},null!==(_b=null==d2?void 0:d2.property)&&void 0!==_b?_b:{}),method:mergeObjectsOfDecorators(null!==(_c=null==d1?void 0:d1.method)&&void 0!==_c?_c:{},null!==(_d=null==d2?void 0:d2.method)&&void 0!==_d?_d:{})}},mergeDecorators=(d1,d2)=>{var _a,_b,_c,_d,_e,_f;return{class:unique([...null!==(_a=null==d1?void 0:d1.class)&&void 0!==_a?_a:[],...null!==(_b=null==d2?void 0:d2.class)&&void 0!==_b?_b:[]]),static:mergePropertyAndMethodDecorators(null!==(_c=null==d1?void 0:d1.static)&&void 0!==_c?_c:{},null!==(_d=null==d2?void 0:d2.static)&&void 0!==_d?_d:{}),instance:mergePropertyAndMethodDecorators(null!==(_e=null==d1?void 0:d1.instance)&&void 0!==_e?_e:{},null!==(_f=null==d2?void 0:d2.instance)&&void 0!==_f?_f:{})}},decorators=new Map,deepDecoratorSearch=(...classes)=>{const decoratorsForClassChain=((...classes)=>{var _a;const allClasses=new Set,frontier=new Set([...classes]);for(;frontier.size>0;)for(let clazz of frontier){const newClasses=[...protoChain(clazz.prototype).map((proto=>proto.constructor)),...null!==(_a=getMixinsForClass(clazz))&&void 0!==_a?_a:[]].filter((c=>!allClasses.has(c)));for(let newClass of newClasses)frontier.add(newClass);allClasses.add(clazz),frontier.delete(clazz)}return[...allClasses]})(...classes).map((clazz=>decorators.get(clazz))).filter((decorators=>!!decorators));return 0==decoratorsForClassChain.length?{}:1==decoratorsForClassChain.length?decoratorsForClassChain[0]:decoratorsForClassChain.reduce(((d1,d2)=>mergeDecorators(d1,d2)))},directDecoratorSearch=(...classes)=>{const classDecorators=classes.map((clazz=>getDecoratorsForClass(clazz)));return 0===classDecorators.length?{}:1===classDecorators.length?classDecorators[0]:classDecorators.reduce(((d1,d2)=>mergeDecorators(d1,d2)))},getDecoratorsForClass=clazz=>{let decoratorsForClass=decorators.get(clazz);return decoratorsForClass||(decoratorsForClass={},decorators.set(clazz,decoratorsForClass)),decoratorsForClass},decorate=decorator=>(...args)=>1===args.length?(decorator=>clazz=>{const decoratorsForClass=getDecoratorsForClass(clazz);let classDecorators=decoratorsForClass.class;return classDecorators||(classDecorators=[],decoratorsForClass.class=classDecorators),classDecorators.push(decorator),decorator(clazz)})(decorator)(args[0]):(decorator=>(object,key,...otherArgs)=>{var _a,_b,_c;const decoratorTargetType="function"==typeof object?"static":"instance",decoratorType="function"==typeof object[key]?"method":"property",clazz="static"===decoratorTargetType?object:object.constructor,decoratorsForClass=getDecoratorsForClass(clazz),decoratorsForTargetType=null!==(_a=null==decoratorsForClass?void 0:decoratorsForClass[decoratorTargetType])&&void 0!==_a?_a:{};decoratorsForClass[decoratorTargetType]=decoratorsForTargetType;let decoratorsForType=null!==(_b=null==decoratorsForTargetType?void 0:decoratorsForTargetType[decoratorType])&&void 0!==_b?_b:{};decoratorsForTargetType[decoratorType]=decoratorsForType;let decoratorsForKey=null!==(_c=null==decoratorsForType?void 0:decoratorsForType[key])&&void 0!==_c?_c:[];return decoratorsForType[key]=decoratorsForKey,decoratorsForKey.push(decorator),decorator(object,key,...otherArgs)})(decorator)(...args);function Mixin(...constructors){var _a,_b,_c;const prototypes=constructors.map((constructor=>constructor.prototype)),initFunctionName=settings.initFunction;if(null!==initFunctionName){const initFunctions=prototypes.map((proto=>proto[initFunctionName])).filter((func=>"function"==typeof func)),combinedInitFunction=function(...args){for(let initFunction of initFunctions)initFunction.apply(this,args)},extraProto={[initFunctionName]:combinedInitFunction};prototypes.push(extraProto)}function MixedClass(...args){for(const constructor of constructors)copyProps(this,new constructor(...args));null!==initFunctionName&&"function"==typeof this[initFunctionName]&&this[initFunctionName].apply(this,args)}MixedClass.prototype="copy"===settings.prototypeStrategy?hardMixProtos(prototypes,MixedClass):softMixProtos(prototypes,MixedClass),Object.setPrototypeOf(MixedClass,"copy"===settings.staticsStrategy?hardMixProtos(constructors,null,["prototype"]):proxyMix(constructors,Function.prototype));let DecoratedMixedClass=MixedClass;if("none"!==settings.decoratorInheritance){const classDecorators="deep"===settings.decoratorInheritance?deepDecoratorSearch(...constructors):directDecoratorSearch(...constructors);for(let decorator of null!==(_a=null==classDecorators?void 0:classDecorators.class)&&void 0!==_a?_a:[]){const result=decorator(DecoratedMixedClass);result&&(DecoratedMixedClass=result)}applyPropAndMethodDecorators(null!==(_b=null==classDecorators?void 0:classDecorators.static)&&void 0!==_b?_b:{},DecoratedMixedClass),applyPropAndMethodDecorators(null!==(_c=null==classDecorators?void 0:classDecorators.instance)&&void 0!==_c?_c:{},DecoratedMixedClass.prototype)}return registerMixins(DecoratedMixedClass,constructors),DecoratedMixedClass}const applyPropAndMethodDecorators=(propAndMethodDecorators,target)=>{const propDecorators=propAndMethodDecorators.property,methodDecorators=propAndMethodDecorators.method;if(propDecorators)for(let key in propDecorators)for(let decorator of propDecorators[key])decorator(target,key);if(methodDecorators)for(let key in methodDecorators)for(let decorator of methodDecorators[key])decorator(target,key,Object.getOwnPropertyDescriptor(target,key))},mix=(...ingredients)=>decoratedClass=>{const mixedClass=Mixin(...ingredients.concat([decoratedClass]));return Object.defineProperty(mixedClass,"name",{value:decoratedClass.name,writable:!1}),mixedClass}},7014:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},8143:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.PAYMASTER_API=exports.WALLET_API=exports.API=void 0,__exportStar(__webpack_require__(25076),exports),exports.API=__webpack_require__(25076),__exportStar(__webpack_require__(44540),exports),exports.WALLET_API=__webpack_require__(44540),exports.PAYMASTER_API=__webpack_require__(11886)},8510:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.encodeToCurve=exports.hashToCurve=exports.schnorr=exports.secp256k1=void 0;const sha256_1=__webpack_require__(81696),utils_1=__webpack_require__(81130),_shortw_utils_js_1=__webpack_require__(73562),hash_to_curve_js_1=__webpack_require__(71761),modular_js_1=__webpack_require__(24967),utils_js_1=__webpack_require__(91484),weierstrass_js_1=__webpack_require__(91705),secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(a,b)=>(a+b/_2n)/b;function sqrtMod(y){const P=secp256k1P,_3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22),_23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88),b2=y*y*y%P,b3=b2*b2*y%P,b6=(0,modular_js_1.pow2)(b3,_3n,P)*b3%P,b9=(0,modular_js_1.pow2)(b6,_3n,P)*b3%P,b11=(0,modular_js_1.pow2)(b9,_2n,P)*b2%P,b22=(0,modular_js_1.pow2)(b11,_11n,P)*b11%P,b44=(0,modular_js_1.pow2)(b22,_22n,P)*b22%P,b88=(0,modular_js_1.pow2)(b44,_44n,P)*b44%P,b176=(0,modular_js_1.pow2)(b88,_88n,P)*b88%P,b220=(0,modular_js_1.pow2)(b176,_44n,P)*b44%P,b223=(0,modular_js_1.pow2)(b220,_3n,P)*b3%P,t1=(0,modular_js_1.pow2)(b223,_23n,P)*b22%P,t2=(0,modular_js_1.pow2)(t1,_6n,P)*b2%P,root=(0,modular_js_1.pow2)(t2,_2n,P);if(!Fpk1.eql(Fpk1.sqr(root),y))throw new Error("Cannot find square root");return root}const Fpk1=(0,modular_js_1.Field)(secp256k1P,void 0,void 0,{sqrt:sqrtMod});exports.secp256k1=(0,_shortw_utils_js_1.createCurve)({a:BigInt(0),b:BigInt(7),Fp:Fpk1,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:k=>{const n=secp256k1N,a1=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2=a1,POW_2_128=BigInt("0x100000000000000000000000000000000"),c1=divNearest(b2*k,n),c2=divNearest(-b1*k,n);let k1=(0,modular_js_1.mod)(k-c1*a1-c2*a2,n),k2=(0,modular_js_1.mod)(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128,k2neg=k2>POW_2_128;if(k1neg&&(k1=n-k1),k2neg&&(k2=n-k2),k1>POW_2_128||k2>POW_2_128)throw new Error("splitScalar: Endomorphism failed, k="+k);return{k1neg,k1,k2neg,k2}}}},sha256_1.sha256);const _0n=BigInt(0),TAGGED_HASH_PREFIXES={};function taggedHash(tag,...messages){let tagP=TAGGED_HASH_PREFIXES[tag];if(void 0===tagP){const tagH=(0,sha256_1.sha256)(Uint8Array.from(tag,(c=>c.charCodeAt(0))));tagP=(0,utils_js_1.concatBytes)(tagH,tagH),TAGGED_HASH_PREFIXES[tag]=tagP}return(0,sha256_1.sha256)((0,utils_js_1.concatBytes)(tagP,...messages))}const pointToBytes=point=>point.toRawBytes(!0).slice(1),numTo32b=n=>(0,utils_js_1.numberToBytesBE)(n,32),modP=x=>(0,modular_js_1.mod)(x,secp256k1P),modN=x=>(0,modular_js_1.mod)(x,secp256k1N),Point=exports.secp256k1.ProjectivePoint;function schnorrGetExtPubKey(priv){let d_=exports.secp256k1.utils.normPrivateKeyToScalar(priv),p=Point.fromPrivateKey(d_);return{scalar:p.hasEvenY()?d_:modN(-d_),bytes:pointToBytes(p)}}function lift_x(x){(0,utils_js_1.aInRange)("x",x,_1n,secp256k1P);const xx=modP(x*x);let y=sqrtMod(modP(xx*x+BigInt(7)));y%_2n!==_0n&&(y=modP(-y));const p=new Point(x,y,_1n);return p.assertValidity(),p}const num=utils_js_1.bytesToNumberBE;function challenge(...args){return modN(num(taggedHash("BIP0340/challenge",...args)))}function schnorrGetPublicKey(privateKey){return schnorrGetExtPubKey(privateKey).bytes}function schnorrSign(message,privateKey,auxRand=(0,utils_1.randomBytes)(32)){const m=(0,utils_js_1.ensureBytes)("message",message),{bytes:px,scalar:d}=schnorrGetExtPubKey(privateKey),a=(0,utils_js_1.ensureBytes)("auxRand",auxRand,32),t=numTo32b(d^num(taggedHash("BIP0340/aux",a))),rand=taggedHash("BIP0340/nonce",t,px,m),k_=modN(num(rand));if(k_===_0n)throw new Error("sign failed: k is zero");const{bytes:rx,scalar:k}=schnorrGetExtPubKey(k_),e=challenge(rx,px,m),sig=new Uint8Array(64);if(sig.set(rx,0),sig.set(numTo32b(modN(k+e*d)),32),!schnorrVerify(sig,m,px))throw new Error("sign: Invalid signature produced");return sig}function schnorrVerify(signature,message,publicKey){const sig=(0,utils_js_1.ensureBytes)("signature",signature,64),m=(0,utils_js_1.ensureBytes)("message",message),pub=(0,utils_js_1.ensureBytes)("publicKey",publicKey,32);try{const P=lift_x(num(pub)),r=num(sig.subarray(0,32));if(!(0,utils_js_1.inRange)(r,_1n,secp256k1P))return!1;const s=num(sig.subarray(32,64));if(!(0,utils_js_1.inRange)(s,_1n,secp256k1N))return!1;const e=challenge(numTo32b(r),pointToBytes(P),m),R=(Q=P,a=s,b=modN(-e),Point.BASE.multiplyAndAddUnsafe(Q,a,b));return!(!R||!R.hasEvenY()||R.toAffine().x!==r)}catch(error){return!1}var Q,a,b}exports.schnorr={getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:exports.secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE:utils_js_1.numberToBytesBE,bytesToNumberBE:utils_js_1.bytesToNumberBE,taggedHash,mod:modular_js_1.mod}};const isoMap=(()=>(0,hash_to_curve_js_1.isogenyMap)(Fpk1,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((i=>i.map((j=>BigInt(j)))))))(),mapSWU=(()=>(0,weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:Fpk1.create(BigInt("-11"))}))(),htf=(()=>(0,hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint,(scalars=>{const{x,y}=mapSWU(Fpk1.create(scalars[0]));return isoMap(x,y)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:Fpk1.ORDER,m:1,k:128,expand:"xmd",hash:sha256_1.sha256}))();exports.hashToCurve=htf.hashToCurve,exports.encodeToCurve=htf.encodeToCurve},8555:(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.BASE64_SVG_PREFIX=void 0;exports.BASE64_SVG_PREFIX="data:image/svg+xml;base64,"},8603:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sha224=exports.sha256=exports.SHA256=void 0;const _md_js_1=__webpack_require__(91134),utils_js_1=__webpack_require__(61667),SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends _md_js_1.HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=(0,utils_js_1.rotr)(W15,7)^(0,utils_js_1.rotr)(W15,18)^W15>>>3,s1=(0,utils_js_1.rotr)(W2,17)^(0,utils_js_1.rotr)(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+((0,utils_js_1.rotr)(E,6)^(0,utils_js_1.rotr)(E,11)^(0,utils_js_1.rotr)(E,25))+(0,_md_js_1.Chi)(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=((0,utils_js_1.rotr)(A,2)^(0,utils_js_1.rotr)(A,13)^(0,utils_js_1.rotr)(A,22))+(0,_md_js_1.Maj)(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}exports.SHA256=SHA256;class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}exports.sha256=(0,utils_js_1.wrapConstructor)((()=>new SHA256)),exports.sha224=(0,utils_js_1.wrapConstructor)((()=>new SHA224))},9113:(__unused_webpack_module,exports)=>{"use strict";function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(b,...lengths){if(!((a=b)instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name))throw new Error("Uint8Array expected");var a;if(lengths.length>0&&!lengths.includes(b.length))throw new Error("Uint8Array expected of length "+lengths+", got length="+b.length)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.anumber=anumber,exports.abytes=abytes,exports.ahash=function(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber(h.outputLen),anumber(h.blockLen)},exports.aexists=function(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")},exports.aoutput=function(out,instance){abytes(out);const min=instance.outputLen;if(out.length<min)throw new Error("digestInto() expects output buffer of length at least "+min)}},9598:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.utils=exports.schnorr=exports.verify=exports.signSync=exports.sign=exports.getSharedSecret=exports.recoverPublicKey=exports.getPublicKey=exports.Signature=exports.Point=exports.CURVE=void 0;const nodeCrypto=__webpack_require__(14923),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});exports.CURVE=CURVE;const divNearest=(a,b)=>(a+b/_2n)/b,endo={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(k){const{n}=CURVE,a1=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2=a1,POW_2_128=BigInt("0x100000000000000000000000000000000"),c1=divNearest(b2*k,n),c2=divNearest(-b1*k,n);let k1=mod(k-c1*a1-c2*a2,n),k2=mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128,k2neg=k2>POW_2_128;if(k1neg&&(k1=n-k1),k2neg&&(k2=n-k2),k1>POW_2_128||k2>POW_2_128)throw new Error("splitScalarEndo: Endomorphism failed, k="+k);return{k1neg,k1,k2neg,k2}}};function weierstrass(x){const{a,b}=CURVE,x2=mod(x*x),x3=mod(x2*x);return mod(x3+a*x+b)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(message){super(message)}}function assertJacPoint(other){if(!(other instanceof JacobianPoint))throw new TypeError("JacobianPoint expected")}class JacobianPoint{constructor(x,y,z){this.x=x,this.y=y,this.z=z}static fromAffine(p){if(!(p instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return p.equals(Point.ZERO)?JacobianPoint.ZERO:new JacobianPoint(p.x,p.y,_1n)}static toAffineBatch(points){const toInv=function(nums,p=CURVE.P){const scratch=new Array(nums.length),inverted=invert(nums.reduce(((acc,num,i)=>num===_0n?acc:(scratch[i]=acc,mod(acc*num,p))),_1n),p);return nums.reduceRight(((acc,num,i)=>num===_0n?acc:(scratch[i]=mod(acc*scratch[i],p),mod(acc*num,p))),inverted),scratch}(points.map((p=>p.z)));return points.map(((p,i)=>p.toAffine(toInv[i])))}static normalizeZ(points){return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine)}equals(other){assertJacPoint(other);const{x:X1,y:Y1,z:Z1}=this,{x:X2,y:Y2,z:Z2}=other,Z1Z1=mod(Z1*Z1),Z2Z2=mod(Z2*Z2),U1=mod(X1*Z2Z2),U2=mod(X2*Z1Z1),S1=mod(mod(Y1*Z2)*Z2Z2),S2=mod(mod(Y2*Z1)*Z1Z1);return U1===U2&&S1===S2}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){const{x:X1,y:Y1,z:Z1}=this,A=mod(X1*X1),B=mod(Y1*Y1),C=mod(B*B),x1b=X1+B,D=mod(_2n*(mod(x1b*x1b)-A-C)),E=mod(_3n*A),F=mod(E*E),X3=mod(F-_2n*D),Y3=mod(E*(D-X3)-_8n*C),Z3=mod(_2n*Y1*Z1);return new JacobianPoint(X3,Y3,Z3)}add(other){assertJacPoint(other);const{x:X1,y:Y1,z:Z1}=this,{x:X2,y:Y2,z:Z2}=other;if(X2===_0n||Y2===_0n)return this;if(X1===_0n||Y1===_0n)return other;const Z1Z1=mod(Z1*Z1),Z2Z2=mod(Z2*Z2),U1=mod(X1*Z2Z2),U2=mod(X2*Z1Z1),S1=mod(mod(Y1*Z2)*Z2Z2),S2=mod(mod(Y2*Z1)*Z1Z1),H=mod(U2-U1),r=mod(S2-S1);if(H===_0n)return r===_0n?this.double():JacobianPoint.ZERO;const HH=mod(H*H),HHH=mod(H*HH),V=mod(U1*HH),X3=mod(r*r-HHH-_2n*V),Y3=mod(r*(V-X3)-S1*HHH),Z3=mod(Z1*Z2*H);return new JacobianPoint(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}multiplyUnsafe(scalar){const P0=JacobianPoint.ZERO;if("bigint"==typeof scalar&&scalar===_0n)return P0;let n=normalizeScalar(scalar);if(n===_1n)return this;if(!USE_ENDOMORPHISM){let p=P0,d=this;for(;n>_0n;)n&_1n&&(p=p.add(d)),d=d.double(),n>>=_1n;return p}let{k1neg,k1,k2neg,k2}=endo.splitScalar(n),k1p=P0,k2p=P0,d=this;for(;k1>_0n||k2>_0n;)k1&_1n&&(k1p=k1p.add(d)),k2&_1n&&(k2p=k2p.add(d)),d=d.double(),k1>>=_1n,k2>>=_1n;return k1neg&&(k1p=k1p.negate()),k2neg&&(k2p=k2p.negate()),k2p=new JacobianPoint(mod(k2p.x*endo.beta),k2p.y,k2p.z),k1p.add(k2p)}precomputeWindow(W){const windows=USE_ENDOMORPHISM?128/W+1:256/W+1,points=[];let p=this,base=p;for(let window=0;window<windows;window++){base=p,points.push(base);for(let i=1;i<2**(W-1);i++)base=base.add(p),points.push(base);p=base.double()}return points}wNAF(n,affinePoint){!affinePoint&&this.equals(JacobianPoint.BASE)&&(affinePoint=Point.BASE);const W=affinePoint&&affinePoint._WINDOW_SIZE||1;if(256%W)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let precomputes=affinePoint&&pointPrecomputes.get(affinePoint);precomputes||(precomputes=this.precomputeWindow(W),affinePoint&&1!==W&&(precomputes=JacobianPoint.normalizeZ(precomputes),pointPrecomputes.set(affinePoint,precomputes)));let p=JacobianPoint.ZERO,f=JacobianPoint.BASE;const windows=1+(USE_ENDOMORPHISM?128/W:256/W),windowSize=2**(W-1),mask=BigInt(2**W-1),maxNumber=2**W,shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy,wbits>windowSize&&(wbits-=maxNumber,n+=_1n);const offset1=offset,offset2=offset+Math.abs(wbits)-1,cond1=window%2!=0,cond2=wbits<0;0===wbits?f=f.add(constTimeNegate(cond1,precomputes[offset1])):p=p.add(constTimeNegate(cond2,precomputes[offset2]))}return{p,f}}multiply(scalar,affinePoint){let point,fake,n=normalizeScalar(scalar);if(USE_ENDOMORPHISM){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1,affinePoint),{p:k2p,f:f2p}=this.wNAF(k2,affinePoint);k1p=constTimeNegate(k1neg,k1p),k2p=constTimeNegate(k2neg,k2p),k2p=new JacobianPoint(mod(k2p.x*endo.beta),k2p.y,k2p.z),point=k1p.add(k2p),fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n,affinePoint);point=p,fake=f}return JacobianPoint.normalizeZ([point,fake])[0]}toAffine(invZ){const{x,y,z}=this,is0=this.equals(JacobianPoint.ZERO);null==invZ&&(invZ=is0?_8n:invert(z));const iz1=invZ,iz2=mod(iz1*iz1),iz3=mod(iz2*iz1),ax=mod(x*iz2),ay=mod(y*iz3),zz=mod(z*iz1);if(is0)return Point.ZERO;if(zz!==_1n)throw new Error("invZ was invalid");return new Point(ax,ay)}}function constTimeNegate(condition,item){const neg=item.negate();return condition?neg:item}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n),JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);const pointPrecomputes=new WeakMap;class Point{constructor(x,y){this.x=x,this.y=y}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(bytes){const isShort=32===bytes.length,x=bytesToNumber(isShort?bytes:bytes.subarray(1));if(!isValidFieldElement(x))throw new Error("Point is not on curve");let y=function(x){const{P}=CURVE,_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22),_23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88),b2=x*x*x%P,b3=b2*b2*x%P,b6=pow2(b3,_3n)*b3%P,b9=pow2(b6,_3n)*b3%P,b11=pow2(b9,_2n)*b2%P,b22=pow2(b11,_11n)*b11%P,b44=pow2(b22,_22n)*b22%P,b88=pow2(b44,_44n)*b44%P,b176=pow2(b88,_88n)*b88%P,b220=pow2(b176,_44n)*b44%P,b223=pow2(b220,_3n)*b3%P,t1=pow2(b223,_23n)*b22%P,t2=pow2(t1,_6n)*b2%P,rt=pow2(t2,_2n);if(rt*rt%P!==x)throw new Error("Cannot find square root");return rt}(weierstrass(x));const isYOdd=(y&_1n)===_1n;if(isShort)isYOdd&&(y=mod(-y));else{!(1&~bytes[0])!==isYOdd&&(y=mod(-y))}const point=new Point(x,y);return point.assertValidity(),point}static fromUncompressedHex(bytes){const x=bytesToNumber(bytes.subarray(1,33)),y=bytesToNumber(bytes.subarray(33,65)),point=new Point(x,y);return point.assertValidity(),point}static fromHex(hex){const bytes=ensureBytes(hex),len=bytes.length,header=bytes[0];if(32===len)return this.fromCompressedHex(bytes);if(33===len&&(2===header||3===header))return this.fromCompressedHex(bytes);if(65===len&&4===header)return this.fromUncompressedHex(bytes);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`)}static fromPrivateKey(privateKey){return Point.BASE.multiply(normalizePrivateKey(privateKey))}static fromSignature(msgHash,signature,recovery){const{r,s}=normalizeSignature(signature);if(![0,1,2,3].includes(recovery))throw new Error("Cannot recover: invalid recovery bit");const h=truncateHash(ensureBytes(msgHash)),{n}=CURVE,radj=2===recovery||3===recovery?r+n:r,rinv=invert(radj,n),u1=mod(-h*rinv,n),u2=mod(s*rinv,n),prefix=1&recovery?"03":"02",R=Point.fromHex(prefix+numTo32bStr(radj)),Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error("Cannot recover signature: point at infinify");return Q.assertValidity(),Q}toRawBytes(isCompressed=!1){return hexToBytes(this.toHex(isCompressed))}toHex(isCompressed=!1){const x=numTo32bStr(this.x);if(isCompressed){return`${this.hasEvenY()?"02":"03"}${x}`}return`04${x}${numTo32bStr(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const msg="Point is not on elliptic curve",{x,y}=this;if(!isValidFieldElement(x)||!isValidFieldElement(y))throw new Error(msg);const left=mod(y*y);if(mod(left-weierstrass(x))!==_0n)throw new Error(msg)}equals(other){return this.x===other.x&&this.y===other.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(other){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine()}subtract(other){return this.add(other.negate())}multiply(scalar){return JacobianPoint.fromAffine(this).multiply(scalar,this).toAffine()}multiplyAndAddUnsafe(Q,a,b){const P=JacobianPoint.fromAffine(this),aP=a===_0n||a===_1n||this!==Point.BASE?P.multiplyUnsafe(a):P.multiply(a),bQ=JacobianPoint.fromAffine(Q).multiplyUnsafe(b),sum=aP.add(bQ);return sum.equals(JacobianPoint.ZERO)?void 0:sum.toAffine()}}function sliceDER(s){return Number.parseInt(s[0],16)>=8?"00"+s:s}function parseDERInt(data){if(data.length<2||2!==data[0])throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);const len=data[1],res=data.subarray(2,len+2);if(!len||res.length!==len)throw new Error("Invalid signature integer: wrong length");if(0===res[0]&&res[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(res),left:data.subarray(len+2)}}exports.Point=Point,Point.BASE=new Point(CURVE.Gx,CURVE.Gy),Point.ZERO=new Point(_0n,_0n);class Signature{constructor(r,s){this.r=r,this.s=s,this.assertValidity()}static fromCompact(hex){const arr=hex instanceof Uint8Array,name="Signature.fromCompact";if("string"!=typeof hex&&!arr)throw new TypeError(`${name}: Expected string or Uint8Array`);const str=arr?bytesToHex(hex):hex;if(128!==str.length)throw new Error(`${name}: Expected 64-byte hex`);return new Signature(hexToNumber(str.slice(0,64)),hexToNumber(str.slice(64,128)))}static fromDER(hex){const arr=hex instanceof Uint8Array;if("string"!=typeof hex&&!arr)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s}=function(data){if(data.length<2||48!=data[0])throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);if(data[1]!==data.length-2)throw new Error("Invalid signature: incorrect length");const{data:r,left:sBytes}=parseDERInt(data.subarray(2)),{data:s,left:rBytesLeft}=parseDERInt(sBytes);if(rBytesLeft.length)throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);return{r,s}}(arr?hex:hexToBytes(hex));return new Signature(r,s)}static fromHex(hex){return this.fromDER(hex)}assertValidity(){const{r,s}=this;if(!isWithinCurveOrder(r))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(s))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const HALF=CURVE.n>>_1n;return this.s>HALF}normalizeS(){return this.hasHighS()?new Signature(this.r,mod(-this.s,CURVE.n)):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){const sHex=sliceDER(numberToHexUnpadded(this.s)),rHex=sliceDER(numberToHexUnpadded(this.r)),sHexL=sHex.length/2,rHexL=rHex.length/2,sLen=numberToHexUnpadded(sHexL),rLen=numberToHexUnpadded(rHexL);return`30${numberToHexUnpadded(rHexL+sHexL+4)}02${rLen}${rHex}02${sLen}${sHex}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...arrays){if(!arrays.every((b=>b instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===arrays.length)return arrays[0];const length=arrays.reduce(((a,arr)=>a+arr.length),0),result=new Uint8Array(length);for(let i=0,pad=0;i<arrays.length;i++){const arr=arrays[i];result.set(arr,pad),pad+=arr.length}return result}exports.Signature=Signature;const hexes=Array.from({length:256},((v,i)=>i.toString(16).padStart(2,"0")));function bytesToHex(uint8a){if(!(uint8a instanceof Uint8Array))throw new Error("Expected Uint8Array");let hex="";for(let i=0;i<uint8a.length;i++)hex+=hexes[uint8a[i]];return hex}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(num){if("bigint"!=typeof num)throw new Error("Expected bigint");if(!(_0n<=num&&num<POW_2_256))throw new Error("Expected number 0 <= n < 2^256");return num.toString(16).padStart(64,"0")}function numTo32b(num){const b=hexToBytes(numTo32bStr(num));if(32!==b.length)throw new Error("Error: expected 32 bytes");return b}function numberToHexUnpadded(num){const hex=num.toString(16);return 1&hex.length?`0${hex}`:hex}function hexToNumber(hex){if("string"!=typeof hex)throw new TypeError("hexToNumber: expected string, got "+typeof hex);return BigInt(`0x${hex}`)}function hexToBytes(hex){if("string"!=typeof hex)throw new TypeError("hexToBytes: expected string, got "+typeof hex);if(hex.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+hex.length);const array=new Uint8Array(hex.length/2);for(let i=0;i<array.length;i++){const j=2*i,hexByte=hex.slice(j,j+2),byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error("Invalid byte sequence");array[i]=byte}return array}function bytesToNumber(bytes){return hexToNumber(bytesToHex(bytes))}function ensureBytes(hex){return hex instanceof Uint8Array?Uint8Array.from(hex):hexToBytes(hex)}function normalizeScalar(num){if("number"==typeof num&&Number.isSafeInteger(num)&&num>0)return BigInt(num);if("bigint"==typeof num&&isWithinCurveOrder(num))return num;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(a,b=CURVE.P){const result=a%b;return result>=_0n?result:b+result}function pow2(x,power){const{P}=CURVE;let res=x;for(;power-- >_0n;)res*=res,res%=P;return res}function invert(number,modulo=CURVE.P){if(number===_0n||modulo<=_0n)throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);let a=mod(number,modulo),b=modulo,x=_0n,y=_1n,u=_1n,v=_0n;for(;a!==_0n;){const q=b/a,r=b%a,m=x-u*q,n=y-v*q;b=a,a=r,x=u,y=v,u=m,v=n}if(b!==_1n)throw new Error("invert: does not exist");return mod(x,modulo)}function truncateHash(hash,truncateOnly=!1){const h=function(bytes){const delta=8*bytes.length-256,num=bytesToNumber(bytes);return delta>0?num>>BigInt(delta):num}(hash);if(truncateOnly)return h;const{n}=CURVE;return h>=n?h-n:h}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(hashLen,qByteLen){if(this.hashLen=hashLen,this.qByteLen=qByteLen,"number"!=typeof hashLen||hashLen<2)throw new Error("hashLen must be a number");if("number"!=typeof qByteLen||qByteLen<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(hashLen).fill(1),this.k=new Uint8Array(hashLen).fill(0),this.counter=0}hmac(...values){return exports.utils.hmacSha256(this.k,...values)}hmacSync(...values){return _hmacSha256Sync(this.k,...values)}checkSync(){if("function"!=typeof _hmacSha256Sync)throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(seed=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),seed),this.v=await this.hmac(this.v),0!==seed.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),seed),this.v=await this.hmac(this.v))}reseedSync(seed=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),seed),this.v=this.hmacSync(this.v),0!==seed.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),seed),this.v=this.hmacSync(this.v))}async generate(){this.incr();let len=0;const out=[];for(;len<this.qByteLen;){this.v=await this.hmac(this.v);const sl=this.v.slice();out.push(sl),len+=this.v.length}return concatBytes(...out)}generateSync(){this.checkSync(),this.incr();let len=0;const out=[];for(;len<this.qByteLen;){this.v=this.hmacSync(this.v);const sl=this.v.slice();out.push(sl),len+=this.v.length}return concatBytes(...out)}}function isWithinCurveOrder(num){return _0n<num&&num<CURVE.n}function isValidFieldElement(num){return _0n<num&&num<CURVE.P}function kmdToSig(kBytes,m,d,lowS=!0){const{n}=CURVE,k=truncateHash(kBytes,!0);if(!isWithinCurveOrder(k))return;const kinv=invert(k,n),q=Point.BASE.multiply(k),r=mod(q.x,n);if(r===_0n)return;const s=mod(kinv*mod(m+d*r,n),n);if(s===_0n)return;let sig=new Signature(r,s),recovery=(q.x===sig.r?0:2)|Number(q.y&_1n);return lowS&&sig.hasHighS()&&(sig=sig.normalizeS(),recovery^=1),{sig,recovery}}function normalizePrivateKey(key){let num;if("bigint"==typeof key)num=key;else if("number"==typeof key&&Number.isSafeInteger(key)&&key>0)num=BigInt(key);else if("string"==typeof key){if(64!==key.length)throw new Error("Expected 32 bytes of private key");num=hexToNumber(key)}else{if(!(key instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==key.length)throw new Error("Expected 32 bytes of private key");num=bytesToNumber(key)}if(!isWithinCurveOrder(num))throw new Error("Expected private key: 0 < key < n");return num}function normalizePublicKey(publicKey){return publicKey instanceof Point?(publicKey.assertValidity(),publicKey):Point.fromHex(publicKey)}function normalizeSignature(signature){if(signature instanceof Signature)return signature.assertValidity(),signature;try{return Signature.fromDER(signature)}catch(error){return Signature.fromCompact(signature)}}function isProbPub(item){const arr=item instanceof Uint8Array,str="string"==typeof item,len=(arr||str)&&item.length;return arr?33===len||65===len:str?66===len||130===len:item instanceof Point}function bits2int(bytes){return bytesToNumber(bytes.length>32?bytes.slice(0,32):bytes)}function bits2octets(bytes){const z1=bits2int(bytes),z2=mod(z1,CURVE.n);return int2octets(z2<_0n?z1:z2)}function int2octets(num){return numTo32b(num)}function initSigArgs(msgHash,privateKey,extraEntropy){if(null==msgHash)throw new Error(`sign: expected valid message hash, not "${msgHash}"`);const h1=ensureBytes(msgHash),d=normalizePrivateKey(privateKey),seedArgs=[int2octets(d),bits2octets(h1)];if(null!=extraEntropy){!0===extraEntropy&&(extraEntropy=exports.utils.randomBytes(32));const e=ensureBytes(extraEntropy);if(32!==e.length)throw new Error("sign: Expected 32 bytes of extra data");seedArgs.push(e)}return{seed:concatBytes(...seedArgs),m:bits2int(h1),d}}function finalizeSig(recSig,opts){const{sig,recovery}=recSig,{der,recovered}=Object.assign({canonical:!0,der:!0},opts),hashed=der?sig.toDERRawBytes():sig.toCompactRawBytes();return recovered?[hashed,recovery]:hashed}exports.getPublicKey=function(privateKey,isCompressed=!1){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)},exports.recoverPublicKey=function(msgHash,signature,recovery,isCompressed=!1){return Point.fromSignature(msgHash,signature,recovery).toRawBytes(isCompressed)},exports.getSharedSecret=function(privateA,publicB,isCompressed=!1){if(isProbPub(privateA))throw new TypeError("getSharedSecret: first arg must be private key");if(!isProbPub(publicB))throw new TypeError("getSharedSecret: second arg must be public key");const b=normalizePublicKey(publicB);return b.assertValidity(),b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed)},exports.sign=async function(msgHash,privKey,opts={}){const{seed,m,d}=initSigArgs(msgHash,privKey,opts.extraEntropy),drbg=new HmacDrbg(32,32);let sig;for(await drbg.reseed(seed);!(sig=kmdToSig(await drbg.generate(),m,d,opts.canonical));)await drbg.reseed();return finalizeSig(sig,opts)},exports.signSync=function(msgHash,privKey,opts={}){const{seed,m,d}=initSigArgs(msgHash,privKey,opts.extraEntropy),drbg=new HmacDrbg(32,32);let sig;for(drbg.reseedSync(seed);!(sig=kmdToSig(drbg.generateSync(),m,d,opts.canonical));)drbg.reseedSync();return finalizeSig(sig,opts)};const vopts={strict:!0};function schnorrChallengeFinalize(ch){return mod(bytesToNumber(ch),CURVE.n)}exports.verify=function(signature,msgHash,publicKey,opts=vopts){let sig;try{sig=normalizeSignature(signature),msgHash=ensureBytes(msgHash)}catch(error){return!1}const{r,s}=sig;if(opts.strict&&sig.hasHighS())return!1;const h=truncateHash(msgHash);let P;try{P=normalizePublicKey(publicKey)}catch(error){return!1}const{n}=CURVE,sinv=invert(s,n),u1=mod(h*sinv,n),u2=mod(r*sinv,n),R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2);return!!R&&mod(R.x,n)===r};class SchnorrSignature{constructor(r,s){this.r=r,this.s=s,this.assertValidity()}static fromHex(hex){const bytes=ensureBytes(hex);if(64!==bytes.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);const r=bytesToNumber(bytes.subarray(0,32)),s=bytesToNumber(bytes.subarray(32,64));return new SchnorrSignature(r,s)}assertValidity(){const{r,s}=this;if(!isValidFieldElement(r)||!isWithinCurveOrder(s))throw new Error("Invalid signature")}toHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}toRawBytes(){return hexToBytes(this.toHex())}}class InternalSchnorrSignature{constructor(message,privateKey,auxRand=exports.utils.randomBytes()){if(null==message)throw new TypeError(`sign: Expected valid message, not "${message}"`);this.m=ensureBytes(message);const{x,scalar}=this.getScalar(normalizePrivateKey(privateKey));if(this.px=x,this.d=scalar,this.rand=ensureBytes(auxRand),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(priv){const point=Point.fromPrivateKey(priv),scalar=point.hasEvenY()?priv:CURVE.n-priv;return{point,scalar,x:point.toRawX()}}initNonce(d,t0h){return numTo32b(d^bytesToNumber(t0h))}finalizeNonce(k0h){const k0=mod(bytesToNumber(k0h),CURVE.n);if(k0===_0n)throw new Error("sign: Creation of signature failed. k is zero");const{point:R,x:rx,scalar:k}=this.getScalar(k0);return{R,rx,k}}finalizeSig(R,k,e,d){return new SchnorrSignature(R.x,mod(k+e*d,CURVE.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m,d,px,rand}=this,tag=exports.utils.taggedHash,t=this.initNonce(d,await tag(TAGS.aux,rand)),{R,rx,k}=this.finalizeNonce(await tag(TAGS.nonce,t,px,m)),e=schnorrChallengeFinalize(await tag(TAGS.challenge,rx,px,m)),sig=this.finalizeSig(R,k,e,d);return await schnorrVerify(sig,m,px)||this.error(),sig}calcSync(){const{m,d,px,rand}=this,tag=exports.utils.taggedHashSync,t=this.initNonce(d,tag(TAGS.aux,rand)),{R,rx,k}=this.finalizeNonce(tag(TAGS.nonce,t,px,m)),e=schnorrChallengeFinalize(tag(TAGS.challenge,rx,px,m)),sig=this.finalizeSig(R,k,e,d);return schnorrVerifySync(sig,m,px)||this.error(),sig}}function initSchnorrVerify(signature,message,publicKey){const raw=signature instanceof SchnorrSignature,sig=raw?signature:SchnorrSignature.fromHex(signature);return raw&&sig.assertValidity(),{...sig,m:ensureBytes(message),P:normalizePublicKey(publicKey)}}function finalizeSchnorrVerify(r,P,s,e){const R=Point.BASE.multiplyAndAddUnsafe(P,normalizePrivateKey(s),mod(-e,CURVE.n));return!(!R||!R.hasEvenY()||R.x!==r)}async function schnorrVerify(signature,message,publicKey){try{const{r,s,m,P}=initSchnorrVerify(signature,message,publicKey),e=schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge,numTo32b(r),P.toRawX(),m));return finalizeSchnorrVerify(r,P,s,e)}catch(error){return!1}}function schnorrVerifySync(signature,message,publicKey){try{const{r,s,m,P}=initSchnorrVerify(signature,message,publicKey),e=schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge,numTo32b(r),P.toRawX(),m));return finalizeSchnorrVerify(r,P,s,e)}catch(error){if(error instanceof ShaError)throw error;return!1}}exports.schnorr={Signature:SchnorrSignature,getPublicKey:function(privateKey){return Point.fromPrivateKey(privateKey).toRawX()},sign:async function(msg,privKey,auxRand){return new InternalSchnorrSignature(msg,privKey,auxRand).calc()},verify:schnorrVerify,signSync:function(msg,privKey,auxRand){return new InternalSchnorrSignature(msg,privKey,auxRand).calcSync()},verifySync:schnorrVerifySync},Point.BASE._setWindowSize(8);const crypto={node:nodeCrypto,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},TAGS={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},TAGGED_HASH_PREFIXES={};exports.utils={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(privateKey){try{return normalizePrivateKey(privateKey),!0}catch(error){return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:hash=>{if((hash=ensureBytes(hash)).length<40||hash.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return numTo32b(mod(bytesToNumber(hash),CURVE.n-_1n)+_1n)},randomBytes:(bytesLength=32)=>{if(crypto.web)return crypto.web.getRandomValues(new Uint8Array(bytesLength));if(crypto.node){const{randomBytes}=crypto.node;return Uint8Array.from(randomBytes(bytesLength))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>exports.utils.hashToPrivateKey(exports.utils.randomBytes(40)),precompute(windowSize=8,point=Point.BASE){const cached=point===Point.BASE?point:new Point(point.x,point.y);return cached._setWindowSize(windowSize),cached.multiply(_3n),cached},sha256:async(...messages)=>{if(crypto.web){const buffer=await crypto.web.subtle.digest("SHA-256",concatBytes(...messages));return new Uint8Array(buffer)}if(crypto.node){const{createHash}=crypto.node,hash=createHash("sha256");return messages.forEach((m=>hash.update(m))),Uint8Array.from(hash.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(key,...messages)=>{if(crypto.web){const ckey=await crypto.web.subtle.importKey("raw",key,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),message=concatBytes(...messages),buffer=await crypto.web.subtle.sign("HMAC",ckey,message);return new Uint8Array(buffer)}if(crypto.node){const{createHmac}=crypto.node,hash=createHmac("sha256",key);return messages.forEach((m=>hash.update(m))),Uint8Array.from(hash.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(tag,...messages)=>{let tagP=TAGGED_HASH_PREFIXES[tag];if(void 0===tagP){const tagH=await exports.utils.sha256(Uint8Array.from(tag,(c=>c.charCodeAt(0))));tagP=concatBytes(tagH,tagH),TAGGED_HASH_PREFIXES[tag]=tagP}return exports.utils.sha256(tagP,...messages)},taggedHashSync:(tag,...messages)=>{if("function"!=typeof _sha256Sync)throw new ShaError("sha256Sync is undefined, you need to set it");let tagP=TAGGED_HASH_PREFIXES[tag];if(void 0===tagP){const tagH=_sha256Sync(Uint8Array.from(tag,(c=>c.charCodeAt(0))));tagP=concatBytes(tagH,tagH),TAGGED_HASH_PREFIXES[tag]=tagP}return _sha256Sync(tagP,...messages)},_JacobianPoint:JacobianPoint},Object.defineProperties(exports.utils,{sha256Sync:{configurable:!1,get:()=>_sha256Sync,set(val){_sha256Sync||(_sha256Sync=val)}},hmacSha256Sync:{configurable:!1,get:()=>_hmacSha256Sync,set(val){_hmacSha256Sync||(_hmacSha256Sync=val)}}})},9750:(__unused_webpack_module,exports,__webpack_require__)=>{var _interopRequireDefault=__webpack_require__(24994);Object.defineProperty(exports,"__esModule",{value:!0}),exports.BitcoinWindowObject=void 0;var _defineProperty2=_interopRequireDefault(__webpack_require__(43693)),_asyncToGenerator2=_interopRequireDefault(__webpack_require__(29293)),_classCallCheck2=_interopRequireDefault(__webpack_require__(17383)),_createClass2=_interopRequireDefault(__webpack_require__(34579)),_classPrivateFieldLooseBase2=_interopRequireDefault(__webpack_require__(33883)),_classPrivateFieldLooseKey2=_interopRequireDefault(__webpack_require__(60055)),_logoBase=_interopRequireDefault(__webpack_require__(98748)),_bitcoinMessage=__webpack_require__(21295),_dappRequests=_interopRequireDefault(__webpack_require__(53213)),_message=__webpack_require__(23956),_messageTypes=__webpack_require__(92306),_multiNetworks=__webpack_require__(22825),_callbacks=(0,_classPrivateFieldLooseKey2.default)("callbacks");exports.BitcoinWindowObject=function(){function BitcoinWindowObject(){var _ref,_this=this;(0,_classCallCheck2.default)(this,BitcoinWindowObject),this.id="BraavosProviders.BitcoinProvider",this.name="Braavos",this.icon=_logoBase.default,this.webUrl="https://braavos.app/",this.chromeWebStoreUrl="https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",this.mozillaAddOnsUrl="https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet/",this.googlePlayStoreUrl="https://play.google.com/store/apps/details?id=app.braavos.wallet",this.iOSAppStoreUrl="https://apps.apple.com/us/app/braavos-wallet/id1636013523",this.methods=["getInfo","getAddresses","getAccounts","signMessage","signPsbt","accountsChanged"],Object.defineProperty(this,_callbacks,{writable:!0,value:{}}),this.version="4.9.2",this.connect=(_ref=(0,_asyncToGenerator2.default)((function*(request){var payload=(0,_messageTypes.decodeRequest)(request).payload;return(yield _this.request("getAddresses",{message:payload.message,purposes:payload.purposes})).result})),function(_x){return _ref.apply(this,arguments)}),this.addListener=function(event,handler){return _this.on(event,handler),function(){_this.off(event,handler)}},this.off=function(event,handleEvent){var _classPrivateFieldLoo,_classPrivateFieldLoo2;null===(_classPrivateFieldLoo=(0,_classPrivateFieldLooseBase2.default)(_this,_callbacks)[_callbacks][event])||void 0===_classPrivateFieldLoo||null===(_classPrivateFieldLoo2=_classPrivateFieldLoo.listeners)||void 0===_classPrivateFieldLoo2||_classPrivateFieldLoo2.delete(handleEvent)}}var _signTransaction,_signMessage,_signMultipleTransactions,_request,_getCapabilities,_handleIncomingMessage;return(0,_createClass2.default)(BitcoinWindowObject,[{key:"handleIncomingMessage",value:(_handleIncomingMessage=(0,_asyncToGenerator2.default)((function*(message){var _message$from;if("braavos-inpage"!==(null==message?void 0:message.from)){var uid=null==message?void 0:message.uid;if(uid&&_dappRequests.default.has(uid))_dappRequests.default.resolve(uid,message.data);else if(null!=message&&null!==(_message$from=message.from)&&void 0!==_message$from&&_message$from.startsWith(_message.ConnectionType.ContentListenerBridge)){var _callbackInfo$listene,_callbackInfo$lastDat,_message$data=message.data,type=_message$data.type,data=_message$data.data,callbackInfo=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][type];if(null==callbackInfo||null===(_callbackInfo$listene=callbackInfo.listeners)||void 0===_callbackInfo$listene||!_callbackInfo$listene.size)return;if(JSON.stringify(null!=data?data:{})===JSON.stringify(null!==(_callbackInfo$lastDat=callbackInfo.lastData)&&void 0!==_callbackInfo$lastDat?_callbackInfo$lastDat:{}))return;callbackInfo.lastData=data,callbackInfo.listeners.forEach((function(callback){"wallet_accountsChanged"===type&&callback((0,_multiNetworks.getBitcoinAccounts)(null!=data?data:[]))}))}}})),function(_x2){return _handleIncomingMessage.apply(this,arguments)})},{key:"getCapabilities",value:(_getCapabilities=(0,_asyncToGenerator2.default)((function*(){return this.methods})),function(){return _getCapabilities.apply(this,arguments)})},{key:"request",value:(_request=(0,_asyncToGenerator2.default)((function*(method,options){switch(method){case"getInfo":return{jsonrpc:"2.0",id:0,result:{methods:this.methods,version:this.version,supports:[]}};case"getAccounts":case"getAddresses":var _ref3,purposes=(null!==(_ref3=options)&&void 0!==_ref3?_ref3:{}).purposes;return this.sendMessageFromInpageToContent({method:_bitcoinMessage.BitcoinDappMethod.CONNECT,data:{purposes:null!=purposes?purposes:["payment","ordinals"]},source:""}).then((function(msg){return{jsonrpc:"2.0",id:0,result:"getAddresses"===method?msg:null==msg?void 0:msg.addresses}}));case"signMessage":var _ref4=options,address=_ref4.address,message=_ref4.message,protocol=_ref4.protocol;return this.sendMessageFromInpageToContent({method:_bitcoinMessage.BitcoinDappMethod.SIGN_MESSAGE,data:{address,message,protocol},source:""}).then((function(msg){if(null==msg||!msg.signature)throw Error("Signature failed");return{jsonrpc:"2.0",id:0,result:msg}}));case"sendTransfer":var recipients=options.recipients;return this.sendMessageFromInpageToContent({method:_bitcoinMessage.BitcoinDappMethod.SEND_TRANSFERS,data:{recipients},source:""}).then((function(msg){if(null==msg||!msg.txid)throw Error("Signature failed");return{jsonrpc:"2.0",id:0,result:msg}}));case"signPsbt":var isBatch=Array.isArray(options),data=(isBatch?options:[options]).map((function(op){var _ref6=op;return{psbt:_ref6.psbt,allowedSignHash:_ref6.allowedSignHash,signInputs:_ref6.signInputs,broadcast:_ref6.broadcast}}));return this.sendMessageFromInpageToContent({method:_bitcoinMessage.BitcoinDappMethod.SIGN_PSBT,data,source:""}).then((function(res){if(null==res||!res.every((function(msg,idx){return!(null==msg||!msg.psbt||!msg.txid&&data[idx].broadcast)})))throw Error("Signature failed");return{jsonrpc:"2.0",id:0,result:isBatch?res:null==res?void 0:res[0]}}));case"getBalance":return this.sendMessageFromInpageToContent({method:_bitcoinMessage.BitcoinDappMethod.GET_BALANCE,source:""}).then((function(msg){return{jsonrpc:"2.0",id:0,result:msg}}));case"wallet_requestPermissions":return this.request("getAccounts",void 0).then((function(res){return{jsonrpc:"2.0",id:0,result:Array.isArray(res)&&!!res.length}}));case"wallet_getWalletType":return{jsonrpc:"2.0",id:0,result:"software"};default:throw new Error(`Unsupported operation: "${method}"`)}})),function(_x3,_x4){return _request.apply(this,arguments)})},{key:"sendBtcTransaction",value:function(){throw new Error("use 'request(\"sendTransfer\")'")}},{key:"signMultipleTransactions",value:(_signMultipleTransactions=(0,_asyncToGenerator2.default)((function*(request){var _yield$this$request,payload=(0,_messageTypes.decodeRequest)(request).payload,psbts=Array.isArray(payload)?payload:payload.psbts.map((function(_ref7){var inputsToSign=_ref7.inputsToSign;return{psbt:_ref7.psbtBase64,signInputs:inputsToSign.reduce((function(res,input){return Object.assign({},res,(0,_defineProperty2.default)({},input.address,input.signingIndexes))}),{})}})),result=null===(_yield$this$request=yield this.request("signPsbt",psbts))||void 0===_yield$this$request?void 0:_yield$this$request.result;return null==result?void 0:result.map((function(_ref8){return{psbtBase64:_ref8.psbt,txId:_ref8.txid}}))})),function(_x5){return _signMultipleTransactions.apply(this,arguments)})},{key:"signMessage",value:(_signMessage=(0,_asyncToGenerator2.default)((function*(request){var _yield$this$request2,payload=(0,_messageTypes.decodeRequest)(request).payload,result=null===(_yield$this$request2=yield this.request("signMessage",{message:payload.message,address:payload.address,protocol:payload.protocol}))||void 0===_yield$this$request2?void 0:_yield$this$request2.result;return null==result?void 0:result.signature})),function(_x6){return _signMessage.apply(this,arguments)})},{key:"signTransaction",value:(_signTransaction=(0,_asyncToGenerator2.default)((function*(request){var _yield$this$request3,payload=(0,_messageTypes.decodeRequest)(request).payload,result=null===(_yield$this$request3=yield this.request("signPsbt",{psbt:payload.psbtBase64,broadcast:payload.broadcast,signInputs:payload.inputsToSign.reduce((function(res,input){return Object.assign({},res,(0,_defineProperty2.default)({},input.address,input.signingIndexes))}),{})}))||void 0===_yield$this$request3?void 0:_yield$this$request3.result;return result?{psbtBase64:result.psbt,txId:result.txid}:void 0})),function(_x7){return _signTransaction.apply(this,arguments)})},{key:"on",value:function(event,handleEvent){var _classPrivateFieldLoo3,_classPrivateFieldLoo4;null!==(_classPrivateFieldLoo4=(_classPrivateFieldLoo3=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks])[event])&&void 0!==_classPrivateFieldLoo4||(_classPrivateFieldLoo3[event]={listeners:new Set}),(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event].listeners.add(handleEvent)}},{key:"removeAllListeners",value:function(event){var _classPrivateFieldLoo5;event?null===(_classPrivateFieldLoo5=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event])||void 0===_classPrivateFieldLoo5||_classPrivateFieldLoo5.listeners.clear():Object.values((0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks]).forEach((function(_ref9){return _ref9.listeners.clear()}))}}]),BitcoinWindowObject}()},10526:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},11886:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(53860),exports),__exportStar(__webpack_require__(72787),exports),__exportStar(__webpack_require__(58768),exports),__exportStar(__webpack_require__(74930),exports)},12475:module=>{module.exports=function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e},module.exports.__esModule=!0,module.exports.default=module.exports},13019:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hmac=exports.HMAC=void 0;const _assert_js_1=__webpack_require__(9113),utils_js_1=__webpack_require__(37995);class HMAC extends utils_js_1.Hash{constructor(hash,_key){super(),this.finished=!1,this.destroyed=!1,(0,_assert_js_1.ahash)(hash);const key=(0,utils_js_1.toBytes)(_key);if(this.iHash=hash.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen,pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad),this.oHash=hash.create();for(let i=0;i<pad.length;i++)pad[i]^=106;this.oHash.update(pad),pad.fill(0)}update(buf){return(0,_assert_js_1.aexists)(this),this.iHash.update(buf),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.abytes)(out,this.outputLen),this.finished=!0,this.iHash.digestInto(out),this.oHash.update(out),this.oHash.digestInto(out),this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);return this.digestInto(out),out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;return to.finished=finished,to.destroyed=destroyed,to.blockLen=blockLen,to.outputLen=outputLen,to.oHash=oHash._cloneInto(to.oHash),to.iHash=iHash._cloneInto(to.iHash),to}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}exports.HMAC=HMAC;exports.hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest(),exports.hmac.create=(hash,key)=>new HMAC(hash,key)},13307:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const adler32=__webpack_require__(82217),crc32=__webpack_require__(30579),inflate_fast=__webpack_require__(79097),inflate_table=__webpack_require__(65930),{Z_FINISH,Z_BLOCK,Z_TREES,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR,Z_BUF_ERROR,Z_DEFLATED}=__webpack_require__(39829),BAD=16209,zswap32=q=>(q>>>24&255)+(q>>>8&65280)+((65280&q)<<8)+((255&q)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateStateCheck=strm=>{if(!strm)return 1;const state=strm.state;return!state||state.strm!==strm||state.mode<16180||state.mode>16211?1:0},inflateResetKeep=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR;const state=strm.state;return strm.total_in=strm.total_out=state.total=0,strm.msg="",state.wrap&&(strm.adler=1&state.wrap),state.mode=16180,state.last=0,state.havedict=0,state.flags=-1,state.dmax=32768,state.head=null,state.hold=0,state.bits=0,state.lencode=state.lendyn=new Int32Array(852),state.distcode=state.distdyn=new Int32Array(592),state.sane=1,state.back=-1,Z_OK},inflateReset=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR;const state=strm.state;return state.wsize=0,state.whave=0,state.wnext=0,inflateResetKeep(strm)},inflateReset2=(strm,windowBits)=>{let wrap;if(inflateStateCheck(strm))return Z_STREAM_ERROR;const state=strm.state;return windowBits<0?(wrap=0,windowBits=-windowBits):(wrap=5+(windowBits>>4),windowBits<48&&(windowBits&=15)),windowBits&&(windowBits<8||windowBits>15)?Z_STREAM_ERROR:(null!==state.window&&state.wbits!==windowBits&&(state.window=null),state.wrap=wrap,state.wbits=windowBits,inflateReset(strm))},inflateInit2=(strm,windowBits)=>{if(!strm)return Z_STREAM_ERROR;const state=new InflateState;strm.state=state,state.strm=strm,state.window=null,state.mode=16180;const ret=inflateReset2(strm,windowBits);return ret!==Z_OK&&(strm.state=null),ret};let lenfix,distfix,virgin=!0;const fixedtables=state=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let sym=0;for(;sym<144;)state.lens[sym++]=8;for(;sym<256;)state.lens[sym++]=9;for(;sym<280;)state.lens[sym++]=7;for(;sym<288;)state.lens[sym++]=8;for(inflate_table(1,state.lens,0,288,lenfix,0,state.work,{bits:9}),sym=0;sym<32;)state.lens[sym++]=5;inflate_table(2,state.lens,0,32,distfix,0,state.work,{bits:5}),virgin=!1}state.lencode=lenfix,state.lenbits=9,state.distcode=distfix,state.distbits=5},updatewindow=(strm,src,end,copy)=>{let dist;const state=strm.state;return null===state.window&&(state.wsize=1<<state.wbits,state.wnext=0,state.whave=0,state.window=new Uint8Array(state.wsize)),copy>=state.wsize?(state.window.set(src.subarray(end-state.wsize,end),0),state.wnext=0,state.whave=state.wsize):(dist=state.wsize-state.wnext,dist>copy&&(dist=copy),state.window.set(src.subarray(end-copy,end-copy+dist),state.wnext),(copy-=dist)?(state.window.set(src.subarray(end-copy,end),0),state.wnext=copy,state.whave=state.wsize):(state.wnext+=dist,state.wnext===state.wsize&&(state.wnext=0),state.whave<state.wsize&&(state.whave+=dist))),0};module.exports.inflateReset=inflateReset,module.exports.inflateReset2=inflateReset2,module.exports.inflateResetKeep=inflateResetKeep,module.exports.inflateInit=strm=>inflateInit2(strm,15),module.exports.inflateInit2=inflateInit2,module.exports.inflate=(strm,flush)=>{let state,input,output,next,put,have,left,hold,bits,_in,_out,copy,from,from_source,here_bits,here_op,here_val,last_bits,last_op,last_val,len,ret,here=0;const hbuf=new Uint8Array(4);let opts,n;const order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(strm)||!strm.output||!strm.input&&0!==strm.avail_in)return Z_STREAM_ERROR;state=strm.state,16191===state.mode&&(state.mode=16192),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,_in=have,_out=left,ret=Z_OK;inf_leave:for(;;)switch(state.mode){case 16180:if(0===state.wrap){state.mode=16192;break}for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(2&state.wrap&&35615===hold){0===state.wbits&&(state.wbits=15),state.check=0,hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0),hold=0,bits=0,state.mode=16181;break}if(state.head&&(state.head.done=!1),!(1&state.wrap)||(((255&hold)<<8)+(hold>>8))%31){strm.msg="incorrect header check",state.mode=BAD;break}if((15&hold)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=BAD;break}if(hold>>>=4,bits-=4,len=8+(15&hold),0===state.wbits&&(state.wbits=len),len>15||len>state.wbits){strm.msg="invalid window size",state.mode=BAD;break}state.dmax=1<<state.wbits,state.flags=0,strm.adler=state.check=1,state.mode=512&hold?16189:16191,hold=0,bits=0;break;case 16181:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.flags=hold,(255&state.flags)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=BAD;break}if(57344&state.flags){strm.msg="unknown header flags set",state.mode=BAD;break}state.head&&(state.head.text=hold>>8&1),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=16182;case 16182:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.time=hold),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,hbuf[2]=hold>>>16&255,hbuf[3]=hold>>>24&255,state.check=crc32(state.check,hbuf,4,0)),hold=0,bits=0,state.mode=16183;case 16183:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.xflags=255&hold,state.head.os=hold>>8),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=16184;case 16184:if(1024&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length=hold,state.head&&(state.head.extra_len=hold),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32(state.check,hbuf,2,0)),hold=0,bits=0}else state.head&&(state.head.extra=null);state.mode=16185;case 16185:if(1024&state.flags&&(copy=state.length,copy>have&&(copy=have),copy&&(state.head&&(len=state.head.extra_len-state.length,state.head.extra||(state.head.extra=new Uint8Array(state.head.extra_len)),state.head.extra.set(input.subarray(next,next+copy),len)),512&state.flags&&4&state.wrap&&(state.check=crc32(state.check,input,copy,next)),have-=copy,next+=copy,state.length-=copy),state.length))break inf_leave;state.length=0,state.mode=16186;case 16186:if(2048&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.name+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&4&state.wrap&&(state.check=crc32(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.name=null);state.length=0,state.mode=16187;case 16187:if(4096&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.comment+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&4&state.wrap&&(state.check=crc32(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.comment=null);state.mode=16188;case 16188:if(512&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(4&state.wrap&&hold!==(65535&state.check)){strm.msg="header crc mismatch",state.mode=BAD;break}hold=0,bits=0}state.head&&(state.head.hcrc=state.flags>>9&1,state.head.done=!0),strm.adler=state.check=0,state.mode=16191;break;case 16189:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}strm.adler=state.check=zswap32(hold),hold=0,bits=0,state.mode=16190;case 16190:if(0===state.havedict)return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,Z_NEED_DICT;strm.adler=state.check=1,state.mode=16191;case 16191:if(flush===Z_BLOCK||flush===Z_TREES)break inf_leave;case 16192:if(state.last){hold>>>=7&bits,bits-=7&bits,state.mode=16206;break}for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}switch(state.last=1&hold,hold>>>=1,bits-=1,3&hold){case 0:state.mode=16193;break;case 1:if(fixedtables(state),state.mode=16199,flush===Z_TREES){hold>>>=2,bits-=2;break inf_leave}break;case 2:state.mode=16196;break;case 3:strm.msg="invalid block type",state.mode=BAD}hold>>>=2,bits-=2;break;case 16193:for(hold>>>=7&bits,bits-=7&bits;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if((65535&hold)!=(hold>>>16^65535)){strm.msg="invalid stored block lengths",state.mode=BAD;break}if(state.length=65535&hold,hold=0,bits=0,state.mode=16194,flush===Z_TREES)break inf_leave;case 16194:state.mode=16195;case 16195:if(copy=state.length,copy){if(copy>have&&(copy=have),copy>left&&(copy=left),0===copy)break inf_leave;output.set(input.subarray(next,next+copy),put),have-=copy,next+=copy,left-=copy,put+=copy,state.length-=copy;break}state.mode=16191;break;case 16196:for(;bits<14;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.nlen=257+(31&hold),hold>>>=5,bits-=5,state.ndist=1+(31&hold),hold>>>=5,bits-=5,state.ncode=4+(15&hold),hold>>>=4,bits-=4,state.nlen>286||state.ndist>30){strm.msg="too many length or distance symbols",state.mode=BAD;break}state.have=0,state.mode=16197;case 16197:for(;state.have<state.ncode;){for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.lens[order[state.have++]]=7&hold,hold>>>=3,bits-=3}for(;state.have<19;)state.lens[order[state.have++]]=0;if(state.lencode=state.lendyn,state.lenbits=7,opts={bits:state.lenbits},ret=inflate_table(0,state.lens,0,19,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid code lengths set",state.mode=BAD;break}state.have=0,state.mode=16198;case 16198:for(;state.have<state.nlen+state.ndist;){for(;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_val<16)hold>>>=here_bits,bits-=here_bits,state.lens[state.have++]=here_val;else{if(16===here_val){for(n=here_bits+2;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold>>>=here_bits,bits-=here_bits,0===state.have){strm.msg="invalid bit length repeat",state.mode=BAD;break}len=state.lens[state.have-1],copy=3+(3&hold),hold>>>=2,bits-=2}else if(17===here_val){for(n=here_bits+3;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=3+(7&hold),hold>>>=3,bits-=3}else{for(n=here_bits+7;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=11+(127&hold),hold>>>=7,bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg="invalid bit length repeat",state.mode=BAD;break}for(;copy--;)state.lens[state.have++]=len}}if(state.mode===BAD)break;if(0===state.lens[256]){strm.msg="invalid code -- missing end-of-block",state.mode=BAD;break}if(state.lenbits=9,opts={bits:state.lenbits},ret=inflate_table(1,state.lens,0,state.nlen,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid literal/lengths set",state.mode=BAD;break}if(state.distbits=6,state.distcode=state.distdyn,opts={bits:state.distbits},ret=inflate_table(2,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,opts),state.distbits=opts.bits,ret){strm.msg="invalid distances set",state.mode=BAD;break}if(state.mode=16199,flush===Z_TREES)break inf_leave;case 16199:state.mode=16200;case 16200:if(have>=6&&left>=258){strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,inflate_fast(strm,_out),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,16191===state.mode&&(state.back=-1);break}for(state.back=0;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_op&&!(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.lencode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,state.length=here_val,0===here_op){state.mode=16205;break}if(32&here_op){state.back=-1,state.mode=16191;break}if(64&here_op){strm.msg="invalid literal/length code",state.mode=BAD;break}state.extra=15&here_op,state.mode=16201;case 16201:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}state.was=state.length,state.mode=16202;case 16202:for(;here=state.distcode[hold&(1<<state.distbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(!(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.distcode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,64&here_op){strm.msg="invalid distance code",state.mode=BAD;break}state.offset=here_val,state.extra=15&here_op,state.mode=16203;case 16203:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.offset+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}if(state.offset>state.dmax){strm.msg="invalid distance too far back",state.mode=BAD;break}state.mode=16204;case 16204:if(0===left)break inf_leave;if(copy=_out-left,state.offset>copy){if(copy=state.offset-copy,copy>state.whave&&state.sane){strm.msg="invalid distance too far back",state.mode=BAD;break}copy>state.wnext?(copy-=state.wnext,from=state.wsize-copy):from=state.wnext-copy,copy>state.length&&(copy=state.length),from_source=state.window}else from_source=output,from=put-state.offset,copy=state.length;copy>left&&(copy=left),left-=copy,state.length-=copy;do{output[put++]=from_source[from++]}while(--copy);0===state.length&&(state.mode=16200);break;case 16205:if(0===left)break inf_leave;output[put++]=state.length,left--,state.mode=16200;break;case 16206:if(state.wrap){for(;bits<32;){if(0===have)break inf_leave;have--,hold|=input[next++]<<bits,bits+=8}if(_out-=left,strm.total_out+=_out,state.total+=_out,4&state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32(state.check,output,_out,put-_out):adler32(state.check,output,_out,put-_out)),_out=left,4&state.wrap&&(state.flags?hold:zswap32(hold))!==state.check){strm.msg="incorrect data check",state.mode=BAD;break}hold=0,bits=0}state.mode=16207;case 16207:if(state.wrap&&state.flags){for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(4&state.wrap&&hold!==(4294967295&state.total)){strm.msg="incorrect length check",state.mode=BAD;break}hold=0,bits=0}state.mode=16208;case 16208:ret=Z_STREAM_END;break inf_leave;case BAD:ret=Z_DATA_ERROR;break inf_leave;case 16210:return Z_MEM_ERROR;default:return Z_STREAM_ERROR}return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,(state.wsize||_out!==strm.avail_out&&state.mode<BAD&&(state.mode<16206||flush!==Z_FINISH))&&updatewindow(strm,strm.output,strm.next_out,_out-strm.avail_out)?(state.mode=16210,Z_MEM_ERROR):(_in-=strm.avail_in,_out-=strm.avail_out,strm.total_in+=_in,strm.total_out+=_out,state.total+=_out,4&state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32(state.check,output,_out,strm.next_out-_out):adler32(state.check,output,_out,strm.next_out-_out)),strm.data_type=state.bits+(state.last?64:0)+(16191===state.mode?128:0)+(16199===state.mode||16194===state.mode?256:0),(0===_in&&0===_out||flush===Z_FINISH)&&ret===Z_OK&&(ret=Z_BUF_ERROR),ret)},module.exports.inflateEnd=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR;let state=strm.state;return state.window&&(state.window=null),strm.state=null,Z_OK},module.exports.inflateGetHeader=(strm,head)=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR;const state=strm.state;return 2&state.wrap?(state.head=head,head.done=!1,Z_OK):Z_STREAM_ERROR},module.exports.inflateSetDictionary=(strm,dictionary)=>{const dictLength=dictionary.length;let state,dictid,ret;return inflateStateCheck(strm)?Z_STREAM_ERROR:(state=strm.state,0!==state.wrap&&16190!==state.mode?Z_STREAM_ERROR:16190===state.mode&&(dictid=1,dictid=adler32(dictid,dictionary,dictLength,0),dictid!==state.check)?Z_DATA_ERROR:(ret=updatewindow(strm,dictionary,dictLength,dictLength),ret?(state.mode=16210,Z_MEM_ERROR):(state.havedict=1,Z_OK)))},module.exports.inflateInfo="pako inflate (from Nodeca project)"},13613:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},14472:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Permission=void 0,exports.Permission={ACCOUNTS:"accounts"}},14762:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hash=exports.nextTick=exports.byteSwapIfBE=exports.byteSwap=exports.isLE=exports.rotl=exports.rotr=exports.createView=exports.u32=exports.u8=void 0,exports.isBytes=function(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name},exports.byteSwap32=function(arr){for(let i=0;i<arr.length;i++)arr[i]=(0,exports.byteSwap)(arr[i])},exports.bytesToHex=function(bytes){(0,_assert_js_1.abytes)(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex},exports.hexToBytes=function(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=asciiToBase16(hex.charCodeAt(hi)),n2=asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array},exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;diff>=0&&diff<tick||(await(0,exports.nextTick)(),ts+=diff)}},exports.utf8ToBytes=utf8ToBytes,exports.toBytes=toBytes,exports.concatBytes=function(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert_js_1.abytes)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res},exports.checkOpts=function(defaults,opts){if(void 0!==opts&&"[object Object]"!=={}.toString.call(opts))throw new Error("Options should be object or undefined");return Object.assign(defaults,opts)},exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC},exports.wrapConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.randomBytes)return crypto_1.crypto.randomBytes(bytesLength);throw new Error("crypto.getRandomValues must be defined")};const crypto_1=__webpack_require__(1238),_assert_js_1=__webpack_require__(90788);exports.u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);exports.u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));exports.createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);exports.rotr=(word,shift)=>word<<32-shift|word>>>shift;exports.rotl=(word,shift)=>word<<shift|word>>>32-shift>>>0,exports.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];exports.byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,exports.byteSwapIfBE=exports.isLE?n=>n:n=>(0,exports.byteSwap)(n);const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(ch){return ch>=asciis._0&&ch<=asciis._9?ch-asciis._0:ch>=asciis.A&&ch<=asciis.F?ch-(asciis.A-10):ch>=asciis.a&&ch<=asciis.f?ch-(asciis.a-10):void 0}function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){return"string"==typeof data&&(data=utf8ToBytes(data)),(0,_assert_js_1.abytes)(data),data}exports.nextTick=async()=>{};exports.Hash=class{clone(){return this._cloneInto()}}},14923:()=>{},17122:(module,__unused_webpack_exports,__webpack_require__)=>{var arrayLikeToArray=__webpack_require__(70079);module.exports=function(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}},module.exports.__esModule=!0,module.exports.default=module.exports},17383:module=>{module.exports=function(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")},module.exports.__esModule=!0,module.exports.default=module.exports},17530:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},21295:(__unused_webpack_module,exports)=>{var BitcoinDappMethod,MessageSigningProtocols;Object.defineProperty(exports,"__esModule",{value:!0}),exports.MessageSigningProtocols=exports.BitcoinDappMethod=void 0,function(BitcoinDappMethod){BitcoinDappMethod.CONNECT="BITCOIN_CONNECT",BitcoinDappMethod.SIGN_MESSAGE="BITCOIN_SIGN_MESSAGE",BitcoinDappMethod.SEND_TRANSFERS="BITCOIN_SEND_TRANSFERS",BitcoinDappMethod.SIGN_PSBT="BITCOIN_SIGN_PSBT",BitcoinDappMethod.GET_BALANCE="BITCOIN_GET_BALANCE"}(BitcoinDappMethod||(exports.BitcoinDappMethod=BitcoinDappMethod={})),function(MessageSigningProtocols){MessageSigningProtocols.ECDSA="ECDSA",MessageSigningProtocols.BIP322="BIP322"}(MessageSigningProtocols||(exports.MessageSigningProtocols=MessageSigningProtocols={}))},21827:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.decodeToken=void 0;const base64url=__webpack_require__(35921);exports.decodeToken=function(token){if("string"==typeof token){const tokenParts=token.split(".");return{header:JSON.parse(base64url.decode(tokenParts[0])),payload:JSON.parse(base64url.decode(tokenParts[1])),signature:tokenParts[2]}}if("object"==typeof token){if("string"!=typeof token.payload)throw new Error("Expected token payload to be a base64 or json string");let payload=token.payload;"{"!==token.payload[0]&&(payload=base64url.decode(payload));const allHeaders=[];return token.header.map((headerValue=>{const header=JSON.parse(base64url.decode(headerValue));allHeaders.push(header)})),{header:allHeaders,payload:JSON.parse(payload),signature:token.signature}}}},22193:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ETransactionVersion3=exports.ETransactionVersion2=exports.ETransactionVersion=exports.EDAMode=exports.EDataAvailabilityMode=exports.EBlockTag=exports.ETransactionExecutionStatus=exports.ETransactionFinalityStatus=exports.ETransactionStatus=exports.ESimulationFlag=exports.ETransactionType=exports.CALL_TYPE=exports.L1_DA_MODE=exports.PRICE_UNIT_FRI=exports.PRICE_UNIT_WEI=exports.STATE_MUTABILITY_EXTERNAL=exports.STATE_MUTABILITY_VIEW=exports.ABI_TYPE_ENUM=exports.ABI_TYPE_L1_HANDLER=exports.ABI_TYPE_CONSTRUCTOR=exports.ABI_TYPE_FUNCTION=exports.EVENT_ABI_TYPE=exports.STRUCT_ABI_TYPE=exports.TXN_TYPE_L1_HANDLER=exports.TXN_TYPE_INVOKE=exports.TXN_TYPE_DEPLOY_ACCOUNT=exports.TXN_TYPE_DEPLOY=exports.TXN_TYPE_DECLARE=exports.STATUS_RECEIVED=exports.STATUS_REJECTED=exports.STATUS_PENDING=exports.STATUS_REVERTED=exports.STATUS_SUCCEEDED=exports.STATUS_ACCEPTED_ON_L1=exports.STATUS_ACCEPTED_ON_L2=void 0,exports.STATUS_ACCEPTED_ON_L2="ACCEPTED_ON_L2",exports.STATUS_ACCEPTED_ON_L1="ACCEPTED_ON_L1",exports.STATUS_SUCCEEDED="SUCCEEDED",exports.STATUS_REVERTED="REVERTED",exports.STATUS_PENDING="PENDING",exports.STATUS_REJECTED="REJECTED",exports.STATUS_RECEIVED="RECEIVED",exports.TXN_TYPE_DECLARE="DECLARE",exports.TXN_TYPE_DEPLOY="DEPLOY",exports.TXN_TYPE_DEPLOY_ACCOUNT="DEPLOY_ACCOUNT",exports.TXN_TYPE_INVOKE="INVOKE",exports.TXN_TYPE_L1_HANDLER="L1_HANDLER",exports.STRUCT_ABI_TYPE="struct",exports.EVENT_ABI_TYPE="event",exports.ABI_TYPE_FUNCTION="function",exports.ABI_TYPE_CONSTRUCTOR="constructor",exports.ABI_TYPE_L1_HANDLER="l1_handler",exports.ABI_TYPE_ENUM="enum",exports.STATE_MUTABILITY_VIEW="view",exports.STATE_MUTABILITY_EXTERNAL="external",exports.PRICE_UNIT_WEI="WEI",exports.PRICE_UNIT_FRI="FRI",exports.L1_DA_MODE={BLOB:"BLOB",CALLDATA:"CALLDATA"},exports.CALL_TYPE={DELEGATE:"DELEGATE",LIBRARY_CALL:"LIBRARY_CALL",CALL:"CALL"},exports.ETransactionType={DECLARE:exports.TXN_TYPE_DECLARE,DEPLOY:exports.TXN_TYPE_DEPLOY,DEPLOY_ACCOUNT:exports.TXN_TYPE_DEPLOY_ACCOUNT,INVOKE:exports.TXN_TYPE_INVOKE,L1_HANDLER:exports.TXN_TYPE_L1_HANDLER},exports.ESimulationFlag={SKIP_VALIDATE:"SKIP_VALIDATE",SKIP_FEE_CHARGE:"SKIP_FEE_CHARGE"},exports.ETransactionStatus={RECEIVED:exports.STATUS_RECEIVED,REJECTED:exports.STATUS_REJECTED,ACCEPTED_ON_L2:exports.STATUS_ACCEPTED_ON_L2,ACCEPTED_ON_L1:exports.STATUS_ACCEPTED_ON_L1},exports.ETransactionFinalityStatus={ACCEPTED_ON_L2:exports.STATUS_ACCEPTED_ON_L2,ACCEPTED_ON_L1:exports.STATUS_ACCEPTED_ON_L1},exports.ETransactionExecutionStatus={SUCCEEDED:exports.STATUS_SUCCEEDED,REVERTED:exports.STATUS_REVERTED},exports.EBlockTag={LATEST:"latest",PENDING:"pending"},exports.EDataAvailabilityMode={L1:"L1",L2:"L2"},exports.EDAMode={L1:0,L2:1},exports.ETransactionVersion={V0:"0x0",V1:"0x1",V2:"0x2",V3:"0x3",F0:"0x100000000000000000000000000000000",F1:"0x100000000000000000000000000000001",F2:"0x100000000000000000000000000000002",F3:"0x100000000000000000000000000000003"},exports.ETransactionVersion2={V0:exports.ETransactionVersion.V0,V1:exports.ETransactionVersion.V1,V2:exports.ETransactionVersion.V2,F0:exports.ETransactionVersion.F0,F1:exports.ETransactionVersion.F1,F2:exports.ETransactionVersion.F2},exports.ETransactionVersion3={V3:exports.ETransactionVersion.V3,F3:exports.ETransactionVersion.F3}},22825:(__unused_webpack_module,exports,__webpack_require__)=>{var _interopRequireDefault=__webpack_require__(24994);Object.defineProperty(exports,"__esModule",{value:!0}),exports.isStarknetAccount=exports.isBitcoinAccount=exports.getStarknetNetwork=exports.getStarknetAccount=exports.getPrintableBitcoinTypeAccount=exports.getNetworksEnv=exports.getNetworks=exports.getNetworkEnv=exports.getBitcoinPaymentAccount=exports.getBitcoinOrdinalAccount=exports.getBitcoinAccounts=exports.getAccountsNetworkEnv=exports.getAccountNetworks=void 0;var _toConsumableArray2=_interopRequireDefault(__webpack_require__(41132)),_wallet=__webpack_require__(90774),isStarknetAccount=exports.isStarknetAccount=function(account){return!!account&&"bitcoin"!==account.network},isBitcoinAccount=exports.isBitcoinAccount=function(account){return!!account&&"bitcoin"===account.network},getBitcoinAccounts=(exports.getStarknetAccount=function(accounts){return null==accounts?void 0:accounts.find(isStarknetAccount)},exports.getBitcoinAccounts=function(accounts){return null==accounts?void 0:accounts.filter(isBitcoinAccount)}),networksMap=(exports.getBitcoinPaymentAccount=function(accounts){var _getBitcoinAccounts;return null===(_getBitcoinAccounts=getBitcoinAccounts(accounts))||void 0===_getBitcoinAccounts?void 0:_getBitcoinAccounts.find((function(a){return a.account_provider_impl===_wallet.AccountProvider.BitcoinSegwit}))},exports.getBitcoinOrdinalAccount=function(accounts){var _getBitcoinAccounts2;return null===(_getBitcoinAccounts2=getBitcoinAccounts(accounts))||void 0===_getBitcoinAccounts2?void 0:_getBitcoinAccounts2.find((function(a){return a.account_provider_impl===_wallet.AccountProvider.BitcoinTaproot}))},exports.getStarknetNetwork=function(networks){return null==networks?void 0:networks.find((function(n){return"bitcoin"!==n}))},exports.getAccountNetworks=function(accounts){return(0,_toConsumableArray2.default)(new Set((null!=accounts?accounts:[]).map((function(_ref){return _ref.network}))))},{mainnet:["mainnet-alpha","bitcoin"],testnet:["sepolia-alpha"],devnet:["devnet"],integration:["integration"]}),getNetworkEnv=(exports.getNetworks=function(networkEnv){var _networksMap$networkE;return null!==(_networksMap$networkE=networksMap[networkEnv])&&void 0!==_networksMap$networkE?_networksMap$networkE:[]},exports.getNetworkEnv=function(network){return Object.keys(networksMap).find((function(env){return networksMap[env].includes(network)}))});exports.getNetworksEnv=function(networks){return getNetworkEnv(null==networks?void 0:networks[0])},exports.getAccountsNetworkEnv=function(accounts){var _accounts$;return getNetworkEnv(null==accounts||null===(_accounts$=accounts[0])||void 0===_accounts$?void 0:_accounts$.network)},exports.getPrintableBitcoinTypeAccount=function(provider_iml){return provider_iml===_wallet.AccountProvider.BitcoinSegwit?"Native Segwit":provider_iml===_wallet.AccountProvider.BitcoinTaproot?"Taproot":void 0}},23956:(__unused_webpack_module,exports)=>{var WalletMethod,ConnectionType;Object.defineProperty(exports,"__esModule",{value:!0}),exports.WalletMethod=exports.ConnectionType=void 0,function(WalletMethod){WalletMethod.IS_NEW="IS_NEW",WalletMethod.IS_RECOVERING="IS_RECOVERING",WalletMethod.GET_RECOVERY_STATE="GET_RECOVERY_STATE",WalletMethod.LOCK="LOCK",WalletMethod.UNLOCK="UNLOCK",WalletMethod.IS_LOCKED="IS_LOCKED",WalletMethod.VALIDATE_PASSWORD="VALIDATE_PASSWORD",WalletMethod.GET_ALL_NETWORK_ENVS="GET_ALL_NETWORK_ENVS",WalletMethod.GET_ALL_NETWORKS_ACCOUNTS="GET_ALL_NETWORKS_ACCOUNTS",WalletMethod.GET_ACTIVE_NETWORK="GET_ACTIVE_NETWORK",WalletMethod.SET_ACTIVE_NETWORK_ENV="SET_ACTIVE_NETWORK_ENV",WalletMethod.GET_ALL_ACCOUNTS="GET_ALL_ACCOUNTS",WalletMethod.GET_ACTIVE_ACCOUNTS="GET_ACTIVE_ACCOUNTS",WalletMethod.SET_ACTIVE_ACCOUNT_INDEX="SET_ACTIVE_ACCOUNT_INDEX",WalletMethod.SET_ACCOUNT_NAME="SET_ACCOUNT_NAME",WalletMethod.AUX_ACCOUNT_AUTH="AUXILIARY_ACCOUNT_AUTH",WalletMethod.INVOKE="INVOKE",WalletMethod.SIGN_MESSAGE="SIGN_MESSAGE",WalletMethod.SIGN_PSBT="SIGN_PSBT",WalletMethod.DECLARE_CONTRACT="DECLARE_CONTRACT",WalletMethod.DEPLOY_CONTRACT="DEPLOY_CONTRACT",WalletMethod.NEW_ACCOUNT="NEW_ACCOUNT",WalletMethod.GENERATE_NEW_ACCOUNT_PARAMS="GENERATE_NEW_ACCOUNT_PARAMS",WalletMethod.IMPORT_LEDGER_ACCOUNT="IMPORT_LEDGER_ACCOUNT",WalletMethod.IMPORT_MULTI_OWNER_ACCOUNT="IMPORT_MULTI_OWNER_ACCOUNT",WalletMethod.IMPORT_READ_ONLY_ACCOUNT="IMPORT_READ_ONLY_ACCOUNT",WalletMethod.IMPORT_PRIVATE_KEY_ACCOUNT="IMPORT_PRIVATE_KEY_ACCOUNT",WalletMethod.EJECT_EXTERNAL_ACCOUNT="EJECT_EXTERNAL_ACCOUNT",WalletMethod.DEPLOY_ACTIVE_ACCOUNT="DEPLOY_ACTIVE_ACCOUNT",WalletMethod.DEPLOY_LEDGER_ACCOUNT="DEPLOY_LEDGER_ACCOUNT",WalletMethod.GET_VERSION="GET_VERSION",WalletMethod.GET_SIGNERS="GET_SIGNERS",WalletMethod.IS_POPUP_CONNECTED="IS_POPUP_CONNECTED",WalletMethod.GET_SEED="GET_SEED",WalletMethod.SEED_RECOVERY="SEED_RECOVERY",WalletMethod.INVOKE_ESTIMATE_FEE="INVOKE_ESTIMATE_FEE",WalletMethod.GASLESS_INVOKE_ESTIMATE="GASLESS_INVOKE_ESTIMATE",WalletMethod.DECLARE_CONTRACT_ESTIMATE_FEE="DECLARE_CONTRACT_ESTIMATE_FEE",WalletMethod.DEPLOY_CONTRACT_ESTIMATE_FEE="DEPLOY_CONTRACT_ESTIMATE_FEE",WalletMethod.DEPLOY_ACTIVE_ACCOUNT_ESTIMATE_FEE="DEPLOY_ACTIVE_ACCOUNT_ESTIMATE_FEE",WalletMethod.DEPLOY_MOCK_ACCOUNT_ESTIMATE_FEE="DEPLOY_MOCK_ACCOUNT_ESTIMATE_FEE",WalletMethod.GET_ACTIVE_ACCOUNT_FACTORY_DEPLOYMENT_CALL="GET_ACTIVE_ACCOUNT_FACTORY_DEPLOYMENT_CALL",WalletMethod.GET_ACTIVE_ACCOUNT_DEPLOYMENT_DATA="GET_ACTIVE_ACCOUNT_DEPLOYMENT_DATA",WalletMethod.UPGRADE_ESTIMATE_FEE="UPGRADE_ESTIMATE_FEE",WalletMethod.IS_UPGRADABLE="IS_UPGRADABLE",WalletMethod.UPGRADE="UPGRADE",WalletMethod.RESET="RESET",WalletMethod.GET_ACTIVE_ACCOUNTS_KEYS="GET_ACTIVE_ACCOUNTS_KEYS",WalletMethod.DISCOVER_NEW_ACCOUNTS="DISCOVER_NEW_ACCOUNTS",WalletMethod.IS_DEPLOYED="IS_DEPLOYED",WalletMethod.GET_PENDING_MULTISIG_TRANSACTION="GET_PENDING_MULTISIG_TRANSACTION",WalletMethod.HANDLE_ACCOUNT_PENDING_MULTISIG_TRANSACTION="HANDLE_ACCOUNT_PENDING_MULTISIG_TRANSACTION",WalletMethod.ADD_SIGNERS_ESTIMATE_FEE="ADD_SIGNERS_ESTIMATE_FEE",WalletMethod.REMOVE_SIGNERS_ESTIMATE_FEE="REMOVE_SIGNERS_ESTIMATE_FEE",WalletMethod.SWAP_SIGNERS_ESTIMATE_FEE="SWAP_SIGNERS_ESTIMATE_FEE",WalletMethod.CANCEL_SIGNER_DEFERRED_REMOVAL_ESTIMATE_FEE="CANCEL_SIGNER_DEFERRED_REMOVAL_ESTIMATE_FEE",WalletMethod.CANCEL_MULTISIG_DEFERRED_REMOVAL_ESTIMATE_FEE="CANCEL_MULTISIG_DEFERRED_REMOVAL_ESTIMATE_FEE",WalletMethod.DISABLE_MULTISIG_ESTIMATE_FEE="DISABLE_MULTISIG_ESTIMATE_FEE",WalletMethod.ENABLE_MULTISIG_ESTIMATE_FEE="ENABLE_MULTISIG_ESTIMATE_FEE",WalletMethod.SET_WITHDRAWAL_LIMITS_ESTIMATE_FEE="SET_WITHDRAWAL_LIMITS_ESTIMATE_FEE",WalletMethod.ADD_SIGNERS="ADD_SIGNERS",WalletMethod.REMOVE_SIGNERS="REMOVE_SIGNERS",WalletMethod.SWAP_SIGNERS="SWAP_SIGNERS",WalletMethod.CANCEL_SIGNER_DEFERRED_REMOVAL="CANCEL_SIGNER_DEFERRED_REMOVAL",WalletMethod.CANCEL_MULTISIG_DEFERRED_REMOVAL="CANCEL_MULTISIG_DEFERRED_REMOVAL",WalletMethod.DISABLE_MULTISIG="DISABLE_MULTISIG",WalletMethod.ENABLE_MULTISIG="ENABLE_MULTISIG",WalletMethod.SET_WITHDRAWAL_LIMITS="SET_WITHDRAWAL_LIMITS",WalletMethod.SET_DAILY_WITHDRAWAL_LIMITS="SET_DAILY_WITHDRAWAL_LIMITS",WalletMethod.SET_DAILY_WITHDRAWAL_LIMITS_ESTIMATE_FEE="SET_DAILY_WITHDRAWAL_LIMITS_ESTIMATE_FEE",WalletMethod.GET_WITHDRAWAL_LIMITS="GET_WITHDRAWAL_LIMITS",WalletMethod.GET_REQUIRED_SIGNER="GET_REQUIRED_SIGNER",WalletMethod.SYNC_ACTIVE_ACCOUNT_SNS="SYNC_ACTIVE_ACCOUNT_SNS",WalletMethod.REVOKE_SESSION_ESTIMATE_FEE="REVOKE_SESSION_ESTIMATE_FEE",WalletMethod.REVOKE_SESSION="REVOKE_SESSION",WalletMethod.RECONNECT_LEDGER="RECONNECT_LEDGER"}(WalletMethod||(exports.WalletMethod=WalletMethod={})),function(ConnectionType){ConnectionType.MessagesWallet="messages-wallet",ConnectionType.ContentListenerBridge="content-listener-bridge",ConnectionType.BackgroundIsReady="background-is-ready"}(ConnectionType||(exports.ConnectionType=ConnectionType={}))},23976:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},24967:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isNegativeLE=void 0,exports.mod=mod,exports.pow=pow,exports.pow2=function(x,power,modulo){let res=x;for(;power-- >_0n;)res*=res,res%=modulo;return res},exports.invert=invert,exports.tonelliShanks=tonelliShanks,exports.FpSqrt=FpSqrt,exports.validateField=function(field){const opts=FIELD_FIELDS.reduce(((map,val)=>(map[val]="function",map)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,utils_js_1.validateObject)(field,opts)},exports.FpPow=FpPow,exports.FpInvertBatch=FpInvertBatch,exports.FpDiv=function(f,lhs,rhs){return f.mul(lhs,"bigint"==typeof rhs?invert(rhs,f.ORDER):f.inv(rhs))},exports.FpLegendre=FpLegendre,exports.FpIsSquare=function(f){const legendre=FpLegendre(f.ORDER);return x=>{const p=legendre(f,x);return f.eql(p,f.ZERO)||f.eql(p,f.ONE)}},exports.nLength=nLength,exports.Field=function(ORDER,bitLen,isLE=!1,redef={}){if(ORDER<=_0n)throw new Error("invalid field: expected ORDER > 0, got "+ORDER);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let sqrtP;const f=Object.freeze({ORDER,BITS,BYTES,MASK:(0,utils_js_1.bitMask)(BITS),ZERO:_0n,ONE:_1n,create:num=>mod(num,ORDER),isValid:num=>{if("bigint"!=typeof num)throw new Error("invalid field element: expected bigint, got "+typeof num);return _0n<=num&&num<ORDER},is0:num=>num===_0n,isOdd:num=>(num&_1n)===_1n,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>(sqrtP||(sqrtP=FpSqrt(ORDER)),sqrtP(f,n))),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?(0,utils_js_1.numberToBytesLE)(num,BYTES):(0,utils_js_1.numberToBytesBE)(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error("Field.fromBytes: expected "+BYTES+" bytes, got "+bytes.length);return isLE?(0,utils_js_1.bytesToNumberLE)(bytes):(0,utils_js_1.bytesToNumberBE)(bytes)}});return Object.freeze(f)},exports.FpSqrtOdd=function(Fp,elm){if(!Fp.isOdd)throw new Error("Field doesn't have isOdd");const root=Fp.sqrt(elm);return Fp.isOdd(root)?root:Fp.neg(root)},exports.FpSqrtEven=function(Fp,elm){if(!Fp.isOdd)throw new Error("Field doesn't have isOdd");const root=Fp.sqrt(elm);return Fp.isOdd(root)?Fp.neg(root):root},exports.hashToPrivateScalar=function(hash,groupOrder,isLE=!1){const hashLen=(hash=(0,utils_js_1.ensureBytes)("privateHash",hash)).length,minLen=nLength(groupOrder).nByteLength+8;if(minLen<24||hashLen<minLen||hashLen>1024)throw new Error("hashToPrivateScalar: expected "+minLen+"-1024 bytes of input, got "+hashLen);return mod(isLE?(0,utils_js_1.bytesToNumberLE)(hash):(0,utils_js_1.bytesToNumberBE)(hash),groupOrder-_1n)+_1n},exports.getFieldBytesLength=getFieldBytesLength,exports.getMinHashLength=getMinHashLength,exports.mapHashToField=function(key,fieldOrder,isLE=!1){const len=key.length,fieldLen=getFieldBytesLength(fieldOrder),minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error("expected "+minLen+"-1024 bytes of input, got "+len);const reduced=mod(isLE?(0,utils_js_1.bytesToNumberBE)(key):(0,utils_js_1.bytesToNumberLE)(key),fieldOrder-_1n)+_1n;return isLE?(0,utils_js_1.numberToBytesLE)(reduced,fieldLen):(0,utils_js_1.numberToBytesBE)(reduced,fieldLen)};const utils_js_1=__webpack_require__(91484),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);function mod(a,b){const result=a%b;return result>=_0n?result:b+result}function pow(num,power,modulo){if(power<_0n)throw new Error("invalid exponent, negatives unsupported");if(modulo<=_0n)throw new Error("invalid modulus");if(modulo===_1n)return _0n;let res=_1n;for(;power>_0n;)power&_1n&&(res=res*num%modulo),num=num*num%modulo,power>>=_1n;return res}function invert(number,modulo){if(number===_0n)throw new Error("invert: expected non-zero number");if(modulo<=_0n)throw new Error("invert: expected positive modulus, got "+modulo);let a=mod(number,modulo),b=modulo,x=_0n,y=_1n,u=_1n,v=_0n;for(;a!==_0n;){const q=b/a,r=b%a,m=x-u*q,n=y-v*q;b=a,a=r,x=u,y=v,u=m,v=n}if(b!==_1n)throw new Error("invert: does not exist");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n)/_2n;let Q,S,Z;for(Q=P-_1n,S=0;Q%_2n===_0n;Q/=_2n,S++);for(Z=_2n;Z<P&&pow(Z,legendreC,P)!==P-_1n;Z++)if(Z>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===S){const p1div4=(P+_1n)/_4n;return function(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}const Q1div2=(Q+_1n)/_2n;return function(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error("Cannot find square root");let r=S,g=Fp.pow(Fp.mul(Fp.ONE,Z),Q),x=Fp.pow(n,Q1div2),b=Fp.pow(n,Q);for(;!Fp.eql(b,Fp.ONE);){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r&&!Fp.eql(t2,Fp.ONE);m++)t2=Fp.sqr(t2);const ge=Fp.pow(g,_1n<<BigInt(r-m-1));g=Fp.sqr(ge),x=Fp.mul(x,ge),b=Fp.mul(b,g),r=m}return x}}function FpSqrt(P){if(P%_4n===_3n){const p1div4=(P+_1n)/_4n;return function(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function(Fp,n){const n2=Fp.mul(n,_2n),v=Fp.pow(n2,c1),nv=Fp.mul(n,v),i=Fp.mul(Fp.mul(nv,_2n),v),root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}return tonelliShanks(P)}exports.isNegativeLE=(num,modulo)=>(mod(num,modulo)&_1n)===_1n;const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function FpPow(f,num,power){if(power<_0n)throw new Error("invalid exponent, negatives unsupported");if(power===_0n)return f.ONE;if(power===_1n)return num;let p=f.ONE,d=num;for(;power>_0n;)power&_1n&&(p=f.mul(p,d)),d=f.sqr(d),power>>=_1n;return p}function FpInvertBatch(f,nums){const tmp=new Array(nums.length),lastMultiplied=nums.reduce(((acc,num,i)=>f.is0(num)?acc:(tmp[i]=acc,f.mul(acc,num))),f.ONE),inverted=f.inv(lastMultiplied);return nums.reduceRight(((acc,num,i)=>f.is0(num)?acc:(tmp[i]=f.mul(acc,tmp[i]),f.mul(acc,num))),inverted),tmp}function FpLegendre(order){const legendreConst=(order-_1n)/_2n;return(f,x)=>f.pow(x,legendreConst)}function nLength(n,nBitLength){const _nBitLength=void 0!==nBitLength?nBitLength:n.toString(2).length;return{nBitLength:_nBitLength,nByteLength:Math.ceil(_nBitLength/8)}}function getFieldBytesLength(fieldOrder){if("bigint"!=typeof fieldOrder)throw new Error("field order must be bigint");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}},24994:module=>{module.exports=function(e){return e&&e.__esModule?e:{default:e}},module.exports.__esModule=!0,module.exports.default=module.exports},25076:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CONTRACT=void 0,__exportStar(__webpack_require__(68326),exports),exports.CONTRACT=__webpack_require__(81452),__exportStar(__webpack_require__(96949),exports),__exportStar(__webpack_require__(7014),exports),__exportStar(__webpack_require__(62560),exports),__exportStar(__webpack_require__(56409),exports),__exportStar(__webpack_require__(25858),exports),__exportStar(__webpack_require__(54691),exports)},25516:(__unused_webpack_module,exports,__webpack_require__)=>{var _interopRequireDefault=__webpack_require__(24994);Object.defineProperty(exports,"__esModule",{value:!0}),exports.getDevnetProvider=exports.getChainIdForNetwork=exports.StarknetWindowObject=void 0;var _inherits2=_interopRequireDefault(__webpack_require__(29511)),_possibleConstructorReturn2=_interopRequireDefault(__webpack_require__(28452)),_getPrototypeOf2=_interopRequireDefault(__webpack_require__(63072)),_toConsumableArray2=_interopRequireDefault(__webpack_require__(41132)),_classCallCheck2=_interopRequireDefault(__webpack_require__(17383)),_createClass2=_interopRequireDefault(__webpack_require__(34579)),_classPrivateFieldLooseBase2=_interopRequireDefault(__webpack_require__(33883)),_classPrivateFieldLooseKey2=_interopRequireDefault(__webpack_require__(60055)),_asyncToGenerator2=_interopRequireDefault(__webpack_require__(29293)),_typesJs=__webpack_require__(28967),_starknet=__webpack_require__(69226),_dappRequests=_interopRequireDefault(__webpack_require__(53213)),_message=__webpack_require__(23956),_logoBase=_interopRequireDefault(__webpack_require__(98748)),_starknetMessage=__webpack_require__(84557),_multiNetworks=__webpack_require__(22825);function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}function getPublicRpcForNetwork(network){switch(network){case"mainnet-alpha":return"https://starknet-mainnet.public.blastapi.io";case"sepolia-alpha":return"https://starknet-sepolia.public.blastapi.io";default:throw new Error(`No public RPC endpoint for network: ${network}`)}}var _ref,getChainIdForNetwork=exports.getChainIdForNetwork=function(network){switch(network){case"mainnet-alpha":return _starknet.constants.StarknetChainId.SN_MAIN;case"sepolia-alpha":return _starknet.constants.StarknetChainId.SN_SEPOLIA;default:return}},getDevnetProvider=exports.getDevnetProvider=(_ref=(0,_asyncToGenerator2.default)((function*(baseUrl,nodeType){if("rpc"===nodeType){var options={nodeUrl:baseUrl,blockIdentifier:"pending"};return new _starknet.RpcProvider(options)}})),function(_x,_x2){return _ref.apply(this,arguments)}),_callbacks=(0,_classPrivateFieldLooseKey2.default)("callbacks"),_snjsVersion=(0,_classPrivateFieldLooseKey2.default)("snjsVersion"),_getProvider=(0,_classPrivateFieldLooseKey2.default)("getProvider"),_getWrappedAccount=(0,_classPrivateFieldLooseKey2.default)("getWrappedAccount"),_executeImpl=(0,_classPrivateFieldLooseKey2.default)("executeImpl"),_signMsgImpl=(0,_classPrivateFieldLooseKey2.default)("signMsgImpl"),_declareImpl=(0,_classPrivateFieldLooseKey2.default)("declareImpl"),_deployImpl=(0,_classPrivateFieldLooseKey2.default)("deployImpl");exports.StarknetWindowObject=function(){function StarknetWindowObject(){var _this=this;(0,_classCallCheck2.default)(this,StarknetWindowObject),Object.defineProperty(this,_getWrappedAccount,{value:_getWrappedAccount2}),Object.defineProperty(this,_getProvider,{value:_getProvider2}),Object.defineProperty(this,_callbacks,{writable:!0,value:{}}),this.id="braavos",this.name="Braavos",this.icon=_logoBase.default,Object.defineProperty(this,_snjsVersion,{writable:!0,value:"v6"}),this.selectedAddress=void 0,this.chainId=void 0,this.isConnected=!1,this.provider=(0,_classPrivateFieldLooseBase2.default)(this,_getProvider)[_getProvider]("mainnet-alpha"),this.account=new _starknet.Account(this.provider,"",{}),Object.defineProperty(this,_executeImpl,{writable:!0,value:function(transactions){var calls=Array.isArray(transactions)?transactions:[transactions];return _this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.INVOKE,data:{calls},source:""}).then((function(msg){if(null==msg||!msg.txHash)throw Error("Execute failed");return{transaction_hash:msg.txHash}}))}}),Object.defineProperty(this,_signMsgImpl,{writable:!0,value:function(data){return _this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.SIGN_MESSAGE,data:{message:data},source:""}).then((function(msg){var _msg$asp$signers,_msg$asp,result=(null!==(_msg$asp$signers=null==msg||null===(_msg$asp=msg.asp)||void 0===_msg$asp?void 0:_msg$asp.signers)&&void 0!==_msg$asp$signers?_msg$asp$signers:[]).reduce((function(allSignatures,_ref2){var signature=_ref2.signature;return[].concat((0,_toConsumableArray2.default)(allSignatures),(0,_toConsumableArray2.default)(signature))}),[]);if(null==result||!result.length)throw Error("Signature failed");return result}))}}),Object.defineProperty(this,_declareImpl,{writable:!0,value:function(payload){return _this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.DECLARE_CONTRACT,data:payload,source:""}).then((function(msg){if(null==msg||!msg.tx_hash)throw Error("Declare failed");return{transaction_hash:msg.tx_hash,class_hash:`${payload.classHash}`}}))}}),Object.defineProperty(this,_deployImpl,{writable:!0,value:function(payload){var data=Array.isArray(payload)?payload:[payload];return _this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.DEPLOY_CONTRACT,data:{payload:data},source:""}).then((function(msg){if(null==msg||!msg.tx_hash)throw Error("Deploy failed");return{transaction_hash:msg.tx_hash,contract_address:msg.contract_address}}))}}),this.version="4.9.2"}var _handleIncomingMessage;return(0,_createClass2.default)(StarknetWindowObject,[{key:"handleIncomingMessage",value:(_handleIncomingMessage=(0,_asyncToGenerator2.default)((function*(message){var _message$from;if("braavos-inpage"!==(null==message?void 0:message.from)){var uid=null==message?void 0:message.uid;if(uid&&_dappRequests.default.has(uid))_dappRequests.default.resolve(uid,message.data);else if(null!=message&&null!==(_message$from=message.from)&&void 0!==_message$from&&_message$from.startsWith(_message.ConnectionType.ContentListenerBridge)){var _message$data=message.data,type=_message$data.type,data=_message$data.data,starknetAccount=(0,_multiNetworks.getStarknetAccount)(data);switch((0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]){case"v4":case"v5":var starknet=window.starknet_braavos;if(starknet)switch(type){case"networkChanged":var _classPrivateFieldLoo,_classPrivateFieldLoo2;starknet.isConnected=!0,starknet.selectedAddress="",starknet.provider=yield(0,_classPrivateFieldLooseBase2.default)(this,_getProvider)[_getProvider](null==starknetAccount?void 0:starknetAccount.network),starknet.chainId=getChainIdForNetwork(null==starknetAccount?void 0:starknetAccount.network),starknet.account=(0,_classPrivateFieldLooseBase2.default)(this,_getWrappedAccount)[_getWrappedAccount]("",starknet.provider),null===(_classPrivateFieldLoo=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks].networkChanged)||void 0===_classPrivateFieldLoo||null===(_classPrivateFieldLoo2=_classPrivateFieldLoo.listeners)||void 0===_classPrivateFieldLoo2||_classPrivateFieldLoo2.forEach((function(callback){return callback(null==starknetAccount?void 0:starknetAccount.network)}));break;case"accountsChanged":var _starknetAccount$addr,_classPrivateFieldLoo3,_classPrivateFieldLoo4;starknet.isConnected=!(null==starknetAccount||!starknetAccount.address),starknet.selectedAddress=null==starknetAccount?void 0:starknetAccount.address,starknet.isConnected||(starknet.provider=yield(0,_classPrivateFieldLooseBase2.default)(this,_getProvider)[_getProvider]("mainnet-alpha"),starknet.chainId=getChainIdForNetwork("mainnet-alpha")),starknet.account=(0,_classPrivateFieldLooseBase2.default)(this,_getWrappedAccount)[_getWrappedAccount](null!==(_starknetAccount$addr=null==starknetAccount?void 0:starknetAccount.address)&&void 0!==_starknetAccount$addr?_starknetAccount$addr:"",starknet.provider),null===(_classPrivateFieldLoo3=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks].accountsChanged)||void 0===_classPrivateFieldLoo3||null===(_classPrivateFieldLoo4=_classPrivateFieldLoo3.listeners)||void 0===_classPrivateFieldLoo4||_classPrivateFieldLoo4.forEach((function(callback){return callback(null==starknetAccount?void 0:starknetAccount.address)}))}break;case"v6":case"v7":var _callbackInfo$listene,_callbackInfo$lastDat,callbackInfo=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][type];if(null==callbackInfo||null===(_callbackInfo$listene=callbackInfo.listeners)||void 0===_callbackInfo$listene||!_callbackInfo$listene.length)return;if(JSON.stringify(null!=data?data:{})===JSON.stringify(null!==(_callbackInfo$lastDat=callbackInfo.lastData)&&void 0!==_callbackInfo$lastDat?_callbackInfo$lastDat:{}))return;callbackInfo.lastData=data,callbackInfo.listeners.forEach((function(callback){switch(type){case"networkChanged":callback(getChainIdForNetwork(null==starknetAccount?void 0:starknetAccount.network),starknetAccount?[starknetAccount.address]:[]);break;case"accountsChanged":callback(starknetAccount?[starknetAccount.address]:[])}}))}}}})),function(_x3){return _handleIncomingMessage.apply(this,arguments)})},{key:"request",value:function(call){switch((0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]){case"v4":case"v5":switch(call.type){case"wallet_watchAsset":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.WATCH_ASSET,data:call.params,source:""}).then((function(res){return!!res}));case"wallet_deploymentData":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.GET_DEPLOYMENT_DATA,source:""}).then((function(res){return res}));default:throw new Error("Not implemented")}case"v6":case"v7":switch(call.type){case"wallet_getPermissions":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.IS_AUTHORIZED,source:""}).then((function(msg){return msg?[_typesJs.Permission.ACCOUNTS]:[]}));case"wallet_requestAccounts":var _params,silent_mode=(null!==(_params=call.params)&&void 0!==_params?_params:{}).silent_mode;return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.CONNECT,data:{silent_mode},source:""}).then((function(msg){return null!=msg&&msg.address?[null==msg?void 0:msg.address]:[]}));case"wallet_watchAsset":var _params2=call.params,type=_params2.type,_params2$options=_params2.options,address=_params2$options.address,name=_params2$options.name,symbol=_params2$options.symbol,image=_params2$options.image,decimals=_params2$options.decimals;return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.WATCH_ASSET,data:{type,options:{address,name,symbol,image,decimals}},source:""}).then((function(res){return!!res}));case"wallet_addStarknetChain":case"wallet_switchStarknetChain":throw new Error(`Unsupported dApp request ${call.type}`);case"wallet_requestChainId":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.GET_CHAIN_ID,source:""}).then((function(res){return res}));case"wallet_deploymentData":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.GET_DEPLOYMENT_DATA,source:""}).then((function(res){return res}));case"wallet_addInvokeTransaction":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.INVOKE,data:{calls:call.params.calls.map((function(call){return{contractAddress:call.contract_address,entrypoint:call.entry_point,calldata:call.calldata}}))},source:""}).then((function(msg){if(null==msg||!msg.txHash)throw Error("Execute failed");return{transaction_hash:msg.txHash}}));case"wallet_addDeclareTransaction":var _params3=call.params,class_hash=_params3.class_hash,contract_class=_params3.contract_class,compiled_class_hash=_params3.compiled_class_hash;return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.DECLARE_CONTRACT,data:{classHash:class_hash,compiledClassHash:compiled_class_hash,contract:contract_class},source:""}).then((function(msg){if(null==msg||!msg.tx_hash)throw Error("Declare failed");return{transaction_hash:msg.tx_hash,class_hash:`${msg.class_hash}`}}));case"wallet_signTypedData":var _params4=call.params,message=_params4.message,types=_params4.types,primaryType=_params4.primaryType,domain=_params4.domain;return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.SIGN_MESSAGE,data:{message:{message,types,primaryType,domain}},source:""}).then((function(msg){var _msg$asp$signers2,_msg$asp2,result=(null!==(_msg$asp$signers2=null==msg||null===(_msg$asp2=msg.asp)||void 0===_msg$asp2?void 0:_msg$asp2.signers)&&void 0!==_msg$asp$signers2?_msg$asp$signers2:[]).reduce((function(allSignatures,_ref4){var signature=_ref4.signature;return[].concat((0,_toConsumableArray2.default)(allSignatures),(0,_toConsumableArray2.default)(signature))}),[]);if(null==result||!result.length)throw Error("Signature failed");return result}));case"wallet_supportedSpecs":return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.GET_SUPPORTED_SPECS,source:""}).then((function(res){return res}));default:throw new Error("Not implemented")}}}},{key:"isPreauthorized",value:function(){return"v6"===(0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]&&((0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]="v5"),this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.IS_AUTHORIZED,source:""}).then((function(msg){return!!msg}))}},{key:"on",value:function(event,handleEvent){var _classPrivateFieldLoo5,currListeners=(null!==(_classPrivateFieldLoo5=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event])&&void 0!==_classPrivateFieldLoo5?_classPrivateFieldLoo5:(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event]={listeners:[]}).listeners;currListeners.includes(handleEvent)||currListeners.push(handleEvent)}},{key:"off",value:function(event,handleEvent){var _classPrivateFieldLoo6;null!==(_classPrivateFieldLoo6=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event])&&void 0!==_classPrivateFieldLoo6&&_classPrivateFieldLoo6.listeners&&((0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event].listeners=(0,_classPrivateFieldLooseBase2.default)(this,_callbacks)[_callbacks][event].listeners.filter((function(callback){return callback!==handleEvent})))}},{key:"enable",value:function(options){var _ref5,_this2=this;return(0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]=null!=options&&options.starknetVersion&&["v4","v5"].includes(options.starknetVersion)?options.starknetVersion:"v5",this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.CONNECT,source:""}).then((_ref5=(0,_asyncToGenerator2.default)((function*(msg){if(!msg)return[""];var _window2=window,windowObj=[_window2.starknet_braavos,_window2.starknet].find((function(obj){return"braavos"===(null==obj?void 0:obj.id)}));return windowObj?(windowObj.isConnected=!0,windowObj.selectedAddress=msg.address,windowObj.provider=yield(0,_classPrivateFieldLooseBase2.default)(_this2,_getProvider)[_getProvider](msg.network),windowObj.account=(0,_classPrivateFieldLooseBase2.default)(_this2,_getWrappedAccount)[_getWrappedAccount](msg.address||"",windowObj.provider),[msg.address||""]):[""]})),function(_x4){return _ref5.apply(this,arguments)})).finally((function(){}))}}]),StarknetWindowObject}();function _getProvider2(network){var snjsVersion=["v6","v7"].includes((0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion])?"v5":(0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion];if("devnet"===network)return this.sendMessageFromInpageToContent({method:_starknetMessage.StarknetDappMethod.GET_NODE,source:""}).then((function(node){return node?getDevnetProvider(node.url,node.type):void 0}));switch(snjsVersion){case"v4":case"v5":var provider=new _starknet.RpcProvider({nodeUrl:getPublicRpcForNetwork(network),chainId:getChainIdForNetwork(network)});return provider.chainId=getChainIdForNetwork(network),provider;default:throw new Error(`[SNWindowObj] getProvider(): Unsupported starknet.js version ${snjsVersion}`)}}function _getWrappedAccount2(address,provider){switch((0,_classPrivateFieldLooseBase2.default)(this,_snjsVersion)[_snjsVersion]){case"v4":case"v5":return new WrappedAccount((0,_classPrivateFieldLooseBase2.default)(this,_executeImpl)[_executeImpl],(0,_classPrivateFieldLooseBase2.default)(this,_signMsgImpl)[_signMsgImpl],(0,_classPrivateFieldLooseBase2.default)(this,_declareImpl)[_declareImpl],(0,_classPrivateFieldLooseBase2.default)(this,_deployImpl)[_deployImpl],address,provider)}}var WrappedAccount=function(_Account){(0,_inherits2.default)(WrappedAccount,_Account);var t,r,_deploy,_declare,_signMessage,_execute,_super=(t=WrappedAccount,r=_isNativeReflectConstruct(),function(){var e,o=(0,_getPrototypeOf2.default)(t);if(r){var s=(0,_getPrototypeOf2.default)(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return(0,_possibleConstructorReturn2.default)(this,e)});function WrappedAccount(executeImpl,signMessageImpl,declareImpl,deployImpl,address,provider){var _this3;return(0,_classCallCheck2.default)(this,WrappedAccount),(_this3=_super.call(this,provider,address,"0")).executeImpl=executeImpl,_this3.signMessageImpl=signMessageImpl,_this3.declareImpl=declareImpl,_this3.deployImpl=deployImpl,_this3.provider=provider,_this3}return(0,_createClass2.default)(WrappedAccount,[{key:"execute",value:(_execute=(0,_asyncToGenerator2.default)((function*(transactions){return this.executeImpl(transactions)})),function(_x5){return _execute.apply(this,arguments)})},{key:"signMessage",value:(_signMessage=(0,_asyncToGenerator2.default)((function*(data){return this.signMessageImpl(data)})),function(_x6){return _signMessage.apply(this,arguments)})},{key:"declare",value:(_declare=(0,_asyncToGenerator2.default)((function*(payload){return this.declareImpl(payload)})),function(_x7){return _declare.apply(this,arguments)})},{key:"deploy",value:(_deploy=(0,_asyncToGenerator2.default)((function*(payload){return this.deployImpl(payload)})),function(_x8){return _deploy.apply(this,arguments)})}]),WrappedAccount}(_starknet.Account)},25858:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},27240:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.shake256=exports.shake128=exports.keccak_512=exports.keccak_384=exports.keccak_256=exports.keccak_224=exports.sha3_512=exports.sha3_384=exports.sha3_256=exports.sha3_224=exports.Keccak=void 0,exports.keccakP=keccakP;const _assert_js_1=__webpack_require__(90788),_u64_js_1=__webpack_require__(61529),utils_js_1=__webpack_require__(14762),SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=(0,_u64_js_1.split)(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?(0,_u64_js_1.rotlBH)(h,l,s):(0,_u64_js_1.rotlSH)(h,l,s),rotlL=(h,l,s)=>s>32?(0,_u64_js_1.rotlBL)(h,l,s):(0,_u64_js_1.rotlSL)(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends utils_js_1.Hash{constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,_assert_js_1.anumber)(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,utils_js_1.u32)(this.state)}keccak(){utils_js_1.isLE||(0,utils_js_1.byteSwap32)(this.state32),keccakP(this.state32,this.rounds),utils_js_1.isLE||(0,utils_js_1.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(data){(0,_assert_js_1.aexists)(this);const{blockLen,state}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){(0,_assert_js_1.aexists)(this,!1),(0,_assert_js_1.abytes)(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return(0,_assert_js_1.anumber)(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if((0,_assert_js_1.aoutput)(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}}exports.Keccak=Keccak;const gen=(suffix,blockLen,outputLen)=>(0,utils_js_1.wrapConstructor)((()=>new Keccak(blockLen,suffix,outputLen)));exports.sha3_224=gen(6,144,28),exports.sha3_256=gen(6,136,32),exports.sha3_384=gen(6,104,48),exports.sha3_512=gen(6,72,64),exports.keccak_224=gen(1,144,28),exports.keccak_256=gen(1,136,32),exports.keccak_384=gen(1,104,48),exports.keccak_512=gen(1,72,64);const genShake=(suffix,blockLen,outputLen)=>(0,utils_js_1.wrapXOFConstructorWithOpts)(((opts={})=>new Keccak(blockLen,suffix,void 0===opts.dkLen?outputLen:opts.dkLen,!0)));exports.shake128=genShake(31,168,16),exports.shake256=genShake(31,136,32)},28452:(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__(73738).default,assertThisInitialized=__webpack_require__(12475);module.exports=function(t,e){if(e&&("object"==_typeof(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)},module.exports.__esModule=!0,module.exports.default=module.exports},28967:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.PAYMASTER_API=exports.WALLET_API=exports.API=void 0,__exportStar(__webpack_require__(91692),exports),exports.API=__webpack_require__(91692),__exportStar(__webpack_require__(34100),exports),exports.WALLET_API=__webpack_require__(34100),exports.PAYMASTER_API=__webpack_require__(39062)},29020:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TypedDataRevision=void 0,exports.TypedDataRevision={ACTIVE:"1",LEGACY:"0"}},29293:module=>{function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}module.exports=function(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}},module.exports.__esModule=!0,module.exports.default=module.exports},29511:(module,__unused_webpack_exports,__webpack_require__)=>{var setPrototypeOf=__webpack_require__(95636);module.exports=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)},module.exports.__esModule=!0,module.exports.default=module.exports},30579:module=>{"use strict";const crcTable=new Uint32Array((()=>{let c,table=[];for(var n=0;n<256;n++){c=n;for(var k=0;k<8;k++)c=1&c?3988292384^c>>>1:c>>>1;table[n]=c}return table})());module.exports=(crc,buf,len,pos)=>{const t=crcTable,end=pos+len;crc^=-1;for(let i=pos;i<end;i++)crc=crc>>>8^t[255&(crc^buf[i])];return~crc}},32632:()=>{},33575:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.shake256=exports.shake128=exports.keccak_512=exports.keccak_384=exports.keccak_256=exports.keccak_224=exports.sha3_512=exports.sha3_384=exports.sha3_256=exports.sha3_224=exports.Keccak=void 0,exports.keccakP=keccakP;const _assert_js_1=__webpack_require__(85409),_u64_js_1=__webpack_require__(35418),utils_js_1=__webpack_require__(61667),SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=(0,_u64_js_1.split)(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?(0,_u64_js_1.rotlBH)(h,l,s):(0,_u64_js_1.rotlSH)(h,l,s),rotlL=(h,l,s)=>s>32?(0,_u64_js_1.rotlBL)(h,l,s):(0,_u64_js_1.rotlSL)(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends utils_js_1.Hash{constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,_assert_js_1.anumber)(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,utils_js_1.u32)(this.state)}keccak(){utils_js_1.isLE||(0,utils_js_1.byteSwap32)(this.state32),keccakP(this.state32,this.rounds),utils_js_1.isLE||(0,utils_js_1.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(data){(0,_assert_js_1.aexists)(this);const{blockLen,state}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){(0,_assert_js_1.aexists)(this,!1),(0,_assert_js_1.abytes)(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return(0,_assert_js_1.anumber)(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if((0,_assert_js_1.aoutput)(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}}exports.Keccak=Keccak;const gen=(suffix,blockLen,outputLen)=>(0,utils_js_1.wrapConstructor)((()=>new Keccak(blockLen,suffix,outputLen)));exports.sha3_224=gen(6,144,28),exports.sha3_256=gen(6,136,32),exports.sha3_384=gen(6,104,48),exports.sha3_512=gen(6,72,64),exports.keccak_224=gen(1,144,28),exports.keccak_256=gen(1,136,32),exports.keccak_384=gen(1,104,48),exports.keccak_512=gen(1,72,64);const genShake=(suffix,blockLen,outputLen)=>(0,utils_js_1.wrapXOFConstructorWithOpts)(((opts={})=>new Keccak(blockLen,suffix,void 0===opts.dkLen?outputLen:opts.dkLen,!0)));exports.shake128=genShake(31,168,16),exports.shake256=genShake(31,136,32)},33883:module=>{module.exports=function(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e},module.exports.__esModule=!0,module.exports.default=module.exports},34100:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(46425),exports),__exportStar(__webpack_require__(29020),exports),__exportStar(__webpack_require__(92125),exports),__exportStar(__webpack_require__(66534),exports),__exportStar(__webpack_require__(58118),exports),__exportStar(__webpack_require__(87695),exports),__exportStar(__webpack_require__(51541),exports)},34579:(module,__unused_webpack_exports,__webpack_require__)=>{var toPropertyKey=__webpack_require__(77736);function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}module.exports=function(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e},module.exports.__esModule=!0,module.exports.default=module.exports},35418:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.add5L=exports.add5H=exports.add4H=exports.add4L=exports.add3H=exports.add3L=exports.rotlBL=exports.rotlBH=exports.rotlSL=exports.rotlSH=exports.rotr32L=exports.rotr32H=exports.rotrBL=exports.rotrBH=exports.rotrSL=exports.rotrSH=exports.shrSL=exports.shrSH=exports.toBig=void 0,exports.fromBig=fromBig,exports.split=split,exports.add=add;const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const toBig=(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0);exports.toBig=toBig;const shrSH=(h,_l,s)=>h>>>s;exports.shrSH=shrSH;const shrSL=(h,l,s)=>h<<32-s|l>>>s;exports.shrSL=shrSL;const rotrSH=(h,l,s)=>h>>>s|l<<32-s;exports.rotrSH=rotrSH;const rotrSL=(h,l,s)=>h<<32-s|l>>>s;exports.rotrSL=rotrSL;const rotrBH=(h,l,s)=>h<<64-s|l>>>s-32;exports.rotrBH=rotrBH;const rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;exports.rotrBL=rotrBL;const rotr32H=(_h,l)=>l;exports.rotr32H=rotr32H;const rotr32L=(h,_l)=>h;exports.rotr32L=rotr32L;const rotlSH=(h,l,s)=>h<<s|l>>>32-s;exports.rotlSH=rotlSH;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;exports.rotlSL=rotlSL;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;exports.rotlBH=rotlBH;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}}exports.rotlBL=rotlBL;const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0);exports.add3L=add3L;const add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0;exports.add3H=add3H;const add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0);exports.add4L=add4L;const add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0;exports.add4H=add4H;const add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0);exports.add5L=add5L;const add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0;exports.add5H=add5H;const u64={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L};exports.default=u64},35921:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.decode=exports.encode=exports.unescape=exports.escape=exports.pad=void 0;const base64_js_1=__webpack_require__(67526);function pad(base64){return`${base64}${"=".repeat(4-(base64.length%4||4))}`}function escape(base64){return base64.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function unescape(base64Url){return pad(base64Url).replace(/-/g,"+").replace(/_/g,"/")}exports.pad=pad,exports.escape=escape,exports.unescape=unescape,exports.encode=function(base64){return escape((0,base64_js_1.fromByteArray)((new TextEncoder).encode(base64)))},exports.decode=function(base64Url){return(new TextDecoder).decode((0,base64_js_1.toByteArray)(pad(unescape(base64Url))))}},37995:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hash=exports.nextTick=exports.byteSwapIfBE=exports.isLE=void 0,exports.isBytes=function(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name},exports.u8=function(arr){return new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength)},exports.u32=function(arr){return new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4))},exports.createView=function(arr){return new DataView(arr.buffer,arr.byteOffset,arr.byteLength)},exports.rotr=function(word,shift){return word<<32-shift|word>>>shift},exports.rotl=function(word,shift){return word<<shift|word>>>32-shift>>>0},exports.byteSwap=byteSwap,exports.byteSwap32=function(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i])},exports.bytesToHex=function(bytes){(0,_assert_js_1.abytes)(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex},exports.hexToBytes=function(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=asciiToBase16(hex.charCodeAt(hi)),n2=asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array},exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;diff>=0&&diff<tick||(await(0,exports.nextTick)(),ts+=diff)}},exports.utf8ToBytes=utf8ToBytes,exports.toBytes=toBytes,exports.concatBytes=function(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert_js_1.abytes)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res},exports.checkOpts=function(defaults,opts){if(void 0!==opts&&"[object Object]"!=={}.toString.call(opts))throw new Error("Options should be object or undefined");return Object.assign(defaults,opts)},exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC},exports.wrapConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.randomBytes)return crypto_1.crypto.randomBytes(bytesLength);throw new Error("crypto.getRandomValues must be defined")};const crypto_1=__webpack_require__(72669),_assert_js_1=__webpack_require__(9113);function byteSwap(word){return word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255}exports.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],exports.byteSwapIfBE=exports.isLE?n=>n:n=>byteSwap(n);const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(ch){return ch>=asciis._0&&ch<=asciis._9?ch-asciis._0:ch>=asciis.A&&ch<=asciis.F?ch-(asciis.A-10):ch>=asciis.a&&ch<=asciis.f?ch-(asciis.a-10):void 0}function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){return"string"==typeof data&&(data=utf8ToBytes(data)),(0,_assert_js_1.abytes)(data),data}exports.nextTick=async()=>{};exports.Hash=class{clone(){return this._cloneInto()}}},39062:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(46316),exports),__exportStar(__webpack_require__(82923),exports),__exportStar(__webpack_require__(23976),exports),__exportStar(__webpack_require__(69114),exports)},39829:module=>{"use strict";module.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},41132:(module,__unused_webpack_exports,__webpack_require__)=>{var arrayWithoutHoles=__webpack_require__(5901),iterableToArray=__webpack_require__(99291),unsupportedIterableToArray=__webpack_require__(17122),nonIterableSpread=__webpack_require__(41869);module.exports=function(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()},module.exports.__esModule=!0,module.exports.default=module.exports},41869:module=>{module.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")},module.exports.__esModule=!0,module.exports.default=module.exports},43693:(module,__unused_webpack_exports,__webpack_require__)=>{var toPropertyKey=__webpack_require__(77736);module.exports=function(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e},module.exports.__esModule=!0,module.exports.default=module.exports},44540:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(51425),exports),__exportStar(__webpack_require__(1956),exports),__exportStar(__webpack_require__(65781),exports),__exportStar(__webpack_require__(10526),exports),__exportStar(__webpack_require__(78),exports),__exportStar(__webpack_require__(63527),exports),__exportStar(__webpack_require__(74509),exports)},45920:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.validateOpts=validateOpts,exports.splitConstants=function(rc,t){if("number"!=typeof t)throw new Error("poseidonSplitConstants: invalid t");if(!Array.isArray(rc)||rc.length%t)throw new Error("poseidonSplitConstants: invalid rc");const res=[];let tmp=[];for(let i=0;i<rc.length;i++)tmp.push(rc[i]),tmp.length===t&&(res.push(tmp),tmp=[]);return res},exports.poseidon=function(opts){const _opts=validateOpts(opts),{Fp,mds,roundConstants,rounds:totalRounds,roundsPartial,sboxFn,t}=_opts,halfRoundsFull=_opts.roundsFull/2,partialIdx=_opts.reversePartialPowIdx?t-1:0,poseidonRound=(values,isFull,idx)=>(values=values.map(((i,j)=>Fp.add(i,roundConstants[idx][j]))),isFull?values=values.map((i=>sboxFn(i))):values[partialIdx]=sboxFn(values[partialIdx]),values=mds.map((i=>i.reduce(((acc,i,j)=>Fp.add(acc,Fp.mulN(i,values[j]))),Fp.ZERO)))),poseidonHash=function(values){if(!Array.isArray(values)||values.length!==t)throw new Error("invalid values, expected array of bigints with length "+t);values=values.map((i=>{if("bigint"!=typeof i)throw new Error("invalid bigint="+i);return Fp.create(i)}));let lastRound=0;for(let i=0;i<halfRoundsFull;i++)values=poseidonRound(values,!0,lastRound++);for(let i=0;i<roundsPartial;i++)values=poseidonRound(values,!1,lastRound++);for(let i=0;i<halfRoundsFull;i++)values=poseidonRound(values,!0,lastRound++);if(lastRound!==totalRounds)throw new Error("invalid number of rounds");return values};return poseidonHash.roundConstants=roundConstants,poseidonHash};const modular_js_1=__webpack_require__(24967);function validateOpts(opts){const{Fp,mds,reversePartialPowIdx:rev,roundConstants:rc}=opts,{roundsFull,roundsPartial,sboxPower,t}=opts;(0,modular_js_1.validateField)(Fp);for(const i of["t","roundsFull","roundsPartial"])if("number"!=typeof opts[i]||!Number.isSafeInteger(opts[i]))throw new Error("invalid number "+i);if(!Array.isArray(mds)||mds.length!==t)throw new Error("Poseidon: invalid MDS matrix");const _mds=mds.map((mdsRow=>{if(!Array.isArray(mdsRow)||mdsRow.length!==t)throw new Error("invalid MDS matrix row: "+mdsRow);return mdsRow.map((i=>{if("bigint"!=typeof i)throw new Error("invalid MDS matrix bigint: "+i);return Fp.create(i)}))}));if(void 0!==rev&&"boolean"!=typeof rev)throw new Error("invalid param reversePartialPowIdx="+rev);if(1&roundsFull)throw new Error("roundsFull is not even"+roundsFull);const rounds=roundsFull+roundsPartial;if(!Array.isArray(rc)||rc.length!==rounds)throw new Error("Poseidon: invalid round constants");const roundConstants=rc.map((rc=>{if(!Array.isArray(rc)||rc.length!==t)throw new Error("invalid round constants");return rc.map((i=>{if("bigint"!=typeof i||!Fp.isValid(i))throw new Error("invalid round constant");return Fp.create(i)}))}));if(!sboxPower||![3,5,7].includes(sboxPower))throw new Error("invalid sboxPower");const _sboxPower=BigInt(sboxPower);let sboxFn=n=>(0,modular_js_1.FpPow)(Fp,n,_sboxPower);return 3===sboxPower?sboxFn=n=>Fp.mul(Fp.sqrN(n),n):5===sboxPower&&(sboxFn=n=>Fp.mul(Fp.sqrN(Fp.sqrN(n)),n)),Object.freeze({...opts,rounds,sboxFn,roundConstants,mds:_mds})}},46316:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},46425:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Permission=void 0,exports.Permission={ACCOUNTS:"accounts"}},46501:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.crypto=void 0,exports.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},47627:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},48287:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";const base64=__webpack_require__(67526),ieee754=__webpack_require__(251),customInspectSymbol="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;exports.Buffer=Buffer,exports.INSPECT_MAX_BYTES=50;const K_MAX_LENGTH=2147483647;function createBuffer(length){if(length>K_MAX_LENGTH)throw new RangeError('The value "'+length+'" is invalid for option "size"');const buf=new Uint8Array(length);return Object.setPrototypeOf(buf,Buffer.prototype),buf}function Buffer(arg,encodingOrOffset,length){if("number"==typeof arg){if("string"==typeof encodingOrOffset)throw new TypeError('The "string" argument must be of type string. Received type number');return allocUnsafe(arg)}return from(arg,encodingOrOffset,length)}function from(value,encodingOrOffset,length){if("string"==typeof value)return function(string,encoding){"string"==typeof encoding&&""!==encoding||(encoding="utf8");if(!Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: "+encoding);const length=0|byteLength(string,encoding);let buf=createBuffer(length);const actual=buf.write(string,encoding);actual!==length&&(buf=buf.slice(0,actual));return buf}(value,encodingOrOffset);if(ArrayBuffer.isView(value))return function(arrayView){if(isInstance(arrayView,Uint8Array)){const copy=new Uint8Array(arrayView);return fromArrayBuffer(copy.buffer,copy.byteOffset,copy.byteLength)}return fromArrayLike(arrayView)}(value);if(null==value)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof value);if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer))return fromArrayBuffer(value,encodingOrOffset,length);if("undefined"!=typeof SharedArrayBuffer&&(isInstance(value,SharedArrayBuffer)||value&&isInstance(value.buffer,SharedArrayBuffer)))return fromArrayBuffer(value,encodingOrOffset,length);if("number"==typeof value)throw new TypeError('The "value" argument must not be of type number. Received type number');const valueOf=value.valueOf&&value.valueOf();if(null!=valueOf&&valueOf!==value)return Buffer.from(valueOf,encodingOrOffset,length);const b=function(obj){if(Buffer.isBuffer(obj)){const len=0|checked(obj.length),buf=createBuffer(len);return 0===buf.length||obj.copy(buf,0,0,len),buf}if(void 0!==obj.length)return"number"!=typeof obj.length||numberIsNaN(obj.length)?createBuffer(0):fromArrayLike(obj);if("Buffer"===obj.type&&Array.isArray(obj.data))return fromArrayLike(obj.data)}(value);if(b)return b;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof value[Symbol.toPrimitive])return Buffer.from(value[Symbol.toPrimitive]("string"),encodingOrOffset,length);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof value)}function assertSize(size){if("number"!=typeof size)throw new TypeError('"size" argument must be of type number');if(size<0)throw new RangeError('The value "'+size+'" is invalid for option "size"')}function allocUnsafe(size){return assertSize(size),createBuffer(size<0?0:0|checked(size))}function fromArrayLike(array){const length=array.length<0?0:0|checked(array.length),buf=createBuffer(length);for(let i=0;i<length;i+=1)buf[i]=255&array[i];return buf}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset)throw new RangeError('"offset" is outside of buffer bounds');if(array.byteLength<byteOffset+(length||0))throw new RangeError('"length" is outside of buffer bounds');let buf;return buf=void 0===byteOffset&&void 0===length?new Uint8Array(array):void 0===length?new Uint8Array(array,byteOffset):new Uint8Array(array,byteOffset,length),Object.setPrototypeOf(buf,Buffer.prototype),buf}function checked(length){if(length>=K_MAX_LENGTH)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+K_MAX_LENGTH.toString(16)+" bytes");return 0|length}function byteLength(string,encoding){if(Buffer.isBuffer(string))return string.length;if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer))return string.byteLength;if("string"!=typeof string)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof string);const len=string.length,mustMatch=arguments.length>2&&!0===arguments[2];if(!mustMatch&&0===len)return 0;let loweredCase=!1;for(;;)switch(encoding){case"ascii":case"latin1":case"binary":return len;case"utf8":case"utf-8":return utf8ToBytes(string).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*len;case"hex":return len>>>1;case"base64":return base64ToBytes(string).length;default:if(loweredCase)return mustMatch?-1:utf8ToBytes(string).length;encoding=(""+encoding).toLowerCase(),loweredCase=!0}}function slowToString(encoding,start,end){let loweredCase=!1;if((void 0===start||start<0)&&(start=0),start>this.length)return"";if((void 0===end||end>this.length)&&(end=this.length),end<=0)return"";if((end>>>=0)<=(start>>>=0))return"";for(encoding||(encoding="utf8");;)switch(encoding){case"hex":return hexSlice(this,start,end);case"utf8":case"utf-8":return utf8Slice(this,start,end);case"ascii":return asciiSlice(this,start,end);case"latin1":case"binary":return latin1Slice(this,start,end);case"base64":return base64Slice(this,start,end);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError("Unknown encoding: "+encoding);encoding=(encoding+"").toLowerCase(),loweredCase=!0}}function swap(b,n,m){const i=b[n];b[n]=b[m],b[m]=i}function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){if(0===buffer.length)return-1;if("string"==typeof byteOffset?(encoding=byteOffset,byteOffset=0):byteOffset>2147483647?byteOffset=2147483647:byteOffset<-2147483648&&(byteOffset=-2147483648),numberIsNaN(byteOffset=+byteOffset)&&(byteOffset=dir?0:buffer.length-1),byteOffset<0&&(byteOffset=buffer.length+byteOffset),byteOffset>=buffer.length){if(dir)return-1;byteOffset=buffer.length-1}else if(byteOffset<0){if(!dir)return-1;byteOffset=0}if("string"==typeof val&&(val=Buffer.from(val,encoding)),Buffer.isBuffer(val))return 0===val.length?-1:arrayIndexOf(buffer,val,byteOffset,encoding,dir);if("number"==typeof val)return val&=255,"function"==typeof Uint8Array.prototype.indexOf?dir?Uint8Array.prototype.indexOf.call(buffer,val,byteOffset):Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset):arrayIndexOf(buffer,[val],byteOffset,encoding,dir);throw new TypeError("val must be string, number or Buffer")}function arrayIndexOf(arr,val,byteOffset,encoding,dir){let i,indexSize=1,arrLength=arr.length,valLength=val.length;if(void 0!==encoding&&("ucs2"===(encoding=String(encoding).toLowerCase())||"ucs-2"===encoding||"utf16le"===encoding||"utf-16le"===encoding)){if(arr.length<2||val.length<2)return-1;indexSize=2,arrLength/=2,valLength/=2,byteOffset/=2}function read(buf,i){return 1===indexSize?buf[i]:buf.readUInt16BE(i*indexSize)}if(dir){let foundIndex=-1;for(i=byteOffset;i<arrLength;i++)if(read(arr,i)===read(val,-1===foundIndex?0:i-foundIndex)){if(-1===foundIndex&&(foundIndex=i),i-foundIndex+1===valLength)return foundIndex*indexSize}else-1!==foundIndex&&(i-=i-foundIndex),foundIndex=-1}else for(byteOffset+valLength>arrLength&&(byteOffset=arrLength-valLength),i=byteOffset;i>=0;i--){let found=!0;for(let j=0;j<valLength;j++)if(read(arr,i+j)!==read(val,j)){found=!1;break}if(found)return i}return-1}function hexWrite(buf,string,offset,length){offset=Number(offset)||0;const remaining=buf.length-offset;length?(length=Number(length))>remaining&&(length=remaining):length=remaining;const strLen=string.length;let i;for(length>strLen/2&&(length=strLen/2),i=0;i<length;++i){const parsed=parseInt(string.substr(2*i,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed}return i}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length)}function asciiWrite(buf,string,offset,length){return blitBuffer(function(str){const byteArray=[];for(let i=0;i<str.length;++i)byteArray.push(255&str.charCodeAt(i));return byteArray}(string),buf,offset,length)}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length)}function ucs2Write(buf,string,offset,length){return blitBuffer(function(str,units){let c,hi,lo;const byteArray=[];for(let i=0;i<str.length&&!((units-=2)<0);++i)c=str.charCodeAt(i),hi=c>>8,lo=c%256,byteArray.push(lo),byteArray.push(hi);return byteArray}(string,buf.length-offset),buf,offset,length)}function base64Slice(buf,start,end){return 0===start&&end===buf.length?base64.fromByteArray(buf):base64.fromByteArray(buf.slice(start,end))}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);const res=[];let i=start;for(;i<end;){const firstByte=buf[i];let codePoint=null,bytesPerSequence=firstByte>239?4:firstByte>223?3:firstByte>191?2:1;if(i+bytesPerSequence<=end){let secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:firstByte<128&&(codePoint=firstByte);break;case 2:secondByte=buf[i+1],128==(192&secondByte)&&(tempCodePoint=(31&firstByte)<<6|63&secondByte,tempCodePoint>127&&(codePoint=tempCodePoint));break;case 3:secondByte=buf[i+1],thirdByte=buf[i+2],128==(192&secondByte)&&128==(192&thirdByte)&&(tempCodePoint=(15&firstByte)<<12|(63&secondByte)<<6|63&thirdByte,tempCodePoint>2047&&(tempCodePoint<55296||tempCodePoint>57343)&&(codePoint=tempCodePoint));break;case 4:secondByte=buf[i+1],thirdByte=buf[i+2],fourthByte=buf[i+3],128==(192&secondByte)&&128==(192&thirdByte)&&128==(192&fourthByte)&&(tempCodePoint=(15&firstByte)<<18|(63&secondByte)<<12|(63&thirdByte)<<6|63&fourthByte,tempCodePoint>65535&&tempCodePoint<1114112&&(codePoint=tempCodePoint))}}null===codePoint?(codePoint=65533,bytesPerSequence=1):codePoint>65535&&(codePoint-=65536,res.push(codePoint>>>10&1023|55296),codePoint=56320|1023&codePoint),res.push(codePoint),i+=bytesPerSequence}return function(codePoints){const len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,codePoints);let res="",i=0;for(;i<len;)res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));return res}(res)}Buffer.TYPED_ARRAY_SUPPORT=function(){try{const arr=new Uint8Array(1),proto={foo:function(){return 42}};return Object.setPrototypeOf(proto,Uint8Array.prototype),Object.setPrototypeOf(arr,proto),42===arr.foo()}catch(e){return!1}}(),!Buffer.TYPED_ARRAY_SUPPORT&&"undefined"!=typeof console&&console.error,Object.defineProperty(Buffer.prototype,"parent",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.buffer}}),Object.defineProperty(Buffer.prototype,"offset",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.byteOffset}}),Buffer.poolSize=8192,Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length)},Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype),Object.setPrototypeOf(Buffer,Uint8Array),Buffer.alloc=function(size,fill,encoding){return function(size,fill,encoding){return assertSize(size),size<=0?createBuffer(size):void 0!==fill?"string"==typeof encoding?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill):createBuffer(size)}(size,fill,encoding)},Buffer.allocUnsafe=function(size){return allocUnsafe(size)},Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size)},Buffer.isBuffer=function(b){return null!=b&&!0===b._isBuffer&&b!==Buffer.prototype},Buffer.compare=function(a,b){if(isInstance(a,Uint8Array)&&(a=Buffer.from(a,a.offset,a.byteLength)),isInstance(b,Uint8Array)&&(b=Buffer.from(b,b.offset,b.byteLength)),!Buffer.isBuffer(a)||!Buffer.isBuffer(b))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(a===b)return 0;let x=a.length,y=b.length;for(let i=0,len=Math.min(x,y);i<len;++i)if(a[i]!==b[i]){x=a[i],y=b[i];break}return x<y?-1:y<x?1:0},Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(list,length){if(!Array.isArray(list))throw new TypeError('"list" argument must be an Array of Buffers');if(0===list.length)return Buffer.alloc(0);let i;if(void 0===length)for(length=0,i=0;i<list.length;++i)length+=list[i].length;const buffer=Buffer.allocUnsafe(length);let pos=0;for(i=0;i<list.length;++i){let buf=list[i];if(isInstance(buf,Uint8Array))pos+buf.length>buffer.length?(Buffer.isBuffer(buf)||(buf=Buffer.from(buf)),buf.copy(buffer,pos)):Uint8Array.prototype.set.call(buffer,buf,pos);else{if(!Buffer.isBuffer(buf))throw new TypeError('"list" argument must be an Array of Buffers');buf.copy(buffer,pos)}pos+=buf.length}return buffer},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){const len=this.length;if(len%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let i=0;i<len;i+=2)swap(this,i,i+1);return this},Buffer.prototype.swap32=function(){const len=this.length;if(len%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let i=0;i<len;i+=4)swap(this,i,i+3),swap(this,i+1,i+2);return this},Buffer.prototype.swap64=function(){const len=this.length;if(len%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let i=0;i<len;i+=8)swap(this,i,i+7),swap(this,i+1,i+6),swap(this,i+2,i+5),swap(this,i+3,i+4);return this},Buffer.prototype.toString=function(){const length=this.length;return 0===length?"":0===arguments.length?utf8Slice(this,0,length):slowToString.apply(this,arguments)},Buffer.prototype.toLocaleString=Buffer.prototype.toString,Buffer.prototype.equals=function(b){if(!Buffer.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||0===Buffer.compare(this,b)},Buffer.prototype.inspect=function(){let str="";const max=exports.INSPECT_MAX_BYTES;return str=this.toString("hex",0,max).replace(/(.{2})/g,"$1 ").trim(),this.length>max&&(str+=" ... "),"<Buffer "+str+">"},customInspectSymbol&&(Buffer.prototype[customInspectSymbol]=Buffer.prototype.inspect),Buffer.prototype.compare=function(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)&&(target=Buffer.from(target,target.offset,target.byteLength)),!Buffer.isBuffer(target))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof target);if(void 0===start&&(start=0),void 0===end&&(end=target?target.length:0),void 0===thisStart&&(thisStart=0),void 0===thisEnd&&(thisEnd=this.length),start<0||end>target.length||thisStart<0||thisEnd>this.length)throw new RangeError("out of range index");if(thisStart>=thisEnd&&start>=end)return 0;if(thisStart>=thisEnd)return-1;if(start>=end)return 1;if(this===target)return 0;let x=(thisEnd>>>=0)-(thisStart>>>=0),y=(end>>>=0)-(start>>>=0);const len=Math.min(x,y),thisCopy=this.slice(thisStart,thisEnd),targetCopy=target.slice(start,end);for(let i=0;i<len;++i)if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i],y=targetCopy[i];break}return x<y?-1:y<x?1:0},Buffer.prototype.includes=function(val,byteOffset,encoding){return-1!==this.indexOf(val,byteOffset,encoding)},Buffer.prototype.indexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,!0)},Buffer.prototype.lastIndexOf=function(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,!1)},Buffer.prototype.write=function(string,offset,length,encoding){if(void 0===offset)encoding="utf8",length=this.length,offset=0;else if(void 0===length&&"string"==typeof offset)encoding=offset,length=this.length,offset=0;else{if(!isFinite(offset))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");offset>>>=0,isFinite(length)?(length>>>=0,void 0===encoding&&(encoding="utf8")):(encoding=length,length=void 0)}const remaining=this.length-offset;if((void 0===length||length>remaining)&&(length=remaining),string.length>0&&(length<0||offset<0)||offset>this.length)throw new RangeError("Attempt to write outside buffer bounds");encoding||(encoding="utf8");let loweredCase=!1;for(;;)switch(encoding){case"hex":return hexWrite(this,string,offset,length);case"utf8":case"utf-8":return utf8Write(this,string,offset,length);case"ascii":case"latin1":case"binary":return asciiWrite(this,string,offset,length);case"base64":return base64Write(this,string,offset,length);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError("Unknown encoding: "+encoding);encoding=(""+encoding).toLowerCase(),loweredCase=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const MAX_ARGUMENTS_LENGTH=4096;function asciiSlice(buf,start,end){let ret="";end=Math.min(buf.length,end);for(let i=start;i<end;++i)ret+=String.fromCharCode(127&buf[i]);return ret}function latin1Slice(buf,start,end){let ret="";end=Math.min(buf.length,end);for(let i=start;i<end;++i)ret+=String.fromCharCode(buf[i]);return ret}function hexSlice(buf,start,end){const len=buf.length;(!start||start<0)&&(start=0),(!end||end<0||end>len)&&(end=len);let out="";for(let i=start;i<end;++i)out+=hexSliceLookupTable[buf[i]];return out}function utf16leSlice(buf,start,end){const bytes=buf.slice(start,end);let res="";for(let i=0;i<bytes.length-1;i+=2)res+=String.fromCharCode(bytes[i]+256*bytes[i+1]);return res}function checkOffset(offset,ext,length){if(offset%1!=0||offset<0)throw new RangeError("offset is not uint");if(offset+ext>length)throw new RangeError("Trying to access beyond buffer length")}function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError("Index out of range")}function wrtBigUInt64LE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);let lo=Number(value&BigInt(4294967295));buf[offset++]=lo,lo>>=8,buf[offset++]=lo,lo>>=8,buf[offset++]=lo,lo>>=8,buf[offset++]=lo;let hi=Number(value>>BigInt(32)&BigInt(4294967295));return buf[offset++]=hi,hi>>=8,buf[offset++]=hi,hi>>=8,buf[offset++]=hi,hi>>=8,buf[offset++]=hi,offset}function wrtBigUInt64BE(buf,value,offset,min,max){checkIntBI(value,min,max,buf,offset,7);let lo=Number(value&BigInt(4294967295));buf[offset+7]=lo,lo>>=8,buf[offset+6]=lo,lo>>=8,buf[offset+5]=lo,lo>>=8,buf[offset+4]=lo;let hi=Number(value>>BigInt(32)&BigInt(4294967295));return buf[offset+3]=hi,hi>>=8,buf[offset+2]=hi,hi>>=8,buf[offset+1]=hi,hi>>=8,buf[offset]=hi,offset+8}function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError("Index out of range");if(offset<0)throw new RangeError("Index out of range")}function writeFloat(buf,value,offset,littleEndian,noAssert){return value=+value,offset>>>=0,noAssert||checkIEEE754(buf,0,offset,4),ieee754.write(buf,value,offset,littleEndian,23,4),offset+4}function writeDouble(buf,value,offset,littleEndian,noAssert){return value=+value,offset>>>=0,noAssert||checkIEEE754(buf,0,offset,8),ieee754.write(buf,value,offset,littleEndian,52,8),offset+8}Buffer.prototype.slice=function(start,end){const len=this.length;(start=~~start)<0?(start+=len)<0&&(start=0):start>len&&(start=len),(end=void 0===end?len:~~end)<0?(end+=len)<0&&(end=0):end>len&&(end=len),end<start&&(end=start);const newBuf=this.subarray(start,end);return Object.setPrototypeOf(newBuf,Buffer.prototype),newBuf},Buffer.prototype.readUintLE=Buffer.prototype.readUIntLE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);let val=this[offset],mul=1,i=0;for(;++i<byteLength&&(mul*=256);)val+=this[offset+i]*mul;return val},Buffer.prototype.readUintBE=Buffer.prototype.readUIntBE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);let val=this[offset+--byteLength],mul=1;for(;byteLength>0&&(mul*=256);)val+=this[offset+--byteLength]*mul;return val},Buffer.prototype.readUint8=Buffer.prototype.readUInt8=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,1,this.length),this[offset]},Buffer.prototype.readUint16LE=Buffer.prototype.readUInt16LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,2,this.length),this[offset]|this[offset+1]<<8},Buffer.prototype.readUint16BE=Buffer.prototype.readUInt16BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,2,this.length),this[offset]<<8|this[offset+1]},Buffer.prototype.readUint32LE=Buffer.prototype.readUInt32LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+16777216*this[offset+3]},Buffer.prototype.readUint32BE=Buffer.prototype.readUInt32BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),16777216*this[offset]+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3])},Buffer.prototype.readBigUInt64LE=defineBigIntMethod((function(offset){validateNumber(offset>>>=0,"offset");const first=this[offset],last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);const lo=first+256*this[++offset]+65536*this[++offset]+this[++offset]*2**24,hi=this[++offset]+256*this[++offset]+65536*this[++offset]+last*2**24;return BigInt(lo)+(BigInt(hi)<<BigInt(32))})),Buffer.prototype.readBigUInt64BE=defineBigIntMethod((function(offset){validateNumber(offset>>>=0,"offset");const first=this[offset],last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);const hi=first*2**24+65536*this[++offset]+256*this[++offset]+this[++offset],lo=this[++offset]*2**24+65536*this[++offset]+256*this[++offset]+last;return(BigInt(hi)<<BigInt(32))+BigInt(lo)})),Buffer.prototype.readIntLE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);let val=this[offset],mul=1,i=0;for(;++i<byteLength&&(mul*=256);)val+=this[offset+i]*mul;return mul*=128,val>=mul&&(val-=Math.pow(2,8*byteLength)),val},Buffer.prototype.readIntBE=function(offset,byteLength,noAssert){offset>>>=0,byteLength>>>=0,noAssert||checkOffset(offset,byteLength,this.length);let i=byteLength,mul=1,val=this[offset+--i];for(;i>0&&(mul*=256);)val+=this[offset+--i]*mul;return mul*=128,val>=mul&&(val-=Math.pow(2,8*byteLength)),val},Buffer.prototype.readInt8=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,1,this.length),128&this[offset]?-1*(255-this[offset]+1):this[offset]},Buffer.prototype.readInt16LE=function(offset,noAssert){offset>>>=0,noAssert||checkOffset(offset,2,this.length);const val=this[offset]|this[offset+1]<<8;return 32768&val?4294901760|val:val},Buffer.prototype.readInt16BE=function(offset,noAssert){offset>>>=0,noAssert||checkOffset(offset,2,this.length);const val=this[offset+1]|this[offset]<<8;return 32768&val?4294901760|val:val},Buffer.prototype.readInt32LE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24},Buffer.prototype.readInt32BE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3]},Buffer.prototype.readBigInt64LE=defineBigIntMethod((function(offset){validateNumber(offset>>>=0,"offset");const first=this[offset],last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);const val=this[offset+4]+256*this[offset+5]+65536*this[offset+6]+(last<<24);return(BigInt(val)<<BigInt(32))+BigInt(first+256*this[++offset]+65536*this[++offset]+this[++offset]*2**24)})),Buffer.prototype.readBigInt64BE=defineBigIntMethod((function(offset){validateNumber(offset>>>=0,"offset");const first=this[offset],last=this[offset+7];void 0!==first&&void 0!==last||boundsError(offset,this.length-8);const val=(first<<24)+65536*this[++offset]+256*this[++offset]+this[++offset];return(BigInt(val)<<BigInt(32))+BigInt(this[++offset]*2**24+65536*this[++offset]+256*this[++offset]+last)})),Buffer.prototype.readFloatLE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),ieee754.read(this,offset,!0,23,4)},Buffer.prototype.readFloatBE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,4,this.length),ieee754.read(this,offset,!1,23,4)},Buffer.prototype.readDoubleLE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,8,this.length),ieee754.read(this,offset,!0,52,8)},Buffer.prototype.readDoubleBE=function(offset,noAssert){return offset>>>=0,noAssert||checkOffset(offset,8,this.length),ieee754.read(this,offset,!1,52,8)},Buffer.prototype.writeUintLE=Buffer.prototype.writeUIntLE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,byteLength>>>=0,!noAssert){checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0)}let mul=1,i=0;for(this[offset]=255&value;++i<byteLength&&(mul*=256);)this[offset+i]=value/mul&255;return offset+byteLength},Buffer.prototype.writeUintBE=Buffer.prototype.writeUIntBE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,byteLength>>>=0,!noAssert){checkInt(this,value,offset,byteLength,Math.pow(2,8*byteLength)-1,0)}let i=byteLength-1,mul=1;for(this[offset+i]=255&value;--i>=0&&(mul*=256);)this[offset+i]=value/mul&255;return offset+byteLength},Buffer.prototype.writeUint8=Buffer.prototype.writeUInt8=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,1,255,0),this[offset]=255&value,offset+1},Buffer.prototype.writeUint16LE=Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,65535,0),this[offset]=255&value,this[offset+1]=value>>>8,offset+2},Buffer.prototype.writeUint16BE=Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,65535,0),this[offset]=value>>>8,this[offset+1]=255&value,offset+2},Buffer.prototype.writeUint32LE=Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,4294967295,0),this[offset+3]=value>>>24,this[offset+2]=value>>>16,this[offset+1]=value>>>8,this[offset]=255&value,offset+4},Buffer.prototype.writeUint32BE=Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,4294967295,0),this[offset]=value>>>24,this[offset+1]=value>>>16,this[offset+2]=value>>>8,this[offset+3]=255&value,offset+4},Buffer.prototype.writeBigUInt64LE=defineBigIntMethod((function(value,offset=0){return wrtBigUInt64LE(this,value,offset,BigInt(0),BigInt("0xffffffffffffffff"))})),Buffer.prototype.writeBigUInt64BE=defineBigIntMethod((function(value,offset=0){return wrtBigUInt64BE(this,value,offset,BigInt(0),BigInt("0xffffffffffffffff"))})),Buffer.prototype.writeIntLE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,!noAssert){const limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit)}let i=0,mul=1,sub=0;for(this[offset]=255&value;++i<byteLength&&(mul*=256);)value<0&&0===sub&&0!==this[offset+i-1]&&(sub=1),this[offset+i]=(value/mul|0)-sub&255;return offset+byteLength},Buffer.prototype.writeIntBE=function(value,offset,byteLength,noAssert){if(value=+value,offset>>>=0,!noAssert){const limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit)}let i=byteLength-1,mul=1,sub=0;for(this[offset+i]=255&value;--i>=0&&(mul*=256);)value<0&&0===sub&&0!==this[offset+i+1]&&(sub=1),this[offset+i]=(value/mul|0)-sub&255;return offset+byteLength},Buffer.prototype.writeInt8=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,1,127,-128),value<0&&(value=255+value+1),this[offset]=255&value,offset+1},Buffer.prototype.writeInt16LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,32767,-32768),this[offset]=255&value,this[offset+1]=value>>>8,offset+2},Buffer.prototype.writeInt16BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,2,32767,-32768),this[offset]=value>>>8,this[offset+1]=255&value,offset+2},Buffer.prototype.writeInt32LE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,2147483647,-2147483648),this[offset]=255&value,this[offset+1]=value>>>8,this[offset+2]=value>>>16,this[offset+3]=value>>>24,offset+4},Buffer.prototype.writeInt32BE=function(value,offset,noAssert){return value=+value,offset>>>=0,noAssert||checkInt(this,value,offset,4,2147483647,-2147483648),value<0&&(value=4294967295+value+1),this[offset]=value>>>24,this[offset+1]=value>>>16,this[offset+2]=value>>>8,this[offset+3]=255&value,offset+4},Buffer.prototype.writeBigInt64LE=defineBigIntMethod((function(value,offset=0){return wrtBigUInt64LE(this,value,offset,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),Buffer.prototype.writeBigInt64BE=defineBigIntMethod((function(value,offset=0){return wrtBigUInt64BE(this,value,offset,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,!0,noAssert)},Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,value,offset,!1,noAssert)},Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,!0,noAssert)},Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,!1,noAssert)},Buffer.prototype.copy=function(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError("argument should be a Buffer");if(start||(start=0),end||0===end||(end=this.length),targetStart>=target.length&&(targetStart=target.length),targetStart||(targetStart=0),end>0&&end<start&&(end=start),end===start)return 0;if(0===target.length||0===this.length)return 0;if(targetStart<0)throw new RangeError("targetStart out of bounds");if(start<0||start>=this.length)throw new RangeError("Index out of range");if(end<0)throw new RangeError("sourceEnd out of bounds");end>this.length&&(end=this.length),target.length-targetStart<end-start&&(end=target.length-targetStart+start);const len=end-start;return this===target&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(targetStart,start,end):Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart),len},Buffer.prototype.fill=function(val,start,end,encoding){if("string"==typeof val){if("string"==typeof start?(encoding=start,start=0,end=this.length):"string"==typeof end&&(encoding=end,end=this.length),void 0!==encoding&&"string"!=typeof encoding)throw new TypeError("encoding must be a string");if("string"==typeof encoding&&!Buffer.isEncoding(encoding))throw new TypeError("Unknown encoding: "+encoding);if(1===val.length){const code=val.charCodeAt(0);("utf8"===encoding&&code<128||"latin1"===encoding)&&(val=code)}}else"number"==typeof val?val&=255:"boolean"==typeof val&&(val=Number(val));if(start<0||this.length<start||this.length<end)throw new RangeError("Out of range index");if(end<=start)return this;let i;if(start>>>=0,end=void 0===end?this.length:end>>>0,val||(val=0),"number"==typeof val)for(i=start;i<end;++i)this[i]=val;else{const bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding),len=bytes.length;if(0===len)throw new TypeError('The value "'+val+'" is invalid for argument "value"');for(i=0;i<end-start;++i)this[i+start]=bytes[i%len]}return this};const errors={};function E(sym,getMessage,Base){errors[sym]=class extends Base{constructor(){super(),Object.defineProperty(this,"message",{value:getMessage.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${sym}]`,this.stack,delete this.name}get code(){return sym}set code(value){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value,writable:!0})}toString(){return`${this.name} [${sym}]: ${this.message}`}}}function addNumericalSeparator(val){let res="",i=val.length;const start="-"===val[0]?1:0;for(;i>=start+4;i-=3)res=`_${val.slice(i-3,i)}${res}`;return`${val.slice(0,i)}${res}`}function checkIntBI(value,min,max,buf,offset,byteLength){if(value>max||value<min){const n="bigint"==typeof min?"n":"";let range;throw range=byteLength>3?0===min||min===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(byteLength+1)}${n}`:`>= -(2${n} ** ${8*(byteLength+1)-1}${n}) and < 2 ** ${8*(byteLength+1)-1}${n}`:`>= ${min}${n} and <= ${max}${n}`,new errors.ERR_OUT_OF_RANGE("value",range,value)}!function(buf,offset,byteLength){validateNumber(offset,"offset"),void 0!==buf[offset]&&void 0!==buf[offset+byteLength]||boundsError(offset,buf.length-(byteLength+1))}(buf,offset,byteLength)}function validateNumber(value,name){if("number"!=typeof value)throw new errors.ERR_INVALID_ARG_TYPE(name,"number",value)}function boundsError(value,length,type){if(Math.floor(value)!==value)throw validateNumber(value,type),new errors.ERR_OUT_OF_RANGE(type||"offset","an integer",value);if(length<0)throw new errors.ERR_BUFFER_OUT_OF_BOUNDS;throw new errors.ERR_OUT_OF_RANGE(type||"offset",`>= ${type?1:0} and <= ${length}`,value)}E("ERR_BUFFER_OUT_OF_BOUNDS",(function(name){return name?`${name} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),E("ERR_INVALID_ARG_TYPE",(function(name,actual){return`The "${name}" argument must be of type number. Received type ${typeof actual}`}),TypeError),E("ERR_OUT_OF_RANGE",(function(str,range,input){let msg=`The value of "${str}" is out of range.`,received=input;return Number.isInteger(input)&&Math.abs(input)>2**32?received=addNumericalSeparator(String(input)):"bigint"==typeof input&&(received=String(input),(input>BigInt(2)**BigInt(32)||input<-(BigInt(2)**BigInt(32)))&&(received=addNumericalSeparator(received)),received+="n"),msg+=` It must be ${range}. Received ${received}`,msg}),RangeError);const INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function utf8ToBytes(string,units){let codePoint;units=units||1/0;const length=string.length;let leadSurrogate=null;const bytes=[];for(let i=0;i<length;++i){if(codePoint=string.charCodeAt(i),codePoint>55295&&codePoint<57344){if(!leadSurrogate){if(codePoint>56319){(units-=3)>-1&&bytes.push(239,191,189);continue}if(i+1===length){(units-=3)>-1&&bytes.push(239,191,189);continue}leadSurrogate=codePoint;continue}if(codePoint<56320){(units-=3)>-1&&bytes.push(239,191,189),leadSurrogate=codePoint;continue}codePoint=65536+(leadSurrogate-55296<<10|codePoint-56320)}else leadSurrogate&&(units-=3)>-1&&bytes.push(239,191,189);if(leadSurrogate=null,codePoint<128){if((units-=1)<0)break;bytes.push(codePoint)}else if(codePoint<2048){if((units-=2)<0)break;bytes.push(codePoint>>6|192,63&codePoint|128)}else if(codePoint<65536){if((units-=3)<0)break;bytes.push(codePoint>>12|224,codePoint>>6&63|128,63&codePoint|128)}else{if(!(codePoint<1114112))throw new Error("Invalid code point");if((units-=4)<0)break;bytes.push(codePoint>>18|240,codePoint>>12&63|128,codePoint>>6&63|128,63&codePoint|128)}}return bytes}function base64ToBytes(str){return base64.toByteArray(function(str){if((str=(str=str.split("=")[0]).trim().replace(INVALID_BASE64_RE,"")).length<2)return"";for(;str.length%4!=0;)str+="=";return str}(str))}function blitBuffer(src,dst,offset,length){let i;for(i=0;i<length&&!(i+offset>=dst.length||i>=src.length);++i)dst[i+offset]=src[i];return i}function isInstance(obj,type){return obj instanceof type||null!=obj&&null!=obj.constructor&&null!=obj.constructor.name&&obj.constructor.name===type.name}function numberIsNaN(obj){return obj!=obj}const hexSliceLookupTable=function(){const table=new Array(256);for(let i=0;i<16;++i){const i16=16*i;for(let j=0;j<16;++j)table[i16+j]="0123456789abcdef"[i]+"0123456789abcdef"[j]}return table}();function defineBigIntMethod(fn){return"undefined"==typeof BigInt?BufferBigIntNotDefined:fn}function BufferBigIntNotDefined(){throw new Error("BigInt not supported")}},48801:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(14472),exports),__exportStar(__webpack_require__(69973),exports),__exportStar(__webpack_require__(50938),exports),__exportStar(__webpack_require__(96857),exports),__exportStar(__webpack_require__(47627),exports),__exportStar(__webpack_require__(77324),exports),__exportStar(__webpack_require__(5142),exports)},50938:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},51425:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Permission=void 0,exports.Permission={ACCOUNTS:"accounts"}},51541:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},53213:(__unused_webpack_module,exports,__webpack_require__)=>{var _interopRequireDefault=__webpack_require__(24994);Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _uid=_interopRequireDefault(__webpack_require__(92944)),pendingDappRequests={},dappRequestsManager={add:function(message,callback){var uid=(0,_uid.default)();return pendingDappRequests[uid]={message,callback},uid},resolve:function(uid,result){var _pendingDappRequests$;null===(_pendingDappRequests$=pendingDappRequests[uid])||void 0===_pendingDappRequests$||_pendingDappRequests$.callback(result),delete pendingDappRequests[uid]},get:function(uid){var _pendingDappRequests$2;return null===(_pendingDappRequests$2=pendingDappRequests[uid])||void 0===_pendingDappRequests$2?void 0:_pendingDappRequests$2.message},has:function(uid){return!!pendingDappRequests[uid]}};exports.default=dappRequestsManager},53435:(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(callback,options){var initOrigin=window.location.origin,innerCallback=function(event){event.origin===initOrigin&&event.source===window&&callback(event)};return window.addEventListener("message",innerCallback,options),function(){return window.removeEventListener("message",innerCallback)}}},53751:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=__webpack_require__(94325),adler32=__webpack_require__(82217),crc32=__webpack_require__(30579),msg=__webpack_require__(81494),{Z_NO_FLUSH,Z_PARTIAL_FLUSH,Z_FULL_FLUSH,Z_FINISH,Z_BLOCK,Z_OK,Z_STREAM_END,Z_STREAM_ERROR,Z_DATA_ERROR,Z_BUF_ERROR,Z_DEFAULT_COMPRESSION,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY,Z_UNKNOWN,Z_DEFLATED}=__webpack_require__(39829),err=(strm,errorCode)=>(strm.msg=msg[errorCode],errorCode),rank=f=>2*f-(f>4?9:0),zero=buf=>{let len=buf.length;for(;--len>=0;)buf[len]=0},slide_hash=s=>{let n,m,p,wsize=s.w_size;n=s.hash_size,p=n;do{m=s.head[--p],s.head[p]=m>=wsize?m-wsize:0}while(--n);n=wsize,p=n;do{m=s.prev[--p],s.prev[p]=m>=wsize?m-wsize:0}while(--n)};let HASH=(s,prev,data)=>(prev<<s.hash_shift^data)&s.hash_mask;const flush_pending=strm=>{const s=strm.state;let len=s.pending;len>strm.avail_out&&(len=strm.avail_out),0!==len&&(strm.output.set(s.pending_buf.subarray(s.pending_out,s.pending_out+len),strm.next_out),strm.next_out+=len,s.pending_out+=len,strm.total_out+=len,strm.avail_out-=len,s.pending-=len,0===s.pending&&(s.pending_out=0))},flush_block_only=(s,last)=>{_tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,last),s.block_start=s.strstart,flush_pending(s.strm)},put_byte=(s,b)=>{s.pending_buf[s.pending++]=b},putShortMSB=(s,b)=>{s.pending_buf[s.pending++]=b>>>8&255,s.pending_buf[s.pending++]=255&b},read_buf=(strm,buf,start,size)=>{let len=strm.avail_in;return len>size&&(len=size),0===len?0:(strm.avail_in-=len,buf.set(strm.input.subarray(strm.next_in,strm.next_in+len),start),1===strm.state.wrap?strm.adler=adler32(strm.adler,buf,len,start):2===strm.state.wrap&&(strm.adler=crc32(strm.adler,buf,len,start)),strm.next_in+=len,strm.total_in+=len,len)},longest_match=(s,cur_match)=>{let match,len,chain_length=s.max_chain_length,scan=s.strstart,best_len=s.prev_length,nice_match=s.nice_match;const limit=s.strstart>s.w_size-262?s.strstart-(s.w_size-262):0,_win=s.window,wmask=s.w_mask,prev=s.prev,strend=s.strstart+258;let scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len];s.prev_length>=s.good_match&&(chain_length>>=2),nice_match>s.lookahead&&(nice_match=s.lookahead);do{if(match=cur_match,_win[match+best_len]===scan_end&&_win[match+best_len-1]===scan_end1&&_win[match]===_win[scan]&&_win[++match]===_win[scan+1]){scan+=2,match++;do{}while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);if(len=258-(strend-scan),scan=strend-258,len>best_len){if(s.match_start=cur_match,best_len=len,len>=nice_match)break;scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len]}}}while((cur_match=prev[cur_match&wmask])>limit&&0!=--chain_length);return best_len<=s.lookahead?best_len:s.lookahead},fill_window=s=>{const _w_size=s.w_size;let n,more,str;do{if(more=s.window_size-s.lookahead-s.strstart,s.strstart>=_w_size+(_w_size-262)&&(s.window.set(s.window.subarray(_w_size,_w_size+_w_size-more),0),s.match_start-=_w_size,s.strstart-=_w_size,s.block_start-=_w_size,s.insert>s.strstart&&(s.insert=s.strstart),slide_hash(s),more+=_w_size),0===s.strm.avail_in)break;if(n=read_buf(s.strm,s.window,s.strstart+s.lookahead,more),s.lookahead+=n,s.lookahead+s.insert>=3)for(str=s.strstart-s.insert,s.ins_h=s.window[str],s.ins_h=HASH(s,s.ins_h,s.window[str+1]);s.insert&&(s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++,s.insert--,!(s.lookahead+s.insert<3)););}while(s.lookahead<262&&0!==s.strm.avail_in)},deflate_stored=(s,flush)=>{let len,left,have,min_block=s.pending_buf_size-5>s.w_size?s.w_size:s.pending_buf_size-5,last=0,used=s.strm.avail_in;do{if(len=65535,have=s.bi_valid+42>>3,s.strm.avail_out<have)break;if(have=s.strm.avail_out-have,left=s.strstart-s.block_start,len>left+s.strm.avail_in&&(len=left+s.strm.avail_in),len>have&&(len=have),len<min_block&&(0===len&&flush!==Z_FINISH||flush===Z_NO_FLUSH||len!==left+s.strm.avail_in))break;last=flush===Z_FINISH&&len===left+s.strm.avail_in?1:0,_tr_stored_block(s,0,0,last),s.pending_buf[s.pending-4]=len,s.pending_buf[s.pending-3]=len>>8,s.pending_buf[s.pending-2]=~len,s.pending_buf[s.pending-1]=~len>>8,flush_pending(s.strm),left&&(left>len&&(left=len),s.strm.output.set(s.window.subarray(s.block_start,s.block_start+left),s.strm.next_out),s.strm.next_out+=left,s.strm.avail_out-=left,s.strm.total_out+=left,s.block_start+=left,len-=left),len&&(read_buf(s.strm,s.strm.output,s.strm.next_out,len),s.strm.next_out+=len,s.strm.avail_out-=len,s.strm.total_out+=len)}while(0===last);return used-=s.strm.avail_in,used&&(used>=s.w_size?(s.matches=2,s.window.set(s.strm.input.subarray(s.strm.next_in-s.w_size,s.strm.next_in),0),s.strstart=s.w_size,s.insert=s.strstart):(s.window_size-s.strstart<=used&&(s.strstart-=s.w_size,s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0),s.matches<2&&s.matches++,s.insert>s.strstart&&(s.insert=s.strstart)),s.window.set(s.strm.input.subarray(s.strm.next_in-used,s.strm.next_in),s.strstart),s.strstart+=used,s.insert+=used>s.w_size-s.insert?s.w_size-s.insert:used),s.block_start=s.strstart),s.high_water<s.strstart&&(s.high_water=s.strstart),last?4:flush!==Z_NO_FLUSH&&flush!==Z_FINISH&&0===s.strm.avail_in&&s.strstart===s.block_start?2:(have=s.window_size-s.strstart,s.strm.avail_in>have&&s.block_start>=s.w_size&&(s.block_start-=s.w_size,s.strstart-=s.w_size,s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0),s.matches<2&&s.matches++,have+=s.w_size,s.insert>s.strstart&&(s.insert=s.strstart)),have>s.strm.avail_in&&(have=s.strm.avail_in),have&&(read_buf(s.strm,s.window,s.strstart,have),s.strstart+=have,s.insert+=have>s.w_size-s.insert?s.w_size-s.insert:have),s.high_water<s.strstart&&(s.high_water=s.strstart),have=s.bi_valid+42>>3,have=s.pending_buf_size-have>65535?65535:s.pending_buf_size-have,min_block=have>s.w_size?s.w_size:have,left=s.strstart-s.block_start,(left>=min_block||(left||flush===Z_FINISH)&&flush!==Z_NO_FLUSH&&0===s.strm.avail_in&&left<=have)&&(len=left>have?have:left,last=flush===Z_FINISH&&0===s.strm.avail_in&&len===left?1:0,_tr_stored_block(s,s.block_start,len,last),s.block_start+=len,flush_pending(s.strm)),last?3:1)},deflate_fast=(s,flush)=>{let hash_head,bflush;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),0!==hash_head&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head)),s.match_length>=3)if(bflush=_tr_tally(s,s.strstart-s.match_start,s.match_length-3),s.lookahead-=s.match_length,s.match_length<=s.max_lazy_match&&s.lookahead>=3){s.match_length--;do{s.strstart++,s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart}while(0!=--s.match_length);s.strstart++}else s.strstart+=s.match_length,s.match_length=0,s.ins_h=s.window[s.strstart],s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+1]);else bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++;if(bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2},deflate_slow=(s,flush)=>{let hash_head,bflush,max_insert;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),s.prev_length=s.match_length,s.prev_match=s.match_start,s.match_length=2,0!==hash_head&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head),s.match_length<=5&&(s.strategy===Z_FILTERED||3===s.match_length&&s.strstart-s.match_start>4096)&&(s.match_length=2)),s.prev_length>=3&&s.match_length<=s.prev_length){max_insert=s.strstart+s.lookahead-3,bflush=_tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-3),s.lookahead-=s.prev_length-1,s.prev_length-=2;do{++s.strstart<=max_insert&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart)}while(0!=--s.prev_length);if(s.match_available=0,s.match_length=2,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}else if(s.match_available){if(bflush=_tr_tally(s,0,s.window[s.strstart-1]),bflush&&flush_block_only(s,!1),s.strstart++,s.lookahead--,0===s.strm.avail_out)return 1}else s.match_available=1,s.strstart++,s.lookahead--}return s.match_available&&(bflush=_tr_tally(s,0,s.window[s.strstart-1]),s.match_available=0),s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2};function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length,this.max_lazy=max_lazy,this.nice_length=nice_length,this.max_chain=max_chain,this.func=func}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),zero(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateStateCheck=strm=>{if(!strm)return 1;const s=strm.state;return!s||s.strm!==strm||42!==s.status&&57!==s.status&&69!==s.status&&73!==s.status&&91!==s.status&&103!==s.status&&113!==s.status&&666!==s.status?1:0},deflateResetKeep=strm=>{if(deflateStateCheck(strm))return err(strm,Z_STREAM_ERROR);strm.total_in=strm.total_out=0,strm.data_type=Z_UNKNOWN;const s=strm.state;return s.pending=0,s.pending_out=0,s.wrap<0&&(s.wrap=-s.wrap),s.status=2===s.wrap?57:s.wrap?42:113,strm.adler=2===s.wrap?0:1,s.last_flush=-2,_tr_init(s),Z_OK},deflateReset=strm=>{const ret=deflateResetKeep(strm);var s;return ret===Z_OK&&((s=strm.state).window_size=2*s.w_size,zero(s.head),s.max_lazy_match=configuration_table[s.level].max_lazy,s.good_match=configuration_table[s.level].good_length,s.nice_match=configuration_table[s.level].nice_length,s.max_chain_length=configuration_table[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),ret},deflateInit2=(strm,level,method,windowBits,memLevel,strategy)=>{if(!strm)return Z_STREAM_ERROR;let wrap=1;if(level===Z_DEFAULT_COMPRESSION&&(level=6),windowBits<0?(wrap=0,windowBits=-windowBits):windowBits>15&&(wrap=2,windowBits-=16),memLevel<1||memLevel>9||method!==Z_DEFLATED||windowBits<8||windowBits>15||level<0||level>9||strategy<0||strategy>Z_FIXED||8===windowBits&&1!==wrap)return err(strm,Z_STREAM_ERROR);8===windowBits&&(windowBits=9);const s=new DeflateState;return strm.state=s,s.strm=strm,s.status=42,s.wrap=wrap,s.gzhead=null,s.w_bits=windowBits,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=memLevel+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+3-1)/3),s.window=new Uint8Array(2*s.w_size),s.head=new Uint16Array(s.hash_size),s.prev=new Uint16Array(s.w_size),s.lit_bufsize=1<<memLevel+6,s.pending_buf_size=4*s.lit_bufsize,s.pending_buf=new Uint8Array(s.pending_buf_size),s.sym_buf=s.lit_bufsize,s.sym_end=3*(s.lit_bufsize-1),s.level=level,s.strategy=strategy,s.method=method,deflateReset(strm)};module.exports.deflateInit=(strm,level)=>deflateInit2(strm,level,Z_DEFLATED,15,8,Z_DEFAULT_STRATEGY),module.exports.deflateInit2=deflateInit2,module.exports.deflateReset=deflateReset,module.exports.deflateResetKeep=deflateResetKeep,module.exports.deflateSetHeader=(strm,head)=>deflateStateCheck(strm)||2!==strm.state.wrap?Z_STREAM_ERROR:(strm.state.gzhead=head,Z_OK),module.exports.deflate=(strm,flush)=>{if(deflateStateCheck(strm)||flush>Z_BLOCK||flush<0)return strm?err(strm,Z_STREAM_ERROR):Z_STREAM_ERROR;const s=strm.state;if(!strm.output||0!==strm.avail_in&&!strm.input||666===s.status&&flush!==Z_FINISH)return err(strm,0===strm.avail_out?Z_BUF_ERROR:Z_STREAM_ERROR);const old_flush=s.last_flush;if(s.last_flush=flush,0!==s.pending){if(flush_pending(strm),0===strm.avail_out)return s.last_flush=-1,Z_OK}else if(0===strm.avail_in&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH)return err(strm,Z_BUF_ERROR);if(666===s.status&&0!==strm.avail_in)return err(strm,Z_BUF_ERROR);if(42===s.status&&0===s.wrap&&(s.status=113),42===s.status){let header=Z_DEFLATED+(s.w_bits-8<<4)<<8,level_flags=-1;if(level_flags=s.strategy>=Z_HUFFMAN_ONLY||s.level<2?0:s.level<6?1:6===s.level?2:3,header|=level_flags<<6,0!==s.strstart&&(header|=32),header+=31-header%31,putShortMSB(s,header),0!==s.strstart&&(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),strm.adler=1,s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK}if(57===s.status)if(strm.adler=0,put_byte(s,31),put_byte(s,139),put_byte(s,8),s.gzhead)put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),put_byte(s,255&s.gzhead.time),put_byte(s,s.gzhead.time>>8&255),put_byte(s,s.gzhead.time>>16&255),put_byte(s,s.gzhead.time>>24&255),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(put_byte(s,255&s.gzhead.extra.length),put_byte(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69;else if(put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,3),s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK;if(69===s.status){if(s.gzhead.extra){let beg=s.pending,left=(65535&s.gzhead.extra.length)-s.gzindex;for(;s.pending+left>s.pending_buf_size;){let copy=s.pending_buf_size-s.pending;if(s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+copy),s.pending),s.pending=s.pending_buf_size,s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex+=copy,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK;beg=0,left-=copy}let gzhead_extra=new Uint8Array(s.gzhead.extra);s.pending_buf.set(gzhead_extra.subarray(s.gzindex,s.gzindex+left),s.pending),s.pending+=left,s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex=0}s.status=73}if(73===s.status){if(s.gzhead.name){let val,beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK;beg=0}val=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex=0}s.status=91}if(91===s.status){if(s.gzhead.comment){let val,beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK;beg=0}val=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg))}s.status=103}if(103===s.status){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size&&(flush_pending(strm),0!==s.pending))return s.last_flush=-1,Z_OK;put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),strm.adler=0}if(s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK}if(0!==strm.avail_in||0!==s.lookahead||flush!==Z_NO_FLUSH&&666!==s.status){let bstate=0===s.level?deflate_stored(s,flush):s.strategy===Z_HUFFMAN_ONLY?((s,flush)=>{let bflush;for(;;){if(0===s.lookahead&&(fill_window(s),0===s.lookahead)){if(flush===Z_NO_FLUSH)return 1;break}if(s.match_length=0,bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):s.strategy===Z_RLE?((s,flush)=>{let bflush,prev,scan,strend;const _win=s.window;for(;;){if(s.lookahead<=258){if(fill_window(s),s.lookahead<=258&&flush===Z_NO_FLUSH)return 1;if(0===s.lookahead)break}if(s.match_length=0,s.lookahead>=3&&s.strstart>0&&(scan=s.strstart-1,prev=_win[scan],prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan])){strend=s.strstart+258;do{}while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s.match_length=258-(strend-scan),s.match_length>s.lookahead&&(s.match_length=s.lookahead)}if(s.match_length>=3?(bflush=_tr_tally(s,1,s.match_length-3),s.lookahead-=s.match_length,s.strstart+=s.match_length,s.match_length=0):(bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++),bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):configuration_table[s.level].func(s,flush);if(3!==bstate&&4!==bstate||(s.status=666),1===bstate||3===bstate)return 0===strm.avail_out&&(s.last_flush=-1),Z_OK;if(2===bstate&&(flush===Z_PARTIAL_FLUSH?_tr_align(s):flush!==Z_BLOCK&&(_tr_stored_block(s,0,0,!1),flush===Z_FULL_FLUSH&&(zero(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),flush_pending(strm),0===strm.avail_out))return s.last_flush=-1,Z_OK}return flush!==Z_FINISH?Z_OK:s.wrap<=0?Z_STREAM_END:(2===s.wrap?(put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),put_byte(s,strm.adler>>16&255),put_byte(s,strm.adler>>24&255),put_byte(s,255&strm.total_in),put_byte(s,strm.total_in>>8&255),put_byte(s,strm.total_in>>16&255),put_byte(s,strm.total_in>>24&255)):(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),flush_pending(strm),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?Z_OK:Z_STREAM_END)},module.exports.deflateEnd=strm=>{if(deflateStateCheck(strm))return Z_STREAM_ERROR;const status=strm.state.status;return strm.state=null,113===status?err(strm,Z_DATA_ERROR):Z_OK},module.exports.deflateSetDictionary=(strm,dictionary)=>{let dictLength=dictionary.length;if(deflateStateCheck(strm))return Z_STREAM_ERROR;const s=strm.state,wrap=s.wrap;if(2===wrap||1===wrap&&42!==s.status||s.lookahead)return Z_STREAM_ERROR;if(1===wrap&&(strm.adler=adler32(strm.adler,dictionary,dictLength,0)),s.wrap=0,dictLength>=s.w_size){0===wrap&&(zero(s.head),s.strstart=0,s.block_start=0,s.insert=0);let tmpDict=new Uint8Array(s.w_size);tmpDict.set(dictionary.subarray(dictLength-s.w_size,dictLength),0),dictionary=tmpDict,dictLength=s.w_size}const avail=strm.avail_in,next=strm.next_in,input=strm.input;for(strm.avail_in=dictLength,strm.next_in=0,strm.input=dictionary,fill_window(s);s.lookahead>=3;){let str=s.strstart,n=s.lookahead-2;do{s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++}while(--n);s.strstart=str,s.lookahead=2,fill_window(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,strm.next_in=next,strm.input=input,strm.avail_in=avail,s.wrap=wrap,Z_OK},module.exports.deflateInfo="pako deflate (from Nodeca project)"},53764:(__unused_webpack_module,exports)=>{"use strict";function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(b,...lengths){if(!((a=b)instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name))throw new Error("Uint8Array expected");var a;if(lengths.length>0&&!lengths.includes(b.length))throw new Error("Uint8Array expected of length "+lengths+", got length="+b.length)}function ahash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber(h.outputLen),anumber(h.blockLen)}function aexists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function aoutput(out,instance){abytes(out);const min=instance.outputLen;if(out.length<min)throw new Error("digestInto() expects output buffer of length at least "+min)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.anumber=anumber,exports.number=anumber,exports.abytes=abytes,exports.bytes=abytes,exports.ahash=ahash,exports.aexists=aexists,exports.aoutput=aoutput;const assert={number:anumber,bytes:abytes,hash:ahash,exists:aexists,output:aoutput};exports.default=assert},53860:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},54557:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},54691:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},55510:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.crypto=void 0,exports.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},56409:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ETransactionVersion3=exports.ETransactionVersion2=exports.ETransactionVersion=exports.EDAMode=exports.EDataAvailabilityMode=exports.EBlockTag=exports.ETransactionExecutionStatus=exports.ETransactionFinalityStatus=exports.ETransactionStatus=exports.ESimulationFlag=exports.ETransactionType=exports.CALL_TYPE=exports.L1_DA_MODE=exports.PRICE_UNIT_FRI=exports.PRICE_UNIT_WEI=exports.STATE_MUTABILITY_EXTERNAL=exports.STATE_MUTABILITY_VIEW=exports.ABI_TYPE_ENUM=exports.ABI_TYPE_L1_HANDLER=exports.ABI_TYPE_CONSTRUCTOR=exports.ABI_TYPE_FUNCTION=exports.EVENT_ABI_TYPE=exports.STRUCT_ABI_TYPE=exports.TXN_TYPE_L1_HANDLER=exports.TXN_TYPE_INVOKE=exports.TXN_TYPE_DEPLOY_ACCOUNT=exports.TXN_TYPE_DEPLOY=exports.TXN_TYPE_DECLARE=exports.STATUS_RECEIVED=exports.STATUS_REJECTED=exports.STATUS_PENDING=exports.STATUS_REVERTED=exports.STATUS_SUCCEEDED=exports.STATUS_ACCEPTED_ON_L1=exports.STATUS_ACCEPTED_ON_L2=void 0,exports.STATUS_ACCEPTED_ON_L2="ACCEPTED_ON_L2",exports.STATUS_ACCEPTED_ON_L1="ACCEPTED_ON_L1",exports.STATUS_SUCCEEDED="SUCCEEDED",exports.STATUS_REVERTED="REVERTED",exports.STATUS_PENDING="PENDING",exports.STATUS_REJECTED="REJECTED",exports.STATUS_RECEIVED="RECEIVED",exports.TXN_TYPE_DECLARE="DECLARE",exports.TXN_TYPE_DEPLOY="DEPLOY",exports.TXN_TYPE_DEPLOY_ACCOUNT="DEPLOY_ACCOUNT",exports.TXN_TYPE_INVOKE="INVOKE",exports.TXN_TYPE_L1_HANDLER="L1_HANDLER",exports.STRUCT_ABI_TYPE="struct",exports.EVENT_ABI_TYPE="event",exports.ABI_TYPE_FUNCTION="function",exports.ABI_TYPE_CONSTRUCTOR="constructor",exports.ABI_TYPE_L1_HANDLER="l1_handler",exports.ABI_TYPE_ENUM="enum",exports.STATE_MUTABILITY_VIEW="view",exports.STATE_MUTABILITY_EXTERNAL="external",exports.PRICE_UNIT_WEI="WEI",exports.PRICE_UNIT_FRI="FRI",exports.L1_DA_MODE={BLOB:"BLOB",CALLDATA:"CALLDATA"},exports.CALL_TYPE={DELEGATE:"DELEGATE",LIBRARY_CALL:"LIBRARY_CALL",CALL:"CALL"},exports.ETransactionType={DECLARE:exports.TXN_TYPE_DECLARE,DEPLOY:exports.TXN_TYPE_DEPLOY,DEPLOY_ACCOUNT:exports.TXN_TYPE_DEPLOY_ACCOUNT,INVOKE:exports.TXN_TYPE_INVOKE,L1_HANDLER:exports.TXN_TYPE_L1_HANDLER},exports.ESimulationFlag={SKIP_VALIDATE:"SKIP_VALIDATE",SKIP_FEE_CHARGE:"SKIP_FEE_CHARGE"},exports.ETransactionStatus={RECEIVED:exports.STATUS_RECEIVED,REJECTED:exports.STATUS_REJECTED,ACCEPTED_ON_L2:exports.STATUS_ACCEPTED_ON_L2,ACCEPTED_ON_L1:exports.STATUS_ACCEPTED_ON_L1},exports.ETransactionFinalityStatus={ACCEPTED_ON_L2:exports.STATUS_ACCEPTED_ON_L2,ACCEPTED_ON_L1:exports.STATUS_ACCEPTED_ON_L1},exports.ETransactionExecutionStatus={SUCCEEDED:exports.STATUS_SUCCEEDED,REVERTED:exports.STATUS_REVERTED},exports.EBlockTag={LATEST:"latest",PENDING:"pending"},exports.EDataAvailabilityMode={L1:"L1",L2:"L2"},exports.EDAMode={L1:0,L2:1},exports.ETransactionVersion={V0:"0x0",V1:"0x1",V2:"0x2",V3:"0x3",F0:"0x100000000000000000000000000000000",F1:"0x100000000000000000000000000000001",F2:"0x100000000000000000000000000000002",F3:"0x100000000000000000000000000000003"},exports.ETransactionVersion2={V0:exports.ETransactionVersion.V0,V1:exports.ETransactionVersion.V1,V2:exports.ETransactionVersion.V2,F0:exports.ETransactionVersion.F0,F1:exports.ETransactionVersion.F1,F2:exports.ETransactionVersion.F2},exports.ETransactionVersion3={V3:exports.ETransactionVersion.V3,F3:exports.ETransactionVersion.F3}},56759:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const zlib_inflate=__webpack_require__(13307),utils=__webpack_require__(58385),strings=__webpack_require__(24),msg=__webpack_require__(81494),ZStream=__webpack_require__(4862),GZheader=__webpack_require__(69066),toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=__webpack_require__(39829);function Inflate(options){this.options=utils.assign({chunkSize:65536,windowBits:15,to:""},options||{});const opt=this.options;opt.raw&&opt.windowBits>=0&&opt.windowBits<16&&(opt.windowBits=-opt.windowBits,0===opt.windowBits&&(opt.windowBits=-15)),!(opt.windowBits>=0&&opt.windowBits<16)||options&&options.windowBits||(opt.windowBits+=32),opt.windowBits>15&&opt.windowBits<48&&(15&opt.windowBits||(opt.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ZStream,this.strm.avail_out=0;let status=zlib_inflate.inflateInit2(this.strm,opt.windowBits);if(status!==Z_OK)throw new Error(msg[status]);if(this.header=new GZheader,zlib_inflate.inflateGetHeader(this.strm,this.header),opt.dictionary&&("string"==typeof opt.dictionary?opt.dictionary=strings.string2buf(opt.dictionary):"[object ArrayBuffer]"===toString.call(opt.dictionary)&&(opt.dictionary=new Uint8Array(opt.dictionary)),opt.raw&&(status=zlib_inflate.inflateSetDictionary(this.strm,opt.dictionary),status!==Z_OK)))throw new Error(msg[status])}function inflate(input,options){const inflator=new Inflate(options);if(inflator.push(input),inflator.err)throw inflator.msg||msg[inflator.err];return inflator.result}Inflate.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize,dictionary=this.options.dictionary;let status,_flush_mode,last_avail_out;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH:Z_NO_FLUSH,"[object ArrayBuffer]"===toString.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;){for(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),status=zlib_inflate.inflate(strm,_flush_mode),status===Z_NEED_DICT&&dictionary&&(status=zlib_inflate.inflateSetDictionary(strm,dictionary),status===Z_OK?status=zlib_inflate.inflate(strm,_flush_mode):status===Z_DATA_ERROR&&(status=Z_NEED_DICT));strm.avail_in>0&&status===Z_STREAM_END&&strm.state.wrap>0&&0!==data[strm.next_in];)zlib_inflate.inflateReset(strm),status=zlib_inflate.inflate(strm,_flush_mode);switch(status){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(status),this.ended=!0,!1}if(last_avail_out=strm.avail_out,strm.next_out&&(0===strm.avail_out||status===Z_STREAM_END))if("string"===this.options.to){let next_out_utf8=strings.utf8border(strm.output,strm.next_out),tail=strm.next_out-next_out_utf8,utf8str=strings.buf2string(strm.output,next_out_utf8);strm.next_out=tail,strm.avail_out=chunkSize-tail,tail&&strm.output.set(strm.output.subarray(next_out_utf8,next_out_utf8+tail),0),this.onData(utf8str)}else this.onData(strm.output.length===strm.next_out?strm.output:strm.output.subarray(0,strm.next_out));if(status!==Z_OK||0!==last_avail_out){if(status===Z_STREAM_END)return status=zlib_inflate.inflateEnd(this.strm),this.onEnd(status),this.ended=!0,!0;if(0===strm.avail_in)break}}return!0},Inflate.prototype.onData=function(chunk){this.chunks.push(chunk)},Inflate.prototype.onEnd=function(status){status===Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=utils.flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg},module.exports.Inflate=Inflate,module.exports.inflate=inflate,module.exports.inflateRaw=function(input,options){return(options=options||{}).raw=!0,inflate(input,options)},module.exports.ungzip=inflate,module.exports.constants=__webpack_require__(39829)},56846:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},58118:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},58385:module=>{"use strict";const _has=(obj,key)=>Object.prototype.hasOwnProperty.call(obj,key);module.exports.assign=function(obj){const sources=Array.prototype.slice.call(arguments,1);for(;sources.length;){const source=sources.shift();if(source){if("object"!=typeof source)throw new TypeError(source+"must be non-object");for(const p in source)_has(source,p)&&(obj[p]=source[p])}}return obj},module.exports.flattenChunks=chunks=>{let len=0;for(let i=0,l=chunks.length;i<l;i++)len+=chunks[i].length;const result=new Uint8Array(len);for(let i=0,pos=0,l=chunks.length;i<l;i++){let chunk=chunks[i];result.set(chunk,pos),pos+=chunk.length}return result}},58768:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},59760:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const{Deflate,deflate,deflateRaw,gzip}=__webpack_require__(64907),{Inflate,inflate,inflateRaw,ungzip}=__webpack_require__(56759),constants=__webpack_require__(39829);module.exports.Deflate=Deflate,module.exports.deflate=deflate,module.exports.deflateRaw=deflateRaw,module.exports.gzip=gzip,module.exports.Inflate=Inflate,module.exports.inflate=inflate,module.exports.inflateRaw=inflateRaw,module.exports.ungzip=ungzip,module.exports.constants=constants},60055:module=>{var id=0;module.exports=function(e){return"__private_"+id+++"_"+e},module.exports.__esModule=!0,module.exports.default=module.exports},61161:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cryptoClients=exports.SECP256K1Client=void 0;const secp256k1_1=__webpack_require__(92485);Object.defineProperty(exports,"SECP256K1Client",{enumerable:!0,get:function(){return secp256k1_1.SECP256K1Client}});const cryptoClients={ES256K:secp256k1_1.SECP256K1Client};exports.cryptoClients=cryptoClients},61529:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.add5L=exports.add5H=exports.add4H=exports.add4L=exports.add3H=exports.add3L=exports.rotlBL=exports.rotlBH=exports.rotlSL=exports.rotlSH=exports.rotr32L=exports.rotr32H=exports.rotrBL=exports.rotrBH=exports.rotrSL=exports.rotrSH=exports.shrSL=exports.shrSH=exports.toBig=void 0,exports.fromBig=fromBig,exports.split=split,exports.add=add;const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const toBig=(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0);exports.toBig=toBig;const shrSH=(h,_l,s)=>h>>>s;exports.shrSH=shrSH;const shrSL=(h,l,s)=>h<<32-s|l>>>s;exports.shrSL=shrSL;const rotrSH=(h,l,s)=>h>>>s|l<<32-s;exports.rotrSH=rotrSH;const rotrSL=(h,l,s)=>h<<32-s|l>>>s;exports.rotrSL=rotrSL;const rotrBH=(h,l,s)=>h<<64-s|l>>>s-32;exports.rotrBH=rotrBH;const rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;exports.rotrBL=rotrBL;const rotr32H=(_h,l)=>l;exports.rotr32H=rotr32H;const rotr32L=(h,_l)=>h;exports.rotr32L=rotr32L;const rotlSH=(h,l,s)=>h<<s|l>>>32-s;exports.rotlSH=rotlSH;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;exports.rotlSL=rotlSL;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;exports.rotlBH=rotlBH;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}}exports.rotlBL=rotlBL;const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0);exports.add3L=add3L;const add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0;exports.add3H=add3H;const add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0);exports.add4L=add4L;const add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0;exports.add4H=add4H;const add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0);exports.add5L=add5L;const add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0;exports.add5H=add5H;const u64={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L};exports.default=u64},61667:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hash=exports.nextTick=exports.byteSwapIfBE=exports.byteSwap=exports.isLE=exports.rotl=exports.rotr=exports.createView=exports.u32=exports.u8=void 0,exports.isBytes=function(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name},exports.byteSwap32=function(arr){for(let i=0;i<arr.length;i++)arr[i]=(0,exports.byteSwap)(arr[i])},exports.bytesToHex=function(bytes){(0,_assert_js_1.abytes)(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex},exports.hexToBytes=function(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("padded hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=asciiToBase16(hex.charCodeAt(hi)),n2=asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array},exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;diff>=0&&diff<tick||(await(0,exports.nextTick)(),ts+=diff)}},exports.utf8ToBytes=utf8ToBytes,exports.toBytes=toBytes,exports.concatBytes=function(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert_js_1.abytes)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res},exports.checkOpts=function(defaults,opts){if(void 0!==opts&&"[object Object]"!=={}.toString.call(opts))throw new Error("Options should be object or undefined");return Object.assign(defaults,opts)},exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC},exports.wrapConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.randomBytes)return crypto_1.crypto.randomBytes(bytesLength);throw new Error("crypto.getRandomValues must be defined")};const crypto_1=__webpack_require__(46501),_assert_js_1=__webpack_require__(85409);exports.u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);exports.u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));exports.createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);exports.rotr=(word,shift)=>word<<32-shift|word>>>shift;exports.rotl=(word,shift)=>word<<shift|word>>>32-shift>>>0,exports.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];exports.byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,exports.byteSwapIfBE=exports.isLE?n=>n:n=>(0,exports.byteSwap)(n);const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(ch){return ch>=asciis._0&&ch<=asciis._9?ch-asciis._0:ch>=asciis.A&&ch<=asciis.F?ch-(asciis.A-10):ch>=asciis.a&&ch<=asciis.f?ch-(asciis.a-10):void 0}function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){return"string"==typeof data&&(data=utf8ToBytes(data)),(0,_assert_js_1.abytes)(data),data}exports.nextTick=async()=>{};exports.Hash=class{clone(){return this._cloneInto()}}},62422:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wNAF=function(c,bits){return{constTimeNegate,hasPrecomputes:elm=>1!==getW(elm),unsafeLadder(elm,n,p=c.ZERO){let d=elm;for(;n>_0n;)n&_1n&&(p=p.add(d)),d=d.double(),n>>=_1n;return p},precomputeWindow(elm,W){const{windows,windowSize}=calcWOpts(W,bits),points=[];let p=elm,base=p;for(let window=0;window<windows;window++){base=p,points.push(base);for(let i=1;i<windowSize;i++)base=base.add(p),points.push(base);p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=calcWOpts(W,bits);let p=c.ZERO,f=c.BASE;const mask=BigInt(2**W-1),maxNumber=2**W,shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy,wbits>windowSize&&(wbits-=maxNumber,n+=_1n);const offset1=offset,offset2=offset+Math.abs(wbits)-1,cond1=window%2!=0,cond2=wbits<0;0===wbits?f=f.add(constTimeNegate(cond1,precomputes[offset1])):p=p.add(constTimeNegate(cond2,precomputes[offset2]))}return{p,f}},wNAFUnsafe(W,precomputes,n,acc=c.ZERO){const{windows,windowSize}=calcWOpts(W,bits),mask=BigInt(2**W-1),maxNumber=2**W,shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;if(n===_0n)break;let wbits=Number(n&mask);if(n>>=shiftBy,wbits>windowSize&&(wbits-=maxNumber,n+=_1n),0===wbits)continue;let curr=precomputes[offset+Math.abs(wbits)-1];wbits<0&&(curr=curr.negate()),acc=acc.add(curr)}return acc},getPrecomputes(W,P,transform){let comp=pointPrecomputes.get(P);return comp||(comp=this.precomputeWindow(P,W),1!==W&&pointPrecomputes.set(P,transform(comp))),comp},wNAFCached(P,n,transform){const W=getW(P);return this.wNAF(W,this.getPrecomputes(W,P,transform),n)},wNAFCachedUnsafe(P,n,transform,prev){const W=getW(P);return 1===W?this.unsafeLadder(P,n,prev):this.wNAFUnsafe(W,this.getPrecomputes(W,P,transform),n,prev)},setWindowSize(P,W){validateW(W,bits),pointWindowSizes.set(P,W),pointPrecomputes.delete(P)}}},exports.pippenger=function(c,fieldN,points,scalars){if(validateMSMPoints(points,c),validateMSMScalars(scalars,fieldN),points.length!==scalars.length)throw new Error("arrays of points and scalars must have equal length");const zero=c.ZERO,wbits=(0,utils_js_1.bitLen)(BigInt(points.length)),windowSize=wbits>12?wbits-3:wbits>4?wbits-2:wbits?2:1,MASK=(1<<windowSize)-1,buckets=new Array(MASK+1).fill(zero),lastBits=Math.floor((fieldN.BITS-1)/windowSize)*windowSize;let sum=zero;for(let i=lastBits;i>=0;i-=windowSize){buckets.fill(zero);for(let j=0;j<scalars.length;j++){const scalar=scalars[j],wbits=Number(scalar>>BigInt(i)&BigInt(MASK));buckets[wbits]=buckets[wbits].add(points[j])}let resI=zero;for(let j=buckets.length-1,sumI=zero;j>0;j--)sumI=sumI.add(buckets[j]),resI=resI.add(sumI);if(sum=sum.add(resI),0!==i)for(let j=0;j<windowSize;j++)sum=sum.double()}return sum},exports.precomputeMSMUnsafe=function(c,fieldN,points,windowSize){validateW(windowSize,fieldN.BITS),validateMSMPoints(points,c);const zero=c.ZERO,tableSize=2**windowSize-1,chunks=Math.ceil(fieldN.BITS/windowSize),MASK=BigInt((1<<windowSize)-1),tables=points.map((p=>{const res=[];for(let i=0,acc=p;i<tableSize;i++)res.push(acc),acc=acc.add(p);return res}));return scalars=>{if(validateMSMScalars(scalars,fieldN),scalars.length>points.length)throw new Error("array of scalars must be smaller than array of points");let res=zero;for(let i=0;i<chunks;i++){if(res!==zero)for(let j=0;j<windowSize;j++)res=res.double();const shiftBy=BigInt(chunks*windowSize-(i+1)*windowSize);for(let j=0;j<scalars.length;j++){const n=scalars[j],curr=Number(n>>shiftBy&MASK);curr&&(res=res.add(tables[j][curr-1]))}}return res}},exports.validateBasic=function(curve){return(0,modular_js_1.validateField)(curve.Fp),(0,utils_js_1.validateObject)(curve,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,modular_js_1.nLength)(curve.n,curve.nBitLength),...curve,p:curve.Fp.ORDER})};const modular_js_1=__webpack_require__(24967),utils_js_1=__webpack_require__(91484),_0n=BigInt(0),_1n=BigInt(1);function constTimeNegate(condition,item){const neg=item.negate();return condition?neg:item}function validateW(W,bits){if(!Number.isSafeInteger(W)||W<=0||W>bits)throw new Error("invalid window size, expected [1.."+bits+"], got W="+W)}function calcWOpts(W,bits){validateW(W,bits);return{windows:Math.ceil(bits/W)+1,windowSize:2**(W-1)}}function validateMSMPoints(points,c){if(!Array.isArray(points))throw new Error("array expected");points.forEach(((p,i)=>{if(!(p instanceof c))throw new Error("invalid point at index "+i)}))}function validateMSMScalars(scalars,field){if(!Array.isArray(scalars))throw new Error("array of scalars expected");scalars.forEach(((s,i)=>{if(!field.isValid(s))throw new Error("invalid scalar at index "+i)}))}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(P){return pointWindowSizes.get(P)||1}},62560:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},62708:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},63072:module=>{function _getPrototypeOf(t){return module.exports=_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},module.exports.__esModule=!0,module.exports.default=module.exports,_getPrototypeOf(t)}module.exports=_getPrototypeOf,module.exports.__esModule=!0,module.exports.default=module.exports},63139:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sha224=exports.sha256=exports.SHA256=void 0;const _md_js_1=__webpack_require__(68262),utils_js_1=__webpack_require__(37995),SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends _md_js_1.HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=(0,utils_js_1.rotr)(W15,7)^(0,utils_js_1.rotr)(W15,18)^W15>>>3,s1=(0,utils_js_1.rotr)(W2,17)^(0,utils_js_1.rotr)(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+((0,utils_js_1.rotr)(E,6)^(0,utils_js_1.rotr)(E,11)^(0,utils_js_1.rotr)(E,25))+(0,_md_js_1.Chi)(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=((0,utils_js_1.rotr)(A,2)^(0,utils_js_1.rotr)(A,13)^(0,utils_js_1.rotr)(A,22))+(0,_md_js_1.Maj)(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}exports.SHA256=SHA256;class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}exports.sha256=(0,utils_js_1.wrapConstructor)((()=>new SHA256)),exports.sha224=(0,utils_js_1.wrapConstructor)((()=>new SHA224))},63527:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},64907:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const zlib_deflate=__webpack_require__(53751),utils=__webpack_require__(58385),strings=__webpack_require__(24),msg=__webpack_require__(81494),ZStream=__webpack_require__(4862),toString=Object.prototype.toString,{Z_NO_FLUSH,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED}=__webpack_require__(39829);function Deflate(options){this.options=utils.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},options||{});let opt=this.options;opt.raw&&opt.windowBits>0?opt.windowBits=-opt.windowBits:opt.gzip&&opt.windowBits>0&&opt.windowBits<16&&(opt.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ZStream,this.strm.avail_out=0;let status=zlib_deflate.deflateInit2(this.strm,opt.level,opt.method,opt.windowBits,opt.memLevel,opt.strategy);if(status!==Z_OK)throw new Error(msg[status]);if(opt.header&&zlib_deflate.deflateSetHeader(this.strm,opt.header),opt.dictionary){let dict;if(dict="string"==typeof opt.dictionary?strings.string2buf(opt.dictionary):"[object ArrayBuffer]"===toString.call(opt.dictionary)?new Uint8Array(opt.dictionary):opt.dictionary,status=zlib_deflate.deflateSetDictionary(this.strm,dict),status!==Z_OK)throw new Error(msg[status]);this._dict_set=!0}}function deflate(input,options){const deflator=new Deflate(options);if(deflator.push(input,!0),deflator.err)throw deflator.msg||msg[deflator.err];return deflator.result}Deflate.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize;let status,_flush_mode;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH:Z_NO_FLUSH,"string"==typeof data?strm.input=strings.string2buf(data):"[object ArrayBuffer]"===toString.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;)if(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),(_flush_mode===Z_SYNC_FLUSH||_flush_mode===Z_FULL_FLUSH)&&strm.avail_out<=6)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else{if(status=zlib_deflate.deflate(strm,_flush_mode),status===Z_STREAM_END)return strm.next_out>0&&this.onData(strm.output.subarray(0,strm.next_out)),status=zlib_deflate.deflateEnd(this.strm),this.onEnd(status),this.ended=!0,status===Z_OK;if(0!==strm.avail_out){if(_flush_mode>0&&strm.next_out>0)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else if(0===strm.avail_in)break}else this.onData(strm.output)}return!0},Deflate.prototype.onData=function(chunk){this.chunks.push(chunk)},Deflate.prototype.onEnd=function(status){status===Z_OK&&(this.result=utils.flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg},module.exports.Deflate=Deflate,module.exports.deflate=deflate,module.exports.deflateRaw=function(input,options){return(options=options||{}).raw=!0,deflate(input,options)},module.exports.gzip=function(input,options){return(options=options||{}).gzip=!0,deflate(input,options)},module.exports.constants=__webpack_require__(39829)},65311:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HashMD=exports.Maj=exports.Chi=void 0;const _assert_js_1=__webpack_require__(53764),utils_js_1=__webpack_require__(81130);exports.Chi=(a,b,c)=>a&b^~a&c;exports.Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends utils_js_1.Hash{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=(0,utils_js_1.createView)(this.buffer)}update(data){(0,_assert_js_1.aexists)(this);const{view,buffer,blockLen}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=(0,utils_js_1.createView)(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.aoutput)(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=(0,utils_js_1.createView)(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}exports.HashMD=HashMD},65781:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},65930:module=>{"use strict";const lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);module.exports=(type,lens,lens_index,codes,table,table_index,work,opts)=>{const bits=opts.bits;let incr,fill,low,mask,next,match,len=0,sym=0,min=0,max=0,root=0,curr=0,drop=0,left=0,used=0,huff=0,base=null;const count=new Uint16Array(16),offs=new Uint16Array(16);let here_bits,here_op,here_val,extra=null;for(len=0;len<=15;len++)count[len]=0;for(sym=0;sym<codes;sym++)count[lens[lens_index+sym]]++;for(root=bits,max=15;max>=1&&0===count[max];max--);if(root>max&&(root=max),0===max)return table[table_index++]=20971520,table[table_index++]=20971520,opts.bits=1,0;for(min=1;min<max&&0===count[min];min++);for(root<min&&(root=min),left=1,len=1;len<=15;len++)if(left<<=1,left-=count[len],left<0)return-1;if(left>0&&(0===type||1!==max))return-1;for(offs[1]=0,len=1;len<15;len++)offs[len+1]=offs[len]+count[len];for(sym=0;sym<codes;sym++)0!==lens[lens_index+sym]&&(work[offs[lens[lens_index+sym]]++]=sym);if(0===type?(base=extra=work,match=20):1===type?(base=lbase,extra=lext,match=257):(base=dbase,extra=dext,match=0),huff=0,sym=0,len=min,next=table_index,curr=root,drop=0,low=-1,used=1<<root,mask=used-1,1===type&&used>852||2===type&&used>592)return 1;for(;;){here_bits=len-drop,work[sym]+1<match?(here_op=0,here_val=work[sym]):work[sym]>=match?(here_op=extra[work[sym]-match],here_val=base[work[sym]-match]):(here_op=96,here_val=0),incr=1<<len-drop,fill=1<<curr,min=fill;do{fill-=incr,table[next+(huff>>drop)+fill]=here_bits<<24|here_op<<16|here_val}while(0!==fill);for(incr=1<<len-1;huff&incr;)incr>>=1;if(0!==incr?(huff&=incr-1,huff+=incr):huff=0,sym++,0==--count[len]){if(len===max)break;len=lens[lens_index+work[sym]]}if(len>root&&(huff&mask)!==low){for(0===drop&&(drop=root),next+=min,curr=len-drop,left=1<<curr;curr+drop<max&&(left-=count[curr+drop],!(left<=0));)curr++,left<<=1;if(used+=1<<curr,1===type&&used>852||2===type&&used>592)return 1;low=huff&mask,table[low]=root<<24|curr<<16|next-table_index}}return 0!==huff&&(table[next+huff]=len-drop<<24|64<<16),opts.bits=root,0}},66534:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},67526:(__unused_webpack_module,exports)=>{"use strict";exports.byteLength=function(b64){var lens=getLens(b64),validLen=lens[0],placeHoldersLen=lens[1];return 3*(validLen+placeHoldersLen)/4-placeHoldersLen},exports.toByteArray=function(b64){var tmp,i,lens=getLens(b64),validLen=lens[0],placeHoldersLen=lens[1],arr=new Arr(function(b64,validLen,placeHoldersLen){return 3*(validLen+placeHoldersLen)/4-placeHoldersLen}(0,validLen,placeHoldersLen)),curByte=0,len=placeHoldersLen>0?validLen-4:validLen;for(i=0;i<len;i+=4)tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)],arr[curByte++]=tmp>>16&255,arr[curByte++]=tmp>>8&255,arr[curByte++]=255&tmp;2===placeHoldersLen&&(tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4,arr[curByte++]=255&tmp);1===placeHoldersLen&&(tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2,arr[curByte++]=tmp>>8&255,arr[curByte++]=255&tmp);return arr},exports.fromByteArray=function(uint8){for(var tmp,len=uint8.length,extraBytes=len%3,parts=[],i=0,len2=len-extraBytes;i<len2;i+=16383)parts.push(encodeChunk(uint8,i,i+16383>len2?len2:i+16383));1===extraBytes?(tmp=uint8[len-1],parts.push(lookup[tmp>>2]+lookup[tmp<<4&63]+"==")):2===extraBytes&&(tmp=(uint8[len-2]<<8)+uint8[len-1],parts.push(lookup[tmp>>10]+lookup[tmp>>4&63]+lookup[tmp<<2&63]+"="));return parts.join("")};for(var lookup=[],revLookup=[],Arr="undefined"!=typeof Uint8Array?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0;i<64;++i)lookup[i]=code[i],revLookup[code.charCodeAt(i)]=i;function getLens(b64){var len=b64.length;if(len%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var validLen=b64.indexOf("=");return-1===validLen&&(validLen=len),[validLen,validLen===len?0:4-validLen%4]}function encodeChunk(uint8,start,end){for(var tmp,num,output=[],i=start;i<end;i+=3)tmp=(uint8[i]<<16&16711680)+(uint8[i+1]<<8&65280)+(255&uint8[i+2]),output.push(lookup[(num=tmp)>>18&63]+lookup[num>>12&63]+lookup[num>>6&63]+lookup[63&num]);return output.join("")}revLookup["-".charCodeAt(0)]=62,revLookup["_".charCodeAt(0)]=63},67631:function(__unused_webpack_module,exports){!function(t){"use strict";function e(t){return r.test(t)}const r=/^-?[0-9]+$/;function n(t){return o.test(t)}const o=/^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;function i(t,r){const n=parseFloat(t),o=String(n),i=a(t),c=a(o);if(i===c)return!0;if(!0===r?.approx){const r=14;if(!e(t)&&c.length>=r&&i.startsWith(c.substring(0,r)))return!0}return!1}let c=function(t){return t.underflow="underflow",t.overflow="overflow",t.truncate_integer="truncate_integer",t.truncate_float="truncate_float",t}({});function u(t){if(i(t,{approx:!1}))return;if(e(t))return c.truncate_integer;const r=parseFloat(t);return isFinite(r)?0===r?c.underflow:c.truncate_float:c.overflow}function a(t){return t.replace(f,"").replace(l,"").replace(d,"").replace(s,"")}const f=/[eE][+-]?\d+$/,s=/^-?(0*)?/,l=/\./,d=/0+$/;class h{isLosslessNumber=!0;constructor(t){if(!n(t))throw new Error('Invalid number (value: "'+t+'")');this.value=t}valueOf(){const t=u(this.value);if(void 0===t||t===c.truncate_float)return parseFloat(this.value);if(e(this.value))return BigInt(this.value);throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${t} and become ${parseFloat(this.value)}`)}toString(){return this.value}}function p(t){return t&&"object"==typeof t&&!0===t.isLosslessNumber||!1}function y(t){return new h(t)}function w(t,e,r,n){return Array.isArray(r)?n.call(t,e,function(t,e){for(let r=0;r<t.length;r++)t[r]=w(t,r+"",t[r],e);return t}(r,n)):r&&"object"==typeof r&&!p(r)?n.call(t,e,function(t,e){return Object.keys(t).forEach((r=>{const n=w(t,r,t[r],e);void 0!==n?t[r]=n:delete t[r]})),t}(r,n)):n.call(t,e,r)}function b(t){return t>=J&&t<=B||t>=Q&&t<=Z||t>=U&&t<=q}function g(t){return t>=J&&t<=B}function v(t,e){return t===e||(Array.isArray(t)&&Array.isArray(e)?t.length===e.length&&t.every(((t,r)=>v(t,e[r]))):!(!A(t)||!A(e))&&[...new Set([...Object.keys(t),...Object.keys(e)])].every((r=>v(t[r],e[r]))))}function A(t){return"object"==typeof t&&null!==t}const m={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},C=92,$=123,S=125,x=91,E=93,N=32,O=10,I=9,j=13,k=34,_=43,F=45,J=48,L=49,B=57,D=44,T=46,R=58,Q=65,U=97,P=69,W=101,Z=70,q=102,z=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;t.LosslessNumber=h,t.UnsafeNumberReason=c,t.config=function(t){throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.")},t.getUnsafeNumberReason=u,t.isInteger=e,t.isLosslessNumber=p,t.isNumber=n,t.isSafeNumber=i,t.parse=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:y,n=0;const o=u();return function(t){if(void 0===t)throw new SyntaxError(`JSON value expected ${H()}`)}(o),function(){if(n<t.length)throw new SyntaxError(`Expected end of input ${H()}`)}(),e?function(t,e){return w({"":t},"",t,e)}(o,e):o;function i(){if(t.charCodeAt(n)===$){n++,f();const e={};let r=!0;for(;n<t.length&&t.charCodeAt(n)!==S;){r?r=!1:(l(),f());const t=n,o=s();if(void 0===o)return void A();f(),d();const i=u();if(void 0===i)return void q();Object.prototype.hasOwnProperty.call(e,o)&&!v(i,e[o])&&Q(o,t+1),e[o]=i}return t.charCodeAt(n)!==S&&function(){throw new SyntaxError(`Quoted object key or end of object '}' expected ${H()}`)}(),n++,e}}function c(){if(t.charCodeAt(n)===x){n++,f();const e=[];let r=!0;for(;n<t.length&&t.charCodeAt(n)!==E;){r?r=!1:l();const t=u();h(t),e.push(t)}return t.charCodeAt(n)!==E&&function(){throw new SyntaxError(`Array item or end of array ']' expected ${H()}`)}(),n++,e}}function u(){f();const e=s()??function(){const e=n;if(t.charCodeAt(n)===F&&(n++,p(e)),t.charCodeAt(n)===J)n++;else if((o=t.charCodeAt(n))>=L&&o<=B)for(n++;g(t.charCodeAt(n));)n++;var o;if(t.charCodeAt(n)===T)for(n++,p(e);g(t.charCodeAt(n));)n++;if(t.charCodeAt(n)===W||t.charCodeAt(n)===P)for(n++,t.charCodeAt(n)!==F&&t.charCodeAt(n)!==_||n++,p(e);g(t.charCodeAt(n));)n++;if(n>e)return r(t.slice(e,n))}()??i()??c()??a("true",!0)??a("false",!1)??a("null",null);return f(),e}function a(e,r){if(t.slice(n,n+e.length)===e)return n+=e.length,r}function f(){for(;(e=t.charCodeAt(n))===N||e===O||e===I||e===j;)n++;var e}function s(){if(t.charCodeAt(n)===k){n++;let r="";for(;n<t.length&&t.charCodeAt(n)!==k;){if(t.charCodeAt(n)===C){const e=t[n+1],o=m[e];void 0!==o?(r+=o,n++):"u"===e?b(t.charCodeAt(n+2))&&b(t.charCodeAt(n+3))&&b(t.charCodeAt(n+4))&&b(t.charCodeAt(n+5))?(r+=String.fromCharCode(parseInt(t.slice(n+2,n+6),16)),n+=5):z(n):Z(n)}else(e=t.charCodeAt(n))>=32&&e<=1114111?r+=t[n]:U(t[n]);n++}return function(){if(t.charCodeAt(n)!==k)throw new SyntaxError(`End of string '"' expected ${H()}`)}(),n++,r}var e}function l(){if(t.charCodeAt(n)!==D)throw new SyntaxError(`Comma ',' expected after value ${H()}`);n++}function d(){if(t.charCodeAt(n)!==R)throw new SyntaxError(`Colon ':' expected after property name ${H()}`);n++}function h(t){if(void 0===t)throw new SyntaxError(`Array item expected ${H()}`)}function p(e){if(!g(t.charCodeAt(n))){const r=t.slice(e,n);throw new SyntaxError(`Invalid number '${r}', expecting a digit ${H()}`)}}function A(){throw new SyntaxError(`Quoted object key expected ${H()}`)}function Q(t,e){throw new SyntaxError(`Duplicate key '${t}' encountered at position ${e}`)}function U(t){throw new SyntaxError(`Invalid character '${t}' ${G()}`)}function Z(e){const r=t.slice(e,e+2);throw new SyntaxError(`Invalid escape character '${r}' ${G()}`)}function q(){throw new SyntaxError(`Object value expected after ':' ${G()}`)}function z(e){const r=t.slice(e,e+6);throw new SyntaxError(`Invalid unicode character '${r}' ${G()}`)}function G(){return`at position ${n}`}function H(){return(n<t.length?`but got '${t[n]}'`:"but reached end of input")+" "+G()}},t.parseLosslessNumber=y,t.parseNumberAndBigInt=function(t){return e(t)?BigInt(t):parseFloat(t)},t.reviveDate=function(t,e){return"string"==typeof e&&z.test(e)?new Date(e):e},t.stringify=function t(e,r,o,i){const c=function(t){return"number"==typeof t?" ".repeat(t):"string"==typeof t&&""!==t?t:void 0}(o);return u("function"==typeof r?r.call({"":e},"",e):e,"");function u(e,a){if(Array.isArray(i)){const t=i.find((t=>t.test(e)));if(t){const r=t.stringify(e);if("string"!=typeof r||!n(r))throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${r})`);return r}}return"boolean"==typeof e||"number"==typeof e||"string"==typeof e||null===e||e instanceof Date||e instanceof Boolean||e instanceof Number||e instanceof String?JSON.stringify(e):e&&e.isLosslessNumber||"bigint"==typeof e?e.toString():Array.isArray(e)?function(t,e){if(0===t.length)return"[]";const n=c?e+c:void 0;let o=c?"[\n":"[";for(let e=0;e<t.length;e++){const i="function"==typeof r?r.call(t,String(e),t[e]):t[e];c&&(o+=n),o+=void 0!==i&&"function"!=typeof i?u(i,n):"null",e<t.length-1&&(o+=c?",\n":",")}return o+=c?"\n"+e+"]":"]",o}(e,a):e&&"object"==typeof e?function(e,n){if("function"==typeof e.toJSON)return t(e.toJSON(),r,o,void 0);const i=Array.isArray(r)?r.map(String):Object.keys(e);if(0===i.length)return"{}";const a=c?n+c:void 0;let f=!0,s=c?"{\n":"{";return i.forEach((t=>{const n="function"==typeof r?r.call(e,t,e[t]):e[t];if(function(t,e){return void 0!==e&&"function"!=typeof e&&"symbol"!=typeof e}(0,n)){f?f=!1:s+=c?",\n":",";const e=JSON.stringify(t);s+=c?a+e+": ":e+":",s+=u(n,a)}})),s+=c?"\n"+n+"}":"}",s}(e,a):void 0}},t.toLosslessNumber=function(t){if(a(t+"").length>15)throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${t})`);if(isNaN(t))throw new Error("Invalid number: NaN");if(!isFinite(t))throw new Error("Invalid number: "+t);return new h(String(t))},t.toSafeNumberOrThrow=function(t,e){const r=parseFloat(t),n=u(t);if(!0===e?.approx?n&&n!==c.truncate_float:n){const e=n?.replace(/_\w+$/,"");throw new Error(`Cannot safely convert to number: the value '${t}' would ${e} and become ${r}`)}return r}}(exports)},68262:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HashMD=void 0,exports.setBigUint64=setBigUint64,exports.Chi=function(a,b,c){return a&b^~a&c},exports.Maj=function(a,b,c){return a&b^a&c^b&c};const _assert_js_1=__webpack_require__(9113),utils_js_1=__webpack_require__(37995);function setBigUint64(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}class HashMD extends utils_js_1.Hash{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=(0,utils_js_1.createView)(this.buffer)}update(data){(0,_assert_js_1.aexists)(this);const{view,buffer,blockLen}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=(0,utils_js_1.createView)(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.aoutput)(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;setBigUint64(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=(0,utils_js_1.createView)(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}exports.HashMD=HashMD},68326:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},68574:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},68886:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.InvalidTokenError=exports.MissingParametersError=void 0;class MissingParametersError extends Error{constructor(message){super(),this.name="MissingParametersError",this.message=message||""}}exports.MissingParametersError=MissingParametersError;class InvalidTokenError extends Error{constructor(message){super(),this.name="InvalidTokenError",this.message=message||""}}exports.InvalidTokenError=InvalidTokenError},69057:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),__exportStar(__webpack_require__(90675),exports),__exportStar(__webpack_require__(2695),exports),__exportStar(__webpack_require__(21827),exports),__exportStar(__webpack_require__(68886),exports),__exportStar(__webpack_require__(61161),exports)},69066:module=>{"use strict";module.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},69114:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},69226:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var mod,Buffer=__webpack_require__(48287).Buffer,__create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})},__copyProps=(to,from,except,desc)=>{if(from&&"object"==typeof from||"function"==typeof from)for(let key of __getOwnPropNames(from))__hasOwnProp.call(to,key)||key===except||__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to},__toESM=(mod,isNodeMode,target)=>(target=null!=mod?__create(__getProtoOf(mod)):{},__copyProps(!isNodeMode&&mod&&mod.__esModule?target:__defProp(target,"default",{value:mod,enumerable:!0}),mod)),index_exports={};__export(index_exports,{Account:()=>Account,AccountInterface:()=>AccountInterface,BatchClient:()=>BatchClient,BlockStatus:()=>BlockStatus,BlockTag:()=>BlockTag,CairoCustomEnum:()=>CairoCustomEnum,CairoFixedArray:()=>CairoFixedArray,CairoOption:()=>CairoOption,CairoOptionVariant:()=>CairoOptionVariant,CairoResult:()=>CairoResult,CairoResultVariant:()=>CairoResultVariant,CairoUint256:()=>CairoUint256,CairoUint512:()=>CairoUint512,CallData:()=>CallData,Contract:()=>Contract,ContractFactory:()=>ContractFactory,ContractInterface:()=>ContractInterface,CustomError:()=>CustomError,EDAMode:()=>EDAMode,EDataAvailabilityMode:()=>EDataAvailabilityMode,ETH_ADDRESS:()=>ETH_ADDRESS,ETransactionExecutionStatus:()=>ETransactionExecutionStatus,ETransactionStatus:()=>ETransactionStatus,ETransactionVersion:()=>ETransactionVersion2,ETransactionVersion2:()=>ETransactionVersion22,ETransactionVersion3:()=>ETransactionVersion3,EntryPointType:()=>EntryPointType,EthSigner:()=>EthSigner,LedgerSigner:()=>LedgerSigner111,LedgerSigner111:()=>LedgerSigner111,LedgerSigner221:()=>LedgerSigner221,LedgerSigner231:()=>LedgerSigner231,LibraryError:()=>LibraryError,Literal:()=>Literal,LogLevelIndex:()=>LogLevelIndex,NON_ZERO_PREFIX:()=>NON_ZERO_PREFIX,OutsideExecutionTypesV1:()=>OutsideExecutionTypesV1,OutsideExecutionTypesV2:()=>OutsideExecutionTypesV2,OutsideExecutionVersion:()=>OutsideExecutionVersion,PaymasterInterface:()=>PaymasterInterface,PaymasterRpc:()=>PaymasterRpc,Provider:()=>RpcProvider2,ProviderInterface:()=>ProviderInterface,RPC:()=>api_exports,RPC07:()=>rpc_0_7_1_exports,RPC08:()=>rpc_0_8_1_exports,RPCResponseParser:()=>RPCResponseParser,ReceiptTx:()=>ReceiptTx,ResponseParser:()=>ResponseParser,RpcChannel:()=>RpcChannel2,RpcError:()=>RpcError,RpcProvider:()=>RpcProvider2,Signer:()=>Signer,SignerInterface:()=>SignerInterface,TransactionExecutionStatus:()=>TransactionExecutionStatus,TransactionFinalityStatus:()=>TransactionFinalityStatus,TransactionType:()=>TransactionType,TypedDataRevision:()=>import_starknet_types_07.TypedDataRevision,UINT_128_MAX:()=>UINT_128_MAX,UINT_128_MIN:()=>UINT_128_MIN,UINT_256_HIGH_MAX:()=>UINT_256_HIGH_MAX,UINT_256_HIGH_MIN:()=>UINT_256_HIGH_MIN,UINT_256_LOW_MAX:()=>UINT_256_LOW_MAX,UINT_256_LOW_MIN:()=>UINT_256_LOW_MIN,UINT_256_MAX:()=>UINT_256_MAX,UINT_256_MIN:()=>UINT_256_MIN,UINT_512_MAX:()=>UINT_512_MAX,UINT_512_MIN:()=>UINT_512_MIN,Uint:()=>Uint,ValidateType:()=>ValidateType,WSSubscriptions:()=>WSSubscriptions,WalletAccount:()=>WalletAccount,WebSocketChannel:()=>WebSocketChannel,addAddressPadding:()=>addAddressPadding,byteArray:()=>byteArray_exports,cairo:()=>cairo_exports,config:()=>config,constants:()=>constants_exports,contractClassResponseToLegacyCompiledContract:()=>contractClassResponseToLegacyCompiledContract,defaultPaymaster:()=>defaultPaymaster,defaultProvider:()=>defaultProvider,ec:()=>ec_exports,encode:()=>encode_exports,eth:()=>eth_exports,events:()=>events_exports,extractContractHashes:()=>extractContractHashes,fixProto:()=>fixProto,fixStack:()=>fixStack,getCalldata:()=>getCalldata,getChecksumAddress:()=>getChecksumAddress,getLedgerPathBuffer:()=>getLedgerPathBuffer111,getLedgerPathBuffer111:()=>getLedgerPathBuffer111,getLedgerPathBuffer221:()=>getLedgerPathBuffer221,hash:()=>hash_exports,isPendingBlock:()=>isPendingBlock,isPendingStateUpdate:()=>isPendingStateUpdate,isPendingTransaction:()=>isPendingTransaction,isRPC08_FeeEstimate:()=>isRPC08_FeeEstimate,isRPC08_ResourceBounds:()=>isRPC08_ResourceBounds,isSierra:()=>isSierra,isSupportedSpecVersion:()=>isSupportedSpecVersion,isV3Tx:()=>isV3Tx,isVersion:()=>isVersion,json:()=>json_exports,logger:()=>logger,merkle:()=>merkle_exports,num:()=>num_exports,outsideExecution:()=>outsideExecution_exports,parseCalldataField:()=>parseCalldataField,paymaster:()=>paymaster_exports,provider:()=>provider_exports,selector:()=>selector_exports,shortString:()=>shortString_exports,src5:()=>src5_exports,stark:()=>stark_exports,starknetId:()=>starknetId_exports,toAnyPatchVersion:()=>toAnyPatchVersion,transaction:()=>transaction_exports,typedData:()=>typedData_exports,types:()=>types_exports,uint256:()=>uint256_exports,units:()=>units,v2hash:()=>v2_exports,v3hash:()=>v3_exports,validateAndParseAddress:()=>validateAndParseAddress,validateChecksumAddress:()=>validateChecksumAddress,wallet:()=>connect_exports}),module.exports=(mod=index_exports,__copyProps(__defProp({},"__esModule",{value:!0}),mod));var constants_exports={};__export(constants_exports,{ADDR_BOUND:()=>ADDR_BOUND,API_VERSION:()=>API_VERSION,BaseUrl:()=>_BaseUrl,DEFAULT_GLOBAL_CONFIG:()=>DEFAULT_GLOBAL_CONFIG,HARDENING_4BYTES:()=>HARDENING_4BYTES,HARDENING_BYTE:()=>HARDENING_BYTE,IS_BROWSER:()=>IS_BROWSER,MASK_250:()=>MASK_250,MASK_31:()=>MASK_31,MAX_STORAGE_ITEM_SIZE:()=>MAX_STORAGE_ITEM_SIZE,NetworkName:()=>_NetworkName,OutsideExecutionCallerAny:()=>OutsideExecutionCallerAny,PAYMASTER_RPC_NODES:()=>PAYMASTER_RPC_NODES,PRIME:()=>PRIME,RANGE_FELT:()=>RANGE_FELT,RANGE_I128:()=>RANGE_I128,RANGE_U128:()=>RANGE_U128,RPC_DEFAULT_NODES:()=>RPC_DEFAULT_NODES,SNIP9_V1_INTERFACE_ID:()=>SNIP9_V1_INTERFACE_ID,SNIP9_V2_INTERFACE_ID:()=>SNIP9_V2_INTERFACE_ID,SYSTEM_MESSAGES:()=>SYSTEM_MESSAGES,StarknetChainId:()=>_StarknetChainId,SupportedRpcVersion:()=>_SupportedRpcVersion,TEXT_TO_FELT_MAX_LEN:()=>TEXT_TO_FELT_MAX_LEN,TRANSACTION_VERSION:()=>TRANSACTION_VERSION,TransactionHashPrefix:()=>_TransactionHashPrefix,UDC:()=>UDC,ZERO:()=>ZERO});var api_exports={};__export(api_exports,{JRPC:()=>jsonrpc_exports,PAYMASTER_API:()=>import_starknet_types_08.PAYMASTER_API,RPCSPEC07:()=>RPCSPEC07,RPCSPEC08:()=>RPCSPEC08});var jsonrpc_exports={},RPCSPEC07=__toESM(__webpack_require__(83304)),RPCSPEC08=__toESM(__webpack_require__(8143)),import_starknet_types_08=__webpack_require__(8143);((target,mod,secondTarget)=>{__copyProps(target,mod,"default"),secondTarget&&__copyProps(secondTarget,mod,"default")})(api_exports,__webpack_require__(8143));var encode_exports={};__export(encode_exports,{IS_BROWSER:()=>IS_BROWSER,addHexPrefix:()=>addHexPrefix,arrayBufferToString:()=>arrayBufferToString,atobUniversal:()=>atobUniversal,btoaUniversal:()=>btoaUniversal,buf2hex:()=>buf2hex,calcByteLength:()=>calcByteLength,concatenateArrayBuffer:()=>concatenateArrayBuffer,padLeft:()=>padLeft,pascalToSnake:()=>pascalToSnake,removeHexPrefix:()=>removeHexPrefix,sanitizeBytes:()=>sanitizeBytes,sanitizeHex:()=>sanitizeHex,utf8ToArray:()=>utf8ToArray});var import_base=__webpack_require__(69999),IS_BROWSER="undefined"!=typeof window,STRING_ZERO="0";function arrayBufferToString(array){return new Uint8Array(array).reduce(((data,byte)=>data+String.fromCharCode(byte)),"")}function utf8ToArray(str){return(new TextEncoder).encode(str)}function atobUniversal(a){return import_base.base64.decode(a)}function btoaUniversal(b){return import_base.base64.encode(new Uint8Array(b))}function buf2hex(buffer){return buffer.reduce(((r,x)=>r+x.toString(16).padStart(2,"0")),"")}function removeHexPrefix(hex){return hex.replace(/^0x/i,"")}function addHexPrefix(hex){return`0x${removeHexPrefix(hex)}`}function padLeft(str,length,padding=STRING_ZERO){return function(str,length,left,padding=STRING_ZERO){const diff=length-str.length;let result=str;if(diff>0){const pad=padding.repeat(diff);result=left?pad+str:str+pad}return result}(str,length,!0,padding)}function calcByteLength(str,byteSize=8){const{length}=str,remainder=length%byteSize;return remainder?(length-remainder)/byteSize*byteSize+byteSize:length}function sanitizeBytes(str,byteSize=8,padding=STRING_ZERO){return padLeft(str,calcByteLength(str,byteSize),padding)}function sanitizeHex(hex){const sanitizedHex=sanitizeBytes(removeHexPrefix(hex),2);return sanitizedHex?addHexPrefix(sanitizedHex):sanitizedHex}var pascalToSnake=text=>/[a-z]/.test(text)?text.split(/(?=[A-Z])/).join("_").toUpperCase():text;function concatenateArrayBuffer(uint8arrays){const totalLength=uint8arrays.reduce(((total,uint8array)=>total+uint8array.byteLength),0),result=new Uint8Array(totalLength);let offset=0;return uint8arrays.forEach((uint8array=>{result.set(uint8array,offset),offset+=uint8array.byteLength})),result}var TEXT_TO_FELT_MAX_LEN=31,{ETransactionVersion:TRANSACTION_VERSION}=RPCSPEC08,ZERO=0n,MASK_250=2n**250n-1n,MASK_31=2n**31n-1n,API_VERSION=ZERO,PRIME=2n**251n+17n*2n**192n+1n,MAX_STORAGE_ITEM_SIZE=256n,ADDR_BOUND=2n**251n-MAX_STORAGE_ITEM_SIZE,range=(min,max)=>({min,max}),RANGE_FELT=range(ZERO,PRIME-1n),RANGE_I128=range(-(2n**127n),2n**127n-1n),RANGE_U128=range(ZERO,2n**128n-1n),UDC={ADDRESS:"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",ENTRYPOINT:"deployContract"},OutsideExecutionCallerAny="0x414e595f43414c4c4552",SNIP9_V1_INTERFACE_ID="0x68cfd18b92d1907b8ba3cc324900277f5a3622099431ea85dd8089255e4181",SNIP9_V2_INTERFACE_ID="0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872",HARDENING_BYTE=128,HARDENING_4BYTES=2147483648n,_BaseUrl={SN_MAIN:"https://alpha-mainnet.starknet.io",SN_SEPOLIA:"https://alpha-sepolia.starknet.io"},_NetworkName={SN_MAIN:"SN_MAIN",SN_SEPOLIA:"SN_SEPOLIA"},_StarknetChainId={SN_MAIN:"0x534e5f4d41494e",SN_SEPOLIA:"0x534e5f5345504f4c4941"},_TransactionHashPrefix={DECLARE:"0x6465636c617265",DEPLOY:"0x6465706c6f79",DEPLOY_ACCOUNT:"0x6465706c6f795f6163636f756e74",INVOKE:"0x696e766f6b65",L1_HANDLER:"0x6c315f68616e646c6572"},_SupportedRpcVersion={"0.7.1":"0.7.1","0.8.1":"0.8.1",v0_7_1:"0.7.1",v0_8_1:"0.8.1"},DEFAULT_GLOBAL_CONFIG={legacyMode:!1,rpcVersion:"0.8.1",transactionVersion:api_exports.ETransactionVersion.V3,logLevel:"INFO",feeMarginPercentage:{bounds:{l1_gas:{max_amount:50,max_price_per_unit:50},l1_data_gas:{max_amount:50,max_price_per_unit:50},l2_gas:{max_amount:50,max_price_per_unit:50}},maxFee:50},fetch:void 0,websocket:void 0},RPC_DEFAULT_NODES={SN_MAIN:["https://starknet-mainnet.public.blastapi.io/rpc/"],SN_SEPOLIA:["https://starknet-sepolia.public.blastapi.io/rpc/"]},PAYMASTER_RPC_NODES={SN_MAIN:["https://starknet.paymaster.avnu.fi"],SN_SEPOLIA:["https://sepolia.paymaster.avnu.fi"]},SYSTEM_MESSAGES={legacyTxWarningMessage:"You are using a deprecated transaction version (V0,V1,V2)!\nUpdate to the latest V3 transactions!",legacyTxRPC08Message:"RPC 0.8 do not support legacy transactions",SWOldV3:"RPC 0.7 V3 tx (improper resource bounds) not supported in RPC 0.8",channelVersionMismatch:"Channel specification version is not compatible with the connected node Specification Version",unsupportedSpecVersion:"The connected node specification version is not supported by this library",maxFeeInV3:"maxFee is not supported in V3 transactions, use resourceBounds instead"},config=class _Configuration{static instance;config;constructor(){this.initialize()}initialize(){this.config={...DEFAULT_GLOBAL_CONFIG}}static getInstance(){return _Configuration.instance||(_Configuration.instance=new _Configuration),_Configuration.instance}get(key,defaultValue){return this.config[key]??defaultValue}set(key,value){this.config[key]=value}update(configData){this.config={...this.config,...configData}}getAll(){return{...this.config}}reset(){this.initialize()}delete(key){delete this.config[key]}hasKey(key){return key in this.config}}.getInstance(),LogLevelIndex={DEBUG:5,INFO:4,WARN:3,ERROR:2,FATAL:1,OFF:0},logger=class _Logger{static instance;config;constructor(){this.config=config}static getInstance(){return _Logger.instance||(_Logger.instance=new _Logger),_Logger.instance}getTimestamp(){return(new Date).toISOString()}shouldLog(messageLevel){const configLevel=this.config.get("logLevel","INFO");return messageLevel<=LogLevelIndex[configLevel]}formatMessage(logMessage){const{level,message,timestamp,data}=logMessage;let formattedMessage=`[${timestamp}] ${level}: ${message}`;if(data)try{formattedMessage+=`\n${JSON.stringify(data,null,2)}`}catch(error){formattedMessage+=`\n[JSON.stringify Error/Circular]: ${error}`}return formattedMessage}log(level,message,data){if(!this.shouldLog(LogLevelIndex[level]))return;const logMessage={level,message,timestamp:this.getTimestamp(),data};this.formatMessage(logMessage)}debug(message,data){this.log("DEBUG",message,data)}info(message,data){this.log("INFO",message,data)}warn(message,data){this.log("WARN",message,data)}error(message,data){this.log("ERROR",message,data)}fatal(message,data){this.log("FATAL",message,data)}setLogLevel(level){this.config.set("logLevel",level)}getLogLevel(){return this.config.get("logLevel","INFO")}getEnabledLogLevels(){return Object.keys(LogLevelIndex).filter((s=>this.shouldLog(LogLevelIndex[s])&&"OFF"!==s))}}.getInstance(),rpc_0_7_1_exports={};__export(rpc_0_7_1_exports,{RpcChannel:()=>RpcChannel});var types_exports={};__export(types_exports,{BlockStatus:()=>BlockStatus,BlockTag:()=>BlockTag,EDAMode:()=>EDAMode,EDataAvailabilityMode:()=>EDataAvailabilityMode,ETH_ADDRESS:()=>ETH_ADDRESS,ETransactionExecutionStatus:()=>ETransactionExecutionStatus,ETransactionStatus:()=>ETransactionStatus,ETransactionVersion:()=>ETransactionVersion2,ETransactionVersion2:()=>ETransactionVersion22,ETransactionVersion3:()=>ETransactionVersion3,EntryPointType:()=>EntryPointType,Literal:()=>Literal,NON_ZERO_PREFIX:()=>NON_ZERO_PREFIX,OutsideExecutionTypesV1:()=>OutsideExecutionTypesV1,OutsideExecutionTypesV2:()=>OutsideExecutionTypesV2,OutsideExecutionVersion:()=>OutsideExecutionVersion,RPC:()=>api_exports,TransactionExecutionStatus:()=>TransactionExecutionStatus,TransactionFinalityStatus:()=>TransactionFinalityStatus,TransactionType:()=>TransactionType,TypedDataRevision:()=>import_starknet_types_07.TypedDataRevision,Uint:()=>Uint,ValidateType:()=>ValidateType,isRPC08_FeeEstimate:()=>isRPC08_FeeEstimate,isRPC08_ResourceBounds:()=>isRPC08_ResourceBounds});var EntryPointType={EXTERNAL:"EXTERNAL",L1_HANDLER:"L1_HANDLER",CONSTRUCTOR:"CONSTRUCTOR"},TransactionType={DECLARE:"DECLARE",DEPLOY:"DEPLOY",DEPLOY_ACCOUNT:"DEPLOY_ACCOUNT",INVOKE:"INVOKE_FUNCTION"},TransactionFinalityStatus={NOT_RECEIVED:"NOT_RECEIVED",RECEIVED:"RECEIVED",ACCEPTED_ON_L2:"ACCEPTED_ON_L2",ACCEPTED_ON_L1:"ACCEPTED_ON_L1"},TransactionExecutionStatus={REJECTED:"REJECTED",REVERTED:"REVERTED",SUCCEEDED:"SUCCEEDED"},BlockStatus={PENDING:"PENDING",ACCEPTED_ON_L1:"ACCEPTED_ON_L1",ACCEPTED_ON_L2:"ACCEPTED_ON_L2",REJECTED:"REJECTED"},BlockTag={PENDING:"pending",LATEST:"latest"},RPCSPEC082=__toESM(__webpack_require__(8143)),{ETransactionVersion:ETransactionVersion2}=RPCSPEC082,{ETransactionVersion2:ETransactionVersion22}=RPCSPEC082,{ETransactionVersion3}=RPCSPEC082,{EDataAvailabilityMode}=RPCSPEC082,{EDAMode}=RPCSPEC082;function isRPC08_FeeEstimate(entry){return"l1_data_gas_consumed"in entry}function isRPC08_ResourceBounds(entry){return"l1_data_gas"in entry}var{ETransactionStatus}=RPCSPEC082,{ETransactionExecutionStatus}=RPCSPEC082,ValidateType={DEPLOY:"DEPLOY",CALL:"CALL",INVOKE:"INVOKE"},Uint={u8:"core::integer::u8",u16:"core::integer::u16",u32:"core::integer::u32",u64:"core::integer::u64",u128:"core::integer::u128",u256:"core::integer::u256",u512:"core::integer::u512"},Literal={ClassHash:"core::starknet::class_hash::ClassHash",ContractAddress:"core::starknet::contract_address::ContractAddress",Secp256k1Point:"core::starknet::secp256k1::Secp256k1Point",U96:"core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>"},ETH_ADDRESS="core::starknet::eth_address::EthAddress",NON_ZERO_PREFIX="core::zeroable::NonZero::",OutsideExecutionTypesV1={StarkNetDomain:[{name:"name",type:"felt"},{name:"version",type:"felt"},{name:"chainId",type:"felt"}],OutsideExecution:[{name:"caller",type:"felt"},{name:"nonce",type:"felt"},{name:"execute_after",type:"felt"},{name:"execute_before",type:"felt"},{name:"calls_len",type:"felt"},{name:"calls",type:"OutsideCall*"}],OutsideCall:[{name:"to",type:"felt"},{name:"selector",type:"felt"},{name:"calldata_len",type:"felt"},{name:"calldata",type:"felt*"}]},OutsideExecutionTypesV2={StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],OutsideExecution:[{name:"Caller",type:"ContractAddress"},{name:"Nonce",type:"felt"},{name:"Execute After",type:"u128"},{name:"Execute Before",type:"u128"},{name:"Calls",type:"Call*"}],Call:[{name:"To",type:"ContractAddress"},{name:"Selector",type:"selector"},{name:"Calldata",type:"felt*"}]},OutsideExecutionVersion={UNSUPPORTED:"0",V1:"1",V2:"2"},import_starknet_types_07=__webpack_require__(83304),json_exports={};__export(json_exports,{parse:()=>parse2,parseAlwaysAsBig:()=>parseAlwaysAsBig,stringify:()=>stringify2});var json=__toESM(__webpack_require__(67631)),parseIntAsNumberOrBigInt=str=>{if(!json.isInteger(str))return parseFloat(str);const num=parseInt(str,10);return Number.isSafeInteger(num)?num:BigInt(str)},parse2=str=>json.parse(String(str),void 0,parseIntAsNumberOrBigInt),parseAlwaysAsBig=str=>json.parse(String(str),void 0,json.parseNumberAndBigInt),stringify2=(value,replacer,space,numberStringifiers)=>json.stringify(value,replacer,space,numberStringifiers),BatchClient=class{nodeUrl;headers;interval;requestId=0;pendingRequests={};batchPromises={};delayTimer;delayPromise;delayPromiseResolve;baseFetch;constructor(options){this.nodeUrl=options.nodeUrl,this.headers=options.headers,this.interval=options.interval,this.baseFetch=options.baseFetch}async wait(){return this.delayPromise&&this.delayPromiseResolve||(this.delayPromise=new Promise((resolve=>{this.delayPromiseResolve=resolve}))),this.delayTimer&&(clearTimeout(this.delayTimer),this.delayTimer=void 0),this.delayTimer=setTimeout((()=>{this.delayPromiseResolve&&(this.delayPromiseResolve(),this.delayPromise=void 0,this.delayPromiseResolve=void 0)}),this.interval),this.delayPromise}addPendingRequest(method,params,id){const request={id:id??`batched_${this.requestId+=1}`,jsonrpc:"2.0",method,params:params??void 0};return this.pendingRequests[request.id]=request,request.id}async sendBatch(requests){return(await this.baseFetch(this.nodeUrl,{method:"POST",body:stringify2(requests),headers:this.headers})).json()}async fetch(method,params,id){const requestId=this.addPendingRequest(method,params,id);await this.wait();const requests=this.pendingRequests;if(this.pendingRequests={},!this.batchPromises[requestId]){const promise=this.sendBatch(Object.values(requests));Object.keys(requests).forEach((key=>{this.batchPromises[key]=promise}))}const results=await this.batchPromises[requestId];delete this.batchPromises[requestId];const result=results.find((res=>res.id===requestId));if(!result)throw new Error(`Couldn't find the result for the request. Method: ${method}`);return result}};function assert(condition,message){if(!condition)throw new Error(message||"Assertion failure")}function assertX(condition,method){if(!condition){if(0!==method.length)throw new Error("AssertionX failure: message function should not require arguments");method()}}var num_exports={};__export(num_exports,{addPercent:()=>addPercent,assertInRange:()=>assertInRange,bigNumberishArrayToDecimalStringArray:()=>bigNumberishArrayToDecimalStringArray,bigNumberishArrayToHexadecimalStringArray:()=>bigNumberishArrayToHexadecimalStringArray,cleanHex:()=>cleanHex,getDecimalString:()=>getDecimalString,getHexString:()=>getHexString,getHexStringArray:()=>getHexStringArray,hexToBytes:()=>hexToBytes,hexToDecimalString:()=>hexToDecimalString,isBigNumberish:()=>isBigNumberish,isHex:()=>isHex,isStringWholeNumber:()=>isStringWholeNumber,stringToSha256ToArrayBuff4:()=>stringToSha256ToArrayBuff4,toBigInt:()=>toBigInt,toCairoBool:()=>toCairoBool,toHex:()=>toHex,toHex64:()=>toHex64,toHexString:()=>toHexString,toStorageKey:()=>toStorageKey,tryToBigInt:()=>tryToBigInt});var import_utils=__webpack_require__(91484),import_sha256=__webpack_require__(8603),isUndefined=value=>void 0===value||void 0===value;function isNumber(value){return"number"==typeof value}function isBoolean(value){return"boolean"==typeof value}function isBigInt(value){return"bigint"==typeof value}function isString(value){return"string"==typeof value}function isObject(item){return!!item&&"object"==typeof item&&!Array.isArray(item)}function isHex(hex){return/^0x[0-9a-f]*$/i.test(hex)}function toBigInt(value){return BigInt(value)}function tryToBigInt(value){return value?BigInt(value):void 0}function toHex(value){return addHexPrefix(toBigInt(value).toString(16))}var toHexString=toHex;function toStorageKey(number){return addHexPrefix(toBigInt(number).toString(16).padStart(64,"0"))}function toHex64(number){const res=addHexPrefix(toBigInt(number).toString(16).padStart(64,"0"));if(66!==res.length)throw TypeError("number is too big for hex 0x(64) representation");return res}function hexToDecimalString(hex){return BigInt(addHexPrefix(hex)).toString(10)}function cleanHex(hex){return hex.toLowerCase().replace(/^(0x)0+/,"$1")}function assertInRange(input,lowerBound,upperBound,inputName=""){const messageSuffix=""===inputName?"invalid length":`invalid ${inputName} length`,inputBigInt=BigInt(input),lowerBoundBigInt=BigInt(lowerBound),upperBoundBigInt=BigInt(upperBound);assert(inputBigInt>=lowerBoundBigInt&&inputBigInt<=upperBoundBigInt,`Message not signable, ${messageSuffix}.`)}function bigNumberishArrayToDecimalStringArray(data){return data.map((x=>toBigInt(x).toString(10)))}function bigNumberishArrayToHexadecimalStringArray(data){return data.map((x=>toHex(x)))}function isStringWholeNumber(str){return/^\d+$/.test(str)}function getDecimalString(str){if(isHex(str))return hexToDecimalString(str);if(isStringWholeNumber(str))return str;throw new Error(`${str} needs to be a hex-string or whole-number-string`)}function getHexString(str){if(isHex(str))return str;if(isStringWholeNumber(str))return toHexString(str);throw new Error(`${str} needs to be a hex-string or whole-number-string`)}function getHexStringArray(array){return array.map(getHexString)}function toCairoBool(value){return(+value).toString()}function hexToBytes(str){if(!isHex(str))throw new Error(`${str} needs to be a hex-string`);let adaptedValue=removeHexPrefix(str);return adaptedValue.length%2!=0&&(adaptedValue=`0${adaptedValue}`),(0,import_utils.hexToBytes)(adaptedValue)}function addPercent(number,percent){const bigIntNum=BigInt(number);return bigIntNum+bigIntNum*BigInt(percent)/100n}function stringToSha256ToArrayBuff4(str){var n;return hexToBytes(toHex((n=BigInt(addHexPrefix(buf2hex((0,import_sha256.sha256)(str)))),Number(n&MASK_31))))}function isBigNumberish(input){return isNumber(input)||isBigInt(input)||isString(input)&&(isHex(input)||isStringWholeNumber(input))}var selector_exports={};__export(selector_exports,{getL1MessageHash:()=>getL1MessageHash,getL2MessageHash:()=>getL2MessageHash,getSelector:()=>getSelector,getSelectorFromName:()=>getSelectorFromName,keccakBn:()=>keccakBn,solidityUint256PackedKeccak256:()=>solidityUint256PackedKeccak256,starknetKeccak:()=>starknetKeccak});var import_starknet=__webpack_require__(4246),import_sha3=__webpack_require__(33575),import_utils2=__webpack_require__(91484);function keccakBn(value){const hexWithoutPrefix=removeHexPrefix(toHex(BigInt(value))),evenHex=hexWithoutPrefix.length%2==0?hexWithoutPrefix:`0${hexWithoutPrefix}`;return addHexPrefix((0,import_starknet.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16))}function starknetKeccak(str){const hash=BigInt(function(str){return addHexPrefix((0,import_starknet.keccak)(utf8ToArray(str)).toString(16))}(str));return hash&MASK_250}function getSelectorFromName(funcName){return toHex(starknetKeccak(funcName))}function getSelector(value){return isNumber(value)||isBigInt(value)?toHex(value):isHex(value)?value:isStringWholeNumber(value)?toHex(value):getSelectorFromName(value)}function solidityUint256PackedKeccak256(params){const myEncode=addHexPrefix(params.reduce(((res,par)=>res+removeHexPrefix(toHex(par)).padStart(64,"0")),""));return addHexPrefix((0,import_utils2.bytesToHex)((0,import_sha3.keccak_256)(hexToBytes(myEncode))))}function getL2MessageHash(l1FromAddress,l2ToAddress,l2Selector,l2Calldata,l1Nonce){return solidityUint256PackedKeccak256([l1FromAddress,l2ToAddress,l1Nonce,l2Selector,l2Calldata.length,...l2Calldata])}function getL1MessageHash(fromL2Address,toL1Address,payload){return solidityUint256PackedKeccak256([fromL2Address,toL1Address,payload.length,...payload])}var shortString_exports={};function isASCII(str){return/^[\x00-\x7F]*$/.test(str)}function isShortString(str){return str.length<=TEXT_TO_FELT_MAX_LEN}function isDecimalString(str){return/^[0-9]*$/i.test(str)}function isText(val){return isString(val)&&!isHex(val)&&!isStringWholeNumber(val)}__export(shortString_exports,{decodeShortString:()=>decodeShortString,encodeShortString:()=>encodeShortString,isASCII:()=>isASCII,isDecimalString:()=>isDecimalString,isLongText:()=>isLongText,isShortString:()=>isShortString,isShortText:()=>isShortText,isText:()=>isText,splitLongString:()=>splitLongString});var isShortText=val=>isText(val)&&isShortString(val),isLongText=val=>isText(val)&&!isShortString(val);function splitLongString(longStr){const regex=RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`,"g");return longStr.match(regex)||[]}function encodeShortString(str){if(!isASCII(str))throw new Error(`${str} is not an ASCII string`);if(!isShortString(str))throw new Error(`${str} is too long`);return addHexPrefix(str.replace(/./g,(char=>char.charCodeAt(0).toString(16))))}function decodeShortString(str){if(!isASCII(str))throw new Error(`${str} is not an ASCII string`);if(isHex(str))return removeHexPrefix(str).replace(/.{2}/g,(hex=>String.fromCharCode(parseInt(hex,16))));if(isDecimalString(str))return decodeShortString("0X".concat(BigInt(str).toString(16)));throw new Error(`${str} is not Hex or decimal`)}var byteArray_exports={};function stringFromByteArray(myByteArray){const pending_word=0n===BigInt(myByteArray.pending_word)?"":decodeShortString(toHex(myByteArray.pending_word));return myByteArray.data.reduce(((cumuledString,encodedString)=>cumuledString+(0n===BigInt(encodedString)?"":decodeShortString(toHex(encodedString)))),"")+pending_word}function byteArrayFromString(targetString){const shortStrings=splitLongString(targetString),remainder=shortStrings[shortStrings.length-1],shortStringsEncoded=shortStrings.map(encodeShortString),[pendingWord,pendingWordLength]=void 0===remainder||31===remainder.length?["0x00",0]:[shortStringsEncoded.pop(),remainder.length];return{data:0===shortStringsEncoded.length?[]:shortStringsEncoded,pending_word:pendingWord,pending_word_len:pendingWordLength}}__export(byteArray_exports,{byteArrayFromString:()=>byteArrayFromString,stringFromByteArray:()=>stringFromByteArray});var cairo_exports={};function CairoFelt(it){if(isBigInt(it)||Number.isInteger(it))return it.toString();if(isString(it)){if(isHex(it))return BigInt(it).toString();if(isText(it)){if(!isShortString(it))throw new Error(`${it} is a long string > 31 chars. Please split it into an array of short strings.`);return BigInt(encodeShortString(it)).toString()}if(isStringWholeNumber(it))return it}if(isBoolean(it))return""+ +it;throw new Error(`${it} can't be computed by felt()`)}__export(cairo_exports,{felt:()=>felt,getAbiContractVersion:()=>getAbiContractVersion,getArrayType:()=>getArrayType,isCairo1Abi:()=>isCairo1Abi,isCairo1Type:()=>isCairo1Type,isLen:()=>isLen,isTypeArray:()=>isTypeArray,isTypeBool:()=>isTypeBool,isTypeByteArray:()=>isTypeByteArray,isTypeBytes31:()=>isTypeBytes31,isTypeContractAddress:()=>isTypeContractAddress,isTypeEnum:()=>isTypeEnum,isTypeEthAddress:()=>isTypeEthAddress,isTypeFelt:()=>isTypeFelt,isTypeLiteral:()=>isTypeLiteral,isTypeNamedTuple:()=>isTypeNamedTuple,isTypeNonZero:()=>isTypeNonZero,isTypeOption:()=>isTypeOption,isTypeResult:()=>isTypeResult,isTypeSecp256k1Point:()=>isTypeSecp256k1Point,isTypeStruct:()=>isTypeStruct,isTypeTuple:()=>isTypeTuple,isTypeU96:()=>isTypeU96,isTypeUint:()=>isTypeUint,isTypeUint256:()=>isTypeUint256,tuple:()=>tuple,uint256:()=>uint256,uint512:()=>uint512});var UINT_128_MAX=(1n<<128n)-1n,UINT_256_MAX=(1n<<256n)-1n,UINT_256_MIN=0n,UINT_256_LOW_MAX=340282366920938463463374607431768211455n,UINT_256_HIGH_MAX=340282366920938463463374607431768211455n,UINT_256_LOW_MIN=0n,UINT_256_HIGH_MIN=0n,CairoUint256=class _CairoUint256{low;high;static abiSelector="core::integer::u256";constructor(...arr){if("object"==typeof arr[0]&&1===arr.length&&"low"in arr[0]&&"high"in arr[0]){const props=_CairoUint256.validateProps(arr[0].low,arr[0].high);this.low=props.low,this.high=props.high}else if(1===arr.length){const bigInt=_CairoUint256.validate(arr[0]);this.low=bigInt&UINT_128_MAX,this.high=bigInt>>128n}else{if(2!==arr.length)throw Error("Incorrect constructor parameters");{const props=_CairoUint256.validateProps(arr[0],arr[1]);this.low=props.low,this.high=props.high}}}static validate(bigNumberish){const bigInt=BigInt(bigNumberish);if(bigInt<UINT_256_MIN)throw Error("bigNumberish is smaller than UINT_256_MIN");if(bigInt>UINT_256_MAX)throw new Error("bigNumberish is bigger than UINT_256_MAX");return bigInt}static validateProps(low,high){const bigIntLow=BigInt(low),bigIntHigh=BigInt(high);if(bigIntLow<UINT_256_LOW_MIN||bigIntLow>UINT_256_LOW_MAX)throw new Error("low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX");if(bigIntHigh<UINT_256_HIGH_MIN||bigIntHigh>UINT_256_HIGH_MAX)throw new Error("high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX");return{low:bigIntLow,high:bigIntHigh}}static is(bigNumberish){try{_CairoUint256.validate(bigNumberish)}catch(error){return!1}return!0}static isAbiType(abiType){return abiType===_CairoUint256.abiSelector}toBigInt(){return(this.high<<128n)+this.low}toUint256HexString(){return{low:addHexPrefix(this.low.toString(16)),high:addHexPrefix(this.high.toString(16))}}toUint256DecimalString(){return{low:this.low.toString(10),high:this.high.toString(10)}}toApiRequest(){return[CairoFelt(this.low),CairoFelt(this.high)]}},UINT_512_MAX=(1n<<512n)-1n,UINT_512_MIN=0n,UINT_128_MIN=0n,CairoUint512=class _CairoUint512{limb0;limb1;limb2;limb3;static abiSelector="core::integer::u512";constructor(...arr){if("object"==typeof arr[0]&&1===arr.length&&"limb0"in arr[0]&&"limb1"in arr[0]&&"limb2"in arr[0]&&"limb3"in arr[0]){const props=_CairoUint512.validateProps(arr[0].limb0,arr[0].limb1,arr[0].limb2,arr[0].limb3);this.limb0=props.limb0,this.limb1=props.limb1,this.limb2=props.limb2,this.limb3=props.limb3}else if(1===arr.length){const bigInt=_CairoUint512.validate(arr[0]);this.limb0=bigInt&UINT_128_MAX,this.limb1=(bigInt&UINT_128_MAX<<128n)>>128n,this.limb2=(bigInt&UINT_128_MAX<<256n)>>256n,this.limb3=bigInt>>384n}else{if(4!==arr.length)throw Error("Incorrect Uint512 constructor parameters");{const props=_CairoUint512.validateProps(arr[0],arr[1],arr[2],arr[3]);this.limb0=props.limb0,this.limb1=props.limb1,this.limb2=props.limb2,this.limb3=props.limb3}}}static validate(bigNumberish){const bigInt=BigInt(bigNumberish);if(bigInt<UINT_512_MIN)throw Error("bigNumberish is smaller than UINT_512_MIN.");if(bigInt>UINT_512_MAX)throw Error("bigNumberish is bigger than UINT_512_MAX.");return bigInt}static validateProps(limb0,limb1,limb2,limb3){const l0=BigInt(limb0),l1=BigInt(limb1),l2=BigInt(limb2),l3=BigInt(limb3);return[l0,l1,l2,l3].forEach(((value,index)=>{if(value<UINT_128_MIN||value>UINT_128_MAX)throw Error(`limb${index} is not in the range of a u128 number`)})),{limb0:l0,limb1:l1,limb2:l2,limb3:l3}}static is(bigNumberish){try{_CairoUint512.validate(bigNumberish)}catch(error){return!1}return!0}static isAbiType(abiType){return abiType===_CairoUint512.abiSelector}toBigInt(){return(this.limb3<<384n)+(this.limb2<<256n)+(this.limb1<<128n)+this.limb0}toUint512HexString(){return{limb0:addHexPrefix(this.limb0.toString(16)),limb1:addHexPrefix(this.limb1.toString(16)),limb2:addHexPrefix(this.limb2.toString(16)),limb3:addHexPrefix(this.limb3.toString(16))}}toUint512DecimalString(){return{limb0:this.limb0.toString(10),limb1:this.limb1.toString(10),limb2:this.limb2.toString(10),limb3:this.limb3.toString(10)}}toApiRequest(){return[CairoFelt(this.limb0),CairoFelt(this.limb1),CairoFelt(this.limb2),CairoFelt(this.limb3)]}},isLen=name=>/_len$/.test(name),isTypeFelt=type=>"felt"===type||"core::felt252"===type,isTypeArray=type=>/\*/.test(type)||type.startsWith("core::array::Array::")||type.startsWith("core::array::Span::"),isTypeTuple=type=>/^\(.*\)$/i.test(type),isTypeNamedTuple=type=>/\(.*\)/i.test(type)&&type.includes(":"),isTypeStruct=(type,structs)=>type in structs,isTypeEnum=(type,enums)=>type in enums,isTypeOption=type=>type.startsWith("core::option::Option::"),isTypeResult=type=>type.startsWith("core::result::Result::"),isTypeUint=type=>Object.values(Uint).includes(type),isTypeUint256=type=>CairoUint256.isAbiType(type),isTypeLiteral=type=>Object.values(Literal).includes(type),isTypeBool=type=>"core::bool"===type,isTypeContractAddress=type=>type===Literal.ContractAddress,isTypeEthAddress=type=>type===ETH_ADDRESS,isTypeBytes31=type=>"core::bytes_31::bytes31"===type,isTypeByteArray=type=>"core::byte_array::ByteArray"===type,isTypeU96=type=>"core::internal::bounded_int::BoundedInt::<0, 79228162514264337593543950335>"===type,isTypeSecp256k1Point=type=>type===Literal.Secp256k1Point,isCairo1Type=type=>type.includes("::"),getArrayType=type=>isCairo1Type(type)?type.substring(type.indexOf("<")+1,type.lastIndexOf(">")):type.replace("*","");function isCairo1Abi(abi){const{cairo}=getAbiContractVersion(abi);if(void 0===cairo)throw Error("Unable to determine Cairo version");return"1"===cairo}function isTypeNonZero(type){return type.startsWith(NON_ZERO_PREFIX)}function getAbiContractVersion(abi){if(abi.find((it=>"interface"===it.type)))return{cairo:"1",compiler:"2"};const testSubject=abi.find((it=>("function"===it.type||"constructor"===it.type)&&(it.inputs.length||it.outputs.length)));if(!testSubject)return{cairo:void 0,compiler:void 0};const io=testSubject.inputs.length?testSubject.inputs:testSubject.outputs;return isCairo1Type(io[0].type)?{cairo:"1",compiler:"1"}:{cairo:"0",compiler:"0"}}var uint256=it=>new CairoUint256(it).toUint256DecimalString(),uint512=it=>new CairoUint512(it).toUint512DecimalString(),tuple=(...args)=>({...args});function felt(it){return CairoFelt(it)}var CairoCustomEnum=class{variant;constructor(enumContent){const variantsList=Object.values(enumContent);if(0===variantsList.length)throw new Error("This Enum must have at least 1 variant");if(1!==variantsList.filter((content=>!isUndefined(content))).length)throw new Error("This Enum must have exactly one active variant");this.variant=enumContent}unwrap(){return Object.values(this.variant).find((item=>!isUndefined(item)))}activeVariant(){const activeVariant=Object.entries(this.variant).find((item=>!isUndefined(item[1])));return isUndefined(activeVariant)?"":activeVariant[0]}},CairoOptionVariant={Some:0,None:1},CairoOption=class{Some;None;constructor(variant,content){if(!(variant in Object.values(CairoOptionVariant)))throw new Error("Wrong variant! It should be CairoOptionVariant.Some or .None.");if(variant===CairoOptionVariant.Some){if(isUndefined(content))throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');this.Some=content,this.None=void 0}else this.Some=void 0,this.None=!0}unwrap(){return this.None?void 0:this.Some}isSome(){return!isUndefined(this.Some)}isNone(){return!0===this.None}},CairoResultVariant={Ok:0,Err:1},CairoResult=class{Ok;Err;constructor(variant,resultContent){if(!(variant in Object.values(CairoResultVariant)))throw new Error("Wrong variant! It should be CairoResultVariant.Ok or .Err.");variant===CairoResultVariant.Ok?(this.Ok=resultContent,this.Err=void 0):(this.Ok=void 0,this.Err=resultContent)}unwrap(){if(!isUndefined(this.Ok))return this.Ok;if(!isUndefined(this.Err))return this.Err;throw new Error("Both Result.Ok and .Err are undefined. Not authorized.")}isOk(){return!isUndefined(this.Ok)}isErr(){return!isUndefined(this.Err)}},guard_isBN=(data,type,key)=>{if(!isBigInt(data[key]))throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`)},guard_unknown=(data,type,key)=>{throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`)};function formatter(data,type,sameType){return Object.entries(data).reduce(((acc,[key,value])=>{const elType=sameType??type[key];if(!(key in type)&&!sameType)return acc[key]=value,acc;if("string"===elType){if(Array.isArray(data[key])){const arrayStr=formatter(data[key],data[key].map((_=>elType)));return acc[key]=Object.values(arrayStr).join(""),acc}return guard_isBN(data,type,key),acc[key]=decodeShortString(value),acc}if("number"===elType)return guard_isBN(data,type,key),acc[key]=Number(value),acc;if("function"==typeof elType)return acc[key]=elType(value),acc;if(Array.isArray(elType)){const arrayObj=formatter(data[key],elType,elType[0]);return acc[key]=Object.values(arrayObj),acc}return isObject(elType)?(acc[key]=formatter(data[key],elType),acc):(guard_unknown(data,type,key),acc)}),{})}var AbiParser1=class{abi;constructor(abi){this.abi=abi}methodInputsLength(abiMethod){return abiMethod.inputs.reduce(((acc,input)=>isLen(input.name)?acc:acc+1),0)}getMethod(name){return this.abi.find((it=>it.name===name))}getLegacyFormat(){return this.abi}},AbiParser2=class{abi;constructor(abi){this.abi=abi}methodInputsLength(abiMethod){return abiMethod.inputs.length}getMethod(name){const intf=this.abi.find((it=>"interface"===it.type));return intf?.items?.find((it=>it.name===name))}getLegacyFormat(){return this.abi.flatMap((it=>"interface"===it.type?it.items:it))}};function createAbiParser(abi){const version=function(abi){return abi.find((it=>"interface"===it.type))?2:isCairo1Abi(abi)?1:0}(abi);if(0===version||1===version)return new AbiParser1(abi);if(2===version)return new AbiParser2(abi);throw Error(`Unsupported ABI version ${version}`)}function isNoConstructorValid(method,argsCalldata,abiMethod){return"constructor"===method&&!abiMethod&&!argsCalldata.length}function getClosureOffset(input,open,close){for(let i=0,counter=0;i<input.length;i++)if(input[i]===open)counter++;else if(input[i]===close&&0==--counter)return i;return Number.POSITIVE_INFINITY}function extractTupleMemberTypes(type){return isCairo1Type(type)?function(type){const input=type.slice(1,-1),result=[];let limitIndex,currentIndex=0;for(;currentIndex<input.length;){switch(!0){case"("===input[currentIndex]:limitIndex=currentIndex+getClosureOffset(input.slice(currentIndex),"(",")")+1;break;case input.startsWith("core::result::Result::<",currentIndex)||input.startsWith("core::array::Array::<",currentIndex)||input.startsWith("core::option::Option::<",currentIndex):limitIndex=currentIndex+getClosureOffset(input.slice(currentIndex),"<",">")+1;break;default:{const commaIndex=input.indexOf(",",currentIndex);limitIndex=-1!==commaIndex?commaIndex:Number.POSITIVE_INFINITY}}result.push(input.slice(currentIndex,limitIndex)),currentIndex=limitIndex+2}return result}(type):function(type){const cleanType=type.replace(/\s/g,"").slice(1,-1),{subTuple,result}=function(s){if(!s.includes("("))return{subTuple:[],result:s};const subTuple=[];let result="",i=0;for(;i<s.length;){if("("===s[i]){let counter=1;const lBracket=i;for(i++;counter;)")"===s[i]&&counter--,"("===s[i]&&counter++,i++;subTuple.push(s.substring(lBracket,i)),result+=" ",i--}else result+=s[i];i++}return{subTuple,result}}(cleanType);let recomposed=result.split(",").map((it=>subTuple.length?it.replace(" ",subTuple.shift()):it));return isTypeNamedTuple(type)&&(recomposed=recomposed.reduce(((acc,it)=>acc.concat(function(namedTuple){const name=namedTuple.substring(0,namedTuple.indexOf(":"));return{name,type:namedTuple.substring(name.length+1)}}(it))),[])),recomposed}(type)}var CairoFixedArray=class _CairoFixedArray{content;arrayType;constructor(content,arrayType){assert(_CairoFixedArray.isTypeFixedArray(arrayType),`The type ${arrayType} is not a Cairo fixed array. Needs [type; length].`);try{_CairoFixedArray.getFixedArrayType(arrayType)}catch{throw new Error(`The type ${arrayType} do not includes any content type. Needs [type; length].`)}try{_CairoFixedArray.getFixedArraySize(arrayType)}catch{throw new Error(`The type ${arrayType} type do not includes any length. Needs [type; length].`)}assert(_CairoFixedArray.getFixedArraySize(arrayType)===content.length,`The ABI type ${arrayType} is expecting ${_CairoFixedArray.getFixedArraySize(arrayType)} items. ${content.length} items provided.`),this.content=content,this.arrayType=arrayType}static getFixedArraySize(type){const matchArray=type.match(/(?<=; )\d+(?=\])/);if(null===matchArray)throw new Error(`ABI type ${type} do not includes a valid number after ';' character.`);return Number(matchArray[0])}getFixedArraySize(){return _CairoFixedArray.getFixedArraySize(this.arrayType)}static getFixedArrayType=type=>{const matchArray=type.match(/(?<=\[).+(?=;)/);if(null===matchArray)throw new Error(`ABI type ${type} do not includes a valid type of data.`);return matchArray[0]};getFixedArrayType(){return _CairoFixedArray.getFixedArrayType(this.arrayType)}static compile(input){return input.reduce(((acc,item,idx)=>(acc[idx]=item,acc)),{})}compile(){return _CairoFixedArray.compile(this.content)}static isTypeFixedArray(type){return/^\[.*;\s.*\]$/.test(type)&&/(?<=\[).+(?=;)/.test(type)&&/(?<=; )\d+(?=\])/.test(type)}};function orderPropsByAbi(unorderedObject,abiOfObject,structs,enums){const orderInput=(unorderedItem,abiType)=>{if(CairoFixedArray.isTypeFixedArray(abiType))return function(input,abiParam){const typeInFixedArray=CairoFixedArray.getFixedArrayType(abiParam),arraySize=CairoFixedArray.getFixedArraySize(abiParam);if(Array.isArray(input)){if(arraySize!==input.length)throw new Error(`ABI type ${abiParam}: array provided do not includes  ${arraySize} items. ${input.length} items provided.`);return input.map((myElem=>orderInput(myElem,typeInFixedArray)))}if(arraySize!==Object.keys(input).length)throw new Error(`ABI type ${abiParam}: object provided do not includes  ${arraySize} properties. ${Object.keys(input).length} items provided.`);return orderInput(input,typeInFixedArray)}(unorderedItem,abiType);if(isTypeArray(abiType))return function(myArray,abiParam){const typeInArray=getArrayType(abiParam);if(isString(myArray))return myArray;return myArray.map((myElem=>orderInput(myElem,typeInArray)))}(unorderedItem,abiType);if(isTypeEnum(abiType,enums)){const abiObj=enums[abiType];return orderEnum(unorderedItem,abiObj)}if(isTypeTuple(abiType))return function(unorderedObject2,abiParam){const orderedObject2=extractTupleMemberTypes(abiParam).reduce(((orderedObject,abiTypeCairoX,index)=>{const myObjKeys=Object.keys(unorderedObject2),setProperty=value=>Object.defineProperty(orderedObject,index.toString(),{enumerable:!0,value:value??unorderedObject2[myObjKeys[index]]}),abiType=abiTypeCairoX?.type?abiTypeCairoX.type:abiTypeCairoX;return setProperty(orderInput(unorderedObject2[myObjKeys[index]],abiType)),orderedObject}),{});return orderedObject2}(unorderedItem,abiType);if(isTypeEthAddress(abiType))return unorderedItem;if(isTypeNonZero(abiType))return unorderedItem;if(isTypeByteArray(abiType))return unorderedItem;if(isTypeU96(abiType))return unorderedItem;if(isTypeSecp256k1Point(abiType))return unorderedItem;if(CairoUint256.isAbiType(abiType)){const u256=unorderedItem;if("object"!=typeof u256)return u256;if(!("low"in u256)||!("high"in u256))throw Error(`Your object includes the property : ${abiType}, containing an Uint256 object without the 'low' and 'high' keys.`);return{low:u256.low,high:u256.high}}if(CairoUint512.isAbiType(abiType)){const u512=unorderedItem;if("object"!=typeof u512)return u512;if(!["limb0","limb1","limb2","limb3"].every((key=>key in u512)))throw function(key){return Error(`Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`)}(abiType);return{limb0:u512.limb0,limb1:u512.limb1,limb2:u512.limb2,limb3:u512.limb3}}if(isTypeStruct(abiType,structs)){const abiOfStruct=structs[abiType].members;return orderStruct(unorderedItem,abiOfStruct)}return unorderedItem},orderStruct=(unorderedObject2,abiObject)=>abiObject.reduce(((orderedObject,abiParam)=>{if("undefined"===unorderedObject2[abiParam.name]&&(isCairo1Type(abiParam.type)||!isLen(abiParam.name)))throw Error(`Your object needs a property with key : ${abiParam.name} .`);var value;return value=orderInput(unorderedObject2[abiParam.name],abiParam.type),Object.defineProperty(orderedObject,abiParam.name,{enumerable:!0,value:value??unorderedObject2[abiParam.name]}),orderedObject}),{});const orderEnum=(unorderedObject2,abiObject)=>{if(isTypeResult(abiObject.name)){const unorderedResult=unorderedObject2,resultOkType=abiObject.name.substring(abiObject.name.indexOf("<")+1,abiObject.name.lastIndexOf(",")),resultErrType=abiObject.name.substring(abiObject.name.indexOf(",")+1,abiObject.name.lastIndexOf(">"));return unorderedResult.isOk()?new CairoResult(CairoResultVariant.Ok,orderInput(unorderedObject2.unwrap(),resultOkType)):new CairoResult(CairoResultVariant.Err,orderInput(unorderedObject2.unwrap(),resultErrType))}if(isTypeOption(abiObject.name)){const unorderedOption=unorderedObject2,resultSomeType=abiObject.name.substring(abiObject.name.indexOf("<")+1,abiObject.name.lastIndexOf(">"));return unorderedOption.isSome()?new CairoOption(CairoOptionVariant.Some,orderInput(unorderedOption.unwrap(),resultSomeType)):new CairoOption(CairoOptionVariant.None,{})}const unorderedCustomEnum=unorderedObject2,newEntries=Object.entries(unorderedCustomEnum.variant).map((variant=>{if(isUndefined(variant[1]))return variant;const variantType=abiObject.type.substring(abiObject.type.lastIndexOf("<")+1,abiObject.type.lastIndexOf(">"));return"()"===variantType?variant:[variant[0],orderInput(unorderedCustomEnum.unwrap(),variantType)]}));return new CairoCustomEnum(Object.fromEntries(newEntries))};return abiOfObject.reduce(((orderedObject,abiParam)=>{return isLen(abiParam.name)&&!isCairo1Type(abiParam.type)||(value=orderInput(unorderedObject[abiParam.name],abiParam.type),Object.defineProperty(orderedObject,abiParam.name,{enumerable:!0,value})),orderedObject;var value}),{})}function parseBaseTypes(type,val){switch(!0){case CairoUint256.isAbiType(type):return new CairoUint256(val).toApiRequest();case CairoUint512.isAbiType(type):return new CairoUint512(val).toApiRequest();case isTypeBytes31(type):return encodeShortString(val.toString());case isTypeSecp256k1Point(type):{const pubKeyETH=removeHexPrefix(toHex(val)).padStart(128,"0"),pubKeyETHy=uint256(addHexPrefix(pubKeyETH.slice(-64))),pubKeyETHx=uint256(addHexPrefix(pubKeyETH.slice(0,-64)));return[felt(pubKeyETHx.low),felt(pubKeyETHx.high),felt(pubKeyETHy.low),felt(pubKeyETHy.high)]}default:return felt(val)}}function parseCalldataValue(element,type,structs,enums){if(void 0===element)throw Error(`Missing parameter for type ${type}`);if(CairoFixedArray.isTypeFixedArray(type)){const arrayType=CairoFixedArray.getFixedArrayType(type);let values=[];if(Array.isArray(element)){values=new CairoFixedArray(element,type).content}else{if("object"!=typeof element)throw new Error(`ABI type ${type}: not an Array representing a cairo.fixedArray() provided.`);values=Object.values(element),assert(values.length===CairoFixedArray.getFixedArraySize(type),`ABI type ${type}: object provided do not includes  ${CairoFixedArray.getFixedArraySize(type)} items. ${values.length} items provided.`)}return values.reduce(((acc,it)=>acc.concat(parseCalldataValue(it,arrayType,structs,enums))),[])}if(Array.isArray(element)){const result=[];result.push(felt(element.length));const arrayType=getArrayType(type);return element.reduce(((acc,it)=>acc.concat(parseCalldataValue(it,arrayType,structs,enums))),result)}if(structs[type]&&structs[type].members.length){if(CairoUint256.isAbiType(type))return new CairoUint256(element).toApiRequest();if(CairoUint512.isAbiType(type))return new CairoUint512(element).toApiRequest();if(isTypeEthAddress(type))return parseBaseTypes(type,element);if(isTypeByteArray(type))return function(element){const myByteArray=byteArrayFromString(element);return[myByteArray.data.length.toString(),...myByteArray.data.map((bn=>bn.toString())),myByteArray.pending_word.toString(),myByteArray.pending_word_len.toString()]}(element);const{members}=structs[type],subElement=element;return members.reduce(((acc,it)=>acc.concat(parseCalldataValue(subElement[it.name],it.type,structs,enums))),[])}if(isTypeTuple(type)){const tupled=function(element,typeStr){const memberTypes=extractTupleMemberTypes(typeStr),elements=Object.values(element);if(elements.length!==memberTypes.length)throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements}\n      expected: ${memberTypes}`);return memberTypes.map(((it,dx)=>({element:elements[dx],type:it.type??it})))}(element,type);return tupled.reduce(((acc,it)=>{const parsedData=parseCalldataValue(it.element,it.type,structs,enums);return acc.concat(parsedData)}),[])}if(CairoUint256.isAbiType(type))return new CairoUint256(element).toApiRequest();if(CairoUint512.isAbiType(type))return new CairoUint512(element).toApiRequest();if(isTypeEnum(type,enums)){const{variants}=enums[type];if(isTypeOption(type)){const myOption=element;if(myOption.isSome()){const listTypeVariant2=variants.find((variant=>"Some"===variant.name));if(isUndefined(listTypeVariant2))throw Error("Error in abi : Option has no 'Some' variant.");const typeVariantSome=listTypeVariant2.type;if("()"===typeVariantSome)return CairoOptionVariant.Some.toString();const parsedParameter2=parseCalldataValue(myOption.unwrap(),typeVariantSome,structs,enums);return Array.isArray(parsedParameter2)?[CairoOptionVariant.Some.toString(),...parsedParameter2]:[CairoOptionVariant.Some.toString(),parsedParameter2]}return CairoOptionVariant.None.toString()}if(isTypeResult(type)){const myResult=element;if(myResult.isOk()){const listTypeVariant3=variants.find((variant=>"Ok"===variant.name));if(isUndefined(listTypeVariant3))throw Error("Error in abi : Result has no 'Ok' variant.");const typeVariantOk=listTypeVariant3.type;if("()"===typeVariantOk)return CairoResultVariant.Ok.toString();const parsedParameter3=parseCalldataValue(myResult.unwrap(),typeVariantOk,structs,enums);return Array.isArray(parsedParameter3)?[CairoResultVariant.Ok.toString(),...parsedParameter3]:[CairoResultVariant.Ok.toString(),parsedParameter3]}const listTypeVariant2=variants.find((variant=>"Err"===variant.name));if(isUndefined(listTypeVariant2))throw Error("Error in abi : Result has no 'Err' variant.");const typeVariantErr=listTypeVariant2.type;if("()"===typeVariantErr)return CairoResultVariant.Err.toString();const parsedParameter2=parseCalldataValue(myResult.unwrap(),typeVariantErr,structs,enums);return Array.isArray(parsedParameter2)?[CairoResultVariant.Err.toString(),...parsedParameter2]:[CairoResultVariant.Err.toString(),parsedParameter2]}const myEnum=element,activeVariant=myEnum.activeVariant(),listTypeVariant=variants.find((variant=>variant.name===activeVariant));if(isUndefined(listTypeVariant))throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);const typeActiveVariant=listTypeVariant.type,numActiveVariant=variants.findIndex((variant=>variant.name===activeVariant));if("()"===typeActiveVariant)return numActiveVariant.toString();const parsedParameter=parseCalldataValue(myEnum.unwrap(),typeActiveVariant,structs,enums);return Array.isArray(parsedParameter)?[numActiveVariant.toString(),...parsedParameter]:[numActiveVariant.toString(),parsedParameter]}if(isTypeNonZero(type))return parseBaseTypes(getArrayType(type),element);if("object"==typeof element)throw Error(`Parameter ${element} do not align with abi parameter ${type}`);return parseBaseTypes(type,element)}function parseCalldataField(argsIterator,input,structs,enums){const{name,type}=input;let{value}=argsIterator.next();switch(!0){case CairoFixedArray.isTypeFixedArray(type):if(!Array.isArray(value)&&"object"!=typeof value)throw Error(`ABI expected parameter ${name} to be an array or an object, got ${value}`);return parseCalldataValue(value,input.type,structs,enums);case isTypeArray(type):if(!Array.isArray(value)&&!isText(value))throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);return isString(value)&&(value=splitLongString(value)),parseCalldataValue(value,input.type,structs,enums);case isTypeNonZero(type):return parseBaseTypes(getArrayType(type),value);case isTypeEthAddress(type):return parseBaseTypes(type,value);case isTypeStruct(type,structs)||isTypeTuple(type)||CairoUint256.isAbiType(type):case isTypeEnum(type,enums):return parseCalldataValue(value,type,structs,enums);default:return parseBaseTypes(type,value)}}function parseBaseTypes2(type,it){let temp;switch(!0){case isTypeBool(type):return temp=it.next().value,Boolean(BigInt(temp));case CairoUint256.isAbiType(type):const low=it.next().value,high=it.next().value;return new CairoUint256(low,high).toBigInt();case CairoUint512.isAbiType(type):const limb0=it.next().value,limb1=it.next().value,limb2=it.next().value,limb3=it.next().value;return new CairoUint512(limb0,limb1,limb2,limb3).toBigInt();case isTypeEthAddress(type):return temp=it.next().value,BigInt(temp);case isTypeBytes31(type):return temp=it.next().value,decodeShortString(temp);case isTypeSecp256k1Point(type):const xLow=removeHexPrefix(it.next().value).padStart(32,"0"),xHigh=removeHexPrefix(it.next().value).padStart(32,"0"),yLow=removeHexPrefix(it.next().value).padStart(32,"0"),yHigh=removeHexPrefix(it.next().value).padStart(32,"0");return BigInt(addHexPrefix(xHigh+xLow+yHigh+yLow));default:return temp=it.next().value,BigInt(temp)}}function parseResponseValue(responseIterator,element,structs,enums){if("()"===element.type)return{};if(CairoUint256.isAbiType(element.type)){const low=responseIterator.next().value,high=responseIterator.next().value;return new CairoUint256(low,high).toBigInt()}if(CairoUint512.isAbiType(element.type)){const limb0=responseIterator.next().value,limb1=responseIterator.next().value,limb2=responseIterator.next().value,limb3=responseIterator.next().value;return new CairoUint512(limb0,limb1,limb2,limb3).toBigInt()}if(isTypeByteArray(element.type)){const parsedBytes31Arr=[],bytes31ArrLen=BigInt(responseIterator.next().value);for(;parsedBytes31Arr.length<bytes31ArrLen;)parsedBytes31Arr.push(toHex(responseIterator.next().value));return stringFromByteArray({data:parsedBytes31Arr,pending_word:toHex(responseIterator.next().value),pending_word_len:BigInt(responseIterator.next().value)})}if(CairoFixedArray.isTypeFixedArray(element.type)){const parsedDataArr=[],el={name:"",type:CairoFixedArray.getFixedArrayType(element.type)},arraySize=CairoFixedArray.getFixedArraySize(element.type);for(;parsedDataArr.length<arraySize;)parsedDataArr.push(parseResponseValue(responseIterator,el,structs,enums));return parsedDataArr}if(isTypeArray(element.type)){const parsedDataArr=[],el={name:"",type:getArrayType(element.type)},len=BigInt(responseIterator.next().value);for(;parsedDataArr.length<len;)parsedDataArr.push(parseResponseValue(responseIterator,el,structs,enums));return parsedDataArr}if(isTypeNonZero(element.type)){const el={name:"",type:getArrayType(element.type)};return parseResponseValue(responseIterator,el,structs,enums)}if(structs&&element.type in structs&&structs[element.type])return isTypeEthAddress(element.type)?parseBaseTypes2(element.type,responseIterator):structs[element.type].members.reduce(((acc,el)=>(acc[el.name]=parseResponseValue(responseIterator,el,structs,enums),acc)),{});if(enums&&element.type in enums&&enums[element.type]){const variantNum=Number(responseIterator.next().value),rawEnum=enums[element.type].variants.reduce(((acc,variant,num)=>num===variantNum?(acc[variant.name]=parseResponseValue(responseIterator,{name:"",type:variant.type},structs,enums),acc):(acc[variant.name]=void 0,acc)),{});if(element.type.startsWith("core::option::Option")){const content=variantNum===CairoOptionVariant.Some?rawEnum.Some:void 0;return new CairoOption(variantNum,content)}if(element.type.startsWith("core::result::Result")){let content;return content=variantNum===CairoResultVariant.Ok?rawEnum.Ok:rawEnum.Err,new CairoResult(variantNum,content)}return new CairoCustomEnum(rawEnum)}if(isTypeTuple(element.type)){return extractTupleMemberTypes(element.type).reduce(((acc,it,idx)=>{const name=it?.name?it.name:idx,el={name,type:it?.type?it.type:it};return acc[name]=parseResponseValue(responseIterator,el,structs,enums),acc}),{})}if(isTypeArray(element.type)){const parsedDataArr=[],el={name:"",type:getArrayType(element.type)},len=BigInt(responseIterator.next().value);for(;parsedDataArr.length<len;)parsedDataArr.push(parseResponseValue(responseIterator,el,structs,enums));return parsedDataArr}return parseBaseTypes2(element.type,responseIterator)}function responseParser(responseIterator,output,structs,enums,parsedResult){const{name,type}=output;let temp;switch(!0){case isLen(name):return temp=responseIterator.next().value,BigInt(temp);case structs&&type in structs||isTypeTuple(type):case enums&&isTypeEnum(type,enums):case CairoFixedArray.isTypeFixedArray(type):return parseResponseValue(responseIterator,output,structs,enums);case isTypeArray(type):if(isCairo1Type(type))return parseResponseValue(responseIterator,output,structs,enums);const parsedDataArr=[];if(parsedResult&&parsedResult[`${name}_len`]){const arrLen=parsedResult[`${name}_len`];for(;parsedDataArr.length<arrLen;)parsedDataArr.push(parseResponseValue(responseIterator,{name,type:output.type.replace("*","")},structs,enums))}return parsedDataArr;case isTypeNonZero(type):return parseResponseValue(responseIterator,output,structs,enums);default:return parseBaseTypes2(type,responseIterator)}}var validateFelt=(parameter,input)=>{if(assert(isString(parameter)||isNumber(parameter)||isBigInt(parameter),`Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`),isString(parameter)&&!isHex(parameter))return;const param=BigInt(parameter.toString(10));assert(param>=0n&&param<=2n**252n-1n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`)},validateUint=(parameter,input)=>{let param;switch(isNumber(parameter)&&assert(parameter<=Number.MAX_SAFE_INTEGER,"Validation: Parameter is too large to be typed as Number use (BigInt or String)"),assert(isString(parameter)||isNumber(parameter)||isBigInt(parameter)||isObject(parameter)&&"low"in parameter&&"high"in parameter||isObject(parameter)&&["limb0","limb1","limb2","limb3"].every((key=>key in parameter)),`Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`),input.type){case Uint.u256:param=new CairoUint256(parameter).toBigInt();break;case Uint.u512:param=new CairoUint512(parameter).toBigInt();break;default:param=toBigInt(parameter)}switch(input.type){case Uint.u8:assert(param>=0n&&param<=255n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);break;case Uint.u16:assert(param>=0n&&param<=65535n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);break;case Uint.u32:assert(param>=0n&&param<=4294967295n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);break;case Uint.u64:assert(param>=0n&&param<=2n**64n-1n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);break;case Uint.u128:assert(param>=0n&&param<=2n**128n-1n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);break;case Uint.u256:assert(param>=0n&&param<=2n**256n-1n,`Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^256-1`);break;case Uint.u512:assert(CairoUint512.is(param),`Validate: arg ${input.name} is ${input.type} should be in range 0 - 2^512-1`);break;case Literal.ClassHash:case Literal.ContractAddress:assert(param>=0n&&param<=2n**252n-1n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);break;case Literal.Secp256k1Point:assert(param>=0n&&param<=2n**512n-1n,`Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`);break;case Literal.U96:assert(param>=0n&&param<=2n**96n-1n,`Validate: arg ${input.name} must be ${input.type} : a 96 bits number.`)}},validateBool=(parameter,input)=>{assert(isBoolean(parameter),`Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`)},validateStruct=(parameter,input,structs)=>{if(input.type!==Uint.u256&&input.type!==Uint.u512)if(isTypeEthAddress(input.type)){assert(!isObject(parameter),`EthAddress type is waiting a BigNumberish. Got "${parameter}"`);const param=BigInt(parameter.toString(10));assert(param>=0n&&param<=2n**160n-1n,`Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`)}else assert(isObject(parameter),`Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as a js object (not array)`),structs[input.type].members.forEach((({name})=>{assert(Object.keys(parameter).includes(name),`Validate: arg ${input.name} should have a property ${name}`)}));else validateUint(parameter,input)},validateEnum=(parameter,input)=>{assert(isObject(parameter),`Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as a js object (not array)`);const methodsKeys=Object.getOwnPropertyNames(Object.getPrototypeOf(parameter)),keys=[...Object.getOwnPropertyNames(parameter),...methodsKeys];if(!(isTypeOption(input.type)&&keys.includes("isSome")&&keys.includes("isNone")||isTypeResult(input.type)&&keys.includes("isOk")&&keys.includes("isErr")||keys.includes("variant")&&keys.includes("activeVariant")))throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received "${parameter}", is not an Enum.`)},validateTuple=(parameter,input)=>{assert(isObject(parameter),`Validate: arg ${input.name} should be a tuple (defined as object)`)},validateArray=(parameterArray,input,structs,enums)=>{const isNormalArray=isTypeArray(input.type),baseType=isNormalArray?getArrayType(input.type):CairoFixedArray.getFixedArrayType(input.type);if(isNormalArray&&isTypeFelt(baseType)&&isLongText(parameterArray))return;let parameter=[];if(isNormalArray)assert(Array.isArray(parameterArray),`Validate: arg ${input.name} should be an Array`),parameter=parameterArray;else switch(!0){case Array.isArray(parameterArray):parameter=parameterArray;break;case"object"==typeof parameterArray:parameter=Object.values(parameterArray);break;default:throw new Error(`Validate: arg ${input.name} should be an Array or an object.`)}switch(!0){case isTypeFelt(baseType):parameter.forEach((param=>validateFelt(param,input)));break;case isTypeTuple(baseType):parameter.forEach((it=>validateTuple(it,{name:input.name,type:baseType})));break;case isTypeArray(baseType):parameter.forEach((param=>validateArray(param,{name:"",type:baseType},structs,enums)));break;case isTypeStruct(baseType,structs):parameter.forEach((it=>validateStruct(it,{name:input.name,type:baseType},structs)));break;case isTypeEnum(baseType,enums):parameter.forEach((it=>validateEnum(it,{name:input.name,type:baseType})));break;case isTypeUint(baseType)||isTypeLiteral(baseType):parameter.forEach((param=>validateUint(param,{name:"",type:baseType})));break;case isTypeBool(baseType):parameter.forEach((param=>validateBool(param,input)));break;default:throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`)}};function validateFields(abiMethod,args,structs,enums){abiMethod.inputs.reduce(((acc,input)=>{const parameter=args[acc];switch(!0){case isLen(input.name):return acc;case isTypeFelt(input.type):validateFelt(parameter,input);break;case isTypeBytes31(input.type):((parameter,input)=>{assert(isString(parameter),`Validate: arg ${input.name} should be a string.`),assert(parameter.length<32,`Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`)})(parameter,input);break;case isTypeUint(input.type)||isTypeLiteral(input.type):validateUint(parameter,input);break;case isTypeBool(input.type):validateBool(parameter,input);break;case isTypeByteArray(input.type):((parameter,input)=>{assert(isString(parameter),`Validate: arg ${input.name} should be a string.`)})(parameter,input);break;case isTypeArray(input.type)||CairoFixedArray.isTypeFixedArray(input.type):validateArray(parameter,input,structs,enums);break;case isTypeStruct(input.type,structs):validateStruct(parameter,input,structs);break;case isTypeEnum(input.type,enums):validateEnum(parameter,input);break;case isTypeTuple(input.type):validateTuple(parameter,input);break;case isTypeNonZero(input.type):((parameter,input)=>{const baseType=getArrayType(input.type);switch(assert(isTypeUint(baseType)&&baseType!==CairoUint512.abiSelector||isTypeFelt(baseType),`Validate: ${input.name} type is not authorized for NonZero type.`),!0){case isTypeFelt(baseType):validateFelt(parameter,input),assert(BigInt(parameter.toString(10))>0,"Validate: value 0 is not authorized in NonZero felt252 type.");break;case isTypeUint(baseType):validateUint(parameter,{name:"",type:baseType}),baseType===Uint.u256?assert(new CairoUint256(parameter).toBigInt()>0,"Validate: value 0 is not authorized in NonZero uint256 type."):assert(toBigInt(parameter)>0,"Validate: value 0 is not authorized in NonZero uint type.");break;default:throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value "${parameter}"`)}})(parameter,input);break;default:throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`)}return acc+1}),0)}var CallData=class _CallData{abi;parser;structs;enums;constructor(abi){this.structs=_CallData.getAbiStruct(abi),this.enums=_CallData.getAbiEnum(abi),this.parser=createAbiParser(abi),this.abi=this.parser.getLegacyFormat()}validate(type,method,args=[]){if(type!==ValidateType.DEPLOY){assert(this.abi.filter((abi=>{if("function"!==abi.type)return!1;const isView="view"===abi.stateMutability||"view"===abi.state_mutability;return type===ValidateType.INVOKE?!isView:isView})).map((abi=>abi.name)).includes(method),(type===ValidateType.INVOKE?"invocable":"viewable")+" method not found in abi")}const abiMethod=this.abi.find((abi=>type===ValidateType.DEPLOY?abi.name===method&&"constructor"===abi.type:abi.name===method&&"function"===abi.type));if(isNoConstructorValid(method,args,abiMethod))return;const inputsLength=this.parser.methodInputsLength(abiMethod);if(args.length!==inputsLength)throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);validateFields(abiMethod,args,this.structs,this.enums)}compile(method,argsCalldata){const abiMethod=this.abi.find((abiFunction=>abiFunction.name===method));if(isNoConstructorValid(method,argsCalldata,abiMethod))return[];let args;if(Array.isArray(argsCalldata))args=argsCalldata;else{const orderedObject=orderPropsByAbi(argsCalldata,abiMethod.inputs,this.structs,this.enums);args=Object.values(orderedObject),validateFields(abiMethod,args,this.structs,this.enums)}const argsIterator=args[Symbol.iterator](),callArray=abiMethod.inputs.reduce(((acc,input)=>isLen(input.name)&&!isCairo1Type(input.type)?acc:acc.concat(parseCalldataField(argsIterator,input,this.structs,this.enums))),[]);return Object.defineProperty(callArray,"__compiled__",{enumerable:!1,writable:!1,value:!0}),callArray}static compile(rawArgs){const createTree=obj=>{const getEntries=(o,prefix=".")=>{const oe=Array.isArray(o)?[o.length.toString(),...o]:o;return Object.entries(oe).flatMap((([k,v])=>{let value=v;"entrypoint"===k?value=getSelectorFromName(value):isLongText(value)&&(value=byteArrayFromString(value));const kk=Array.isArray(oe)&&"0"===k?"$$len":k;if(isBigInt(value))return[[`${prefix}${kk}`,felt(value)]];if(Object(value)===value){const methodsKeys=Object.getOwnPropertyNames(Object.getPrototypeOf(value)),keys=[...Object.getOwnPropertyNames(value),...methodsKeys];if(keys.includes("isSome")&&keys.includes("isNone")){const myOption=value,variantNb=myOption.isSome()?CairoOptionVariant.Some:CairoOptionVariant.None;return myOption.isSome()?getEntries({0:variantNb,1:myOption.unwrap()},`${prefix}${kk}.`):[[`${prefix}${kk}`,felt(variantNb)]]}if(keys.includes("isOk")&&keys.includes("isErr")){const myResult=value,variantNb=myResult.isOk()?CairoResultVariant.Ok:CairoResultVariant.Err;return getEntries({0:variantNb,1:myResult.unwrap()},`${prefix}${kk}.`)}if(keys.includes("variant")&&keys.includes("activeVariant")){const myEnum=value,activeVariant=myEnum.activeVariant(),activeVariantNb=Object.keys(myEnum.variant).findIndex((variant=>variant===activeVariant));return"object"==typeof myEnum.unwrap()&&0===Object.keys(myEnum.unwrap()).length?[[`${prefix}${kk}`,felt(activeVariantNb)]]:getEntries({0:activeVariantNb,1:myEnum.unwrap()},`${prefix}${kk}.`)}return getEntries(value,`${prefix}${kk}.`)}return[[`${prefix}${kk}`,felt(value)]]}))};return Object.fromEntries(getEntries(obj))};let callTreeArray;if(Array.isArray(rawArgs)){const callTree=createTree({...rawArgs});callTreeArray=Object.values(callTree)}else{const callTree=createTree(rawArgs);callTreeArray=Object.values(callTree)}return Object.defineProperty(callTreeArray,"__compiled__",{enumerable:!1,writable:!1,value:!0}),callTreeArray}parse(method,response){const{outputs}=this.abi.find((abi=>abi.name===method)),responseIterator=response.flat()[Symbol.iterator](),parsed=outputs.flat().reduce(((acc,output,idx)=>{const propName=output.name??idx;return acc[propName]=responseParser(responseIterator,output,this.structs,this.enums,acc),acc[propName]&&acc[`${propName}_len`]&&delete acc[`${propName}_len`],acc}),{});return 1===Object.keys(parsed).length&&0 in parsed?parsed[0]:parsed}format(method,response,format){return formatter(this.parse(method,response),format)}static getAbiStruct(abi){return abi.filter((abiEntry=>"struct"===abiEntry.type)).reduce(((acc,abiEntry)=>({...acc,[abiEntry.name]:abiEntry})),{})}static getAbiEnum(abi){const fullEnumList=abi.filter((abiEntry=>"enum"===abiEntry.type)).reduce(((acc,abiEntry)=>({...acc,[abiEntry.name]:abiEntry})),{});return delete fullEnumList["core::bool"],fullEnumList}static toCalldata(rawCalldata=[]){return _CallData.compile(rawCalldata)}static toHex(raw=[]){return _CallData.compile(raw).map((it=>toHex(it)))}decodeParameters(typeCairo,response){const typeCairoArray=Array.isArray(typeCairo)?typeCairo:[typeCairo],responseIterator=response.flat()[Symbol.iterator](),decodedArray=typeCairoArray.map((typeParam=>responseParser(responseIterator,{name:"",type:typeParam},this.structs,this.enums)));return 1===decodedArray.length?decodedArray[0]:decodedArray}},hash_exports={};__export(hash_exports,{calculateContractAddressFromHash:()=>calculateContractAddressFromHash,calculateDeclareTransactionHash:()=>calculateDeclareTransactionHash3,calculateDeployAccountTransactionHash:()=>calculateDeployAccountTransactionHash3,calculateInvokeTransactionHash:()=>calculateInvokeTransactionHash2,calculateL2MessageTxHash:()=>calculateL2MessageTxHash,computeCompiledClassHash:()=>computeCompiledClassHash,computeContractClassHash:()=>computeContractClassHash,computeHashOnElements:()=>computeHashOnElements2,computeHintedClassHash:()=>computeHintedClassHash,computeLegacyContractClassHash:()=>computeLegacyContractClassHash,computePedersenHash:()=>computePedersenHash,computePedersenHashOnElements:()=>computePedersenHashOnElements,computePoseidonHash:()=>computePoseidonHash,computePoseidonHashOnElements:()=>computePoseidonHashOnElements,computeSierraContractClassHash:()=>computeSierraContractClassHash,formatSpaces:()=>formatSpaces,getL1MessageHash:()=>getL1MessageHash,getL2MessageHash:()=>getL2MessageHash,getSelector:()=>getSelector,getSelectorFromName:()=>getSelectorFromName,hashByteCodeSegments:()=>hashByteCodeSegments,keccakBn:()=>keccakBn,poseidon:()=>poseidon,solidityUint256PackedKeccak256:()=>solidityUint256PackedKeccak256,starknetKeccak:()=>starknetKeccak});var poseidon=__toESM(__webpack_require__(45920)),v2_exports={};__export(v2_exports,{calculateDeclareTransactionHash:()=>calculateDeclareTransactionHash,calculateDeployAccountTransactionHash:()=>calculateDeployAccountTransactionHash,calculateL2MessageTxHash:()=>calculateL2MessageTxHash,calculateTransactionHash:()=>calculateTransactionHash,calculateTransactionHashCommon:()=>calculateTransactionHashCommon,computeHashOnElements:()=>computeHashOnElements});var ec_exports={};__export(ec_exports,{starkCurve:()=>starkCurve,weierstrass:()=>weierstrass});var starkCurve=__toESM(__webpack_require__(4246)),weierstrass=__toESM(__webpack_require__(91705));function computeHashOnElements(data){return[...data,data.length].reduce(((x,y)=>starkCurve.pedersen(toBigInt(x),toBigInt(y))),0).toString()}function calculateTransactionHashCommon(txHashPrefix,version,contractAddress,entryPointSelector,calldata,maxFee,chainId,additionalData=[]){const calldataHash=computeHashOnElements(calldata);return computeHashOnElements([txHashPrefix,version,contractAddress,entryPointSelector,calldataHash,maxFee,chainId,...additionalData])}function calculateDeclareTransactionHash(classHash,senderAddress,version,maxFee,chainId,nonce,compiledClassHash){return calculateTransactionHashCommon(_TransactionHashPrefix.DECLARE,version,senderAddress,0,[classHash],maxFee,chainId,[nonce,...compiledClassHash?[compiledClassHash]:[]])}function calculateDeployAccountTransactionHash(contractAddress,classHash,constructorCalldata,salt,version,maxFee,chainId,nonce){const calldata=[classHash,salt,...constructorCalldata];return calculateTransactionHashCommon(_TransactionHashPrefix.DEPLOY_ACCOUNT,version,contractAddress,0,calldata,maxFee,chainId,[nonce])}function calculateTransactionHash(contractAddress,version,calldata,maxFee,chainId,nonce){return calculateTransactionHashCommon(_TransactionHashPrefix.INVOKE,version,contractAddress,0,calldata,maxFee,chainId,[nonce])}function calculateL2MessageTxHash(l1FromAddress,l2ToAddress,l2Selector,l2Calldata,l2ChainId,l1Nonce){const payload=[l1FromAddress,...l2Calldata];return calculateTransactionHashCommon(_TransactionHashPrefix.L1_HANDLER,0,l2ToAddress,getSelector(l2Selector),payload,0,l2ChainId,[l1Nonce])}var v3_exports={};__export(v3_exports,{calculateDeclareTransactionHash:()=>calculateDeclareTransactionHash2,calculateDeployAccountTransactionHash:()=>calculateDeployAccountTransactionHash2,calculateInvokeTransactionHash:()=>calculateInvokeTransactionHash,calculateTransactionHashCommon:()=>calculateTransactionHashCommon2,encodeDataResourceBoundsL1:()=>encodeDataResourceBoundsL1,encodeResourceBoundsL1:()=>encodeResourceBoundsL1,encodeResourceBoundsL2:()=>encodeResourceBoundsL2,hashDAMode:()=>hashDAMode,hashFeeField:()=>hashFeeField,hashFeeFieldV3B3:()=>hashFeeFieldV3B3});var import_starknet2=__webpack_require__(4246),AToBI=array=>array.map((it=>BigInt(it))),DATA_AVAILABILITY_MODE_BITS=32n,MAX_PRICE_PER_UNIT_BITS=128n,RESOURCE_VALUE_OFFSET=64n+MAX_PRICE_PER_UNIT_BITS,L1_GAS_NAME=BigInt(encodeShortString("L1_GAS")),L2_GAS_NAME=BigInt(encodeShortString("L2_GAS")),L1_DATA_GAS_NAME=BigInt(encodeShortString("L1_DATA"));function hashDAMode(nonceDAMode,feeDAMode){return(BigInt(nonceDAMode)<<DATA_AVAILABILITY_MODE_BITS)+BigInt(feeDAMode)}function encodeResourceBoundsL1(bounds){return(L1_GAS_NAME<<RESOURCE_VALUE_OFFSET)+(BigInt(bounds.l1_gas.max_amount)<<MAX_PRICE_PER_UNIT_BITS)+BigInt(bounds.l1_gas.max_price_per_unit)}function encodeResourceBoundsL2(bounds){return(L2_GAS_NAME<<RESOURCE_VALUE_OFFSET)+(BigInt(bounds.l2_gas.max_amount)<<MAX_PRICE_PER_UNIT_BITS)+BigInt(bounds.l2_gas.max_price_per_unit)}function encodeDataResourceBoundsL1(bounds){return(L1_DATA_GAS_NAME<<RESOURCE_VALUE_OFFSET)+(BigInt(bounds.l1_data_gas.max_amount)<<MAX_PRICE_PER_UNIT_BITS)+BigInt(bounds.l1_data_gas.max_price_per_unit)}function hashFeeField(tip,bounds){const L1Bound=encodeResourceBoundsL1(bounds),L2Bound=encodeResourceBoundsL2(bounds);return(0,import_starknet2.poseidonHashMany)([BigInt(tip),L1Bound,L2Bound])}function hashFeeFieldV3B3(tip,bounds){const L1Bound=encodeResourceBoundsL1(bounds),L2Bound=encodeResourceBoundsL2(bounds),L1Data=encodeDataResourceBoundsL1(bounds);return(0,import_starknet2.poseidonHashMany)([BigInt(tip),L1Bound,L2Bound,L1Data])}function calculateTransactionHashCommon2(txHashPrefix,version,senderAddress,chainId,nonce,tip,paymasterData,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,additionalData=[]){const feeFieldHash=isRPC08_ResourceBounds(resourceBounds)?hashFeeFieldV3B3(tip,resourceBounds):hashFeeField(tip,resourceBounds),dAModeHash=hashDAMode(nonceDataAvailabilityMode,feeDataAvailabilityMode),dataToHash=AToBI([txHashPrefix,version,senderAddress,feeFieldHash,(0,import_starknet2.poseidonHashMany)(AToBI(paymasterData)),chainId,nonce,dAModeHash,...AToBI(additionalData)]);return toHex((0,import_starknet2.poseidonHashMany)(dataToHash))}function calculateDeployAccountTransactionHash2(contractAddress,classHash,compiledConstructorCalldata,salt,version,chainId,nonce,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,tip,paymasterData){return calculateTransactionHashCommon2(_TransactionHashPrefix.DEPLOY_ACCOUNT,version,contractAddress,chainId,nonce,tip,paymasterData,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,[(0,import_starknet2.poseidonHashMany)(AToBI(compiledConstructorCalldata)),classHash,salt])}function calculateDeclareTransactionHash2(classHash,compiledClassHash,senderAddress,version,chainId,nonce,accountDeploymentData,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,tip,paymasterData){return calculateTransactionHashCommon2(_TransactionHashPrefix.DECLARE,version,senderAddress,chainId,nonce,tip,AToBI(paymasterData),nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,[(0,import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)),classHash,compiledClassHash])}function calculateInvokeTransactionHash(senderAddress,version,compiledCalldata,chainId,nonce,accountDeploymentData,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,tip,paymasterData){return calculateTransactionHashCommon2(_TransactionHashPrefix.INVOKE,version,senderAddress,chainId,nonce,tip,paymasterData,nonceDataAvailabilityMode,feeDataAvailabilityMode,resourceBounds,[(0,import_starknet2.poseidonHashMany)(AToBI(accountDeploymentData)),(0,import_starknet2.poseidonHashMany)(AToBI(compiledCalldata))])}function calculateInvokeTransactionHash2(args){return function(args){return[api_exports.ETransactionVersion.V3,api_exports.ETransactionVersion.F3].includes(args.version)}(args)?calculateInvokeTransactionHash(args.senderAddress,args.version,args.compiledCalldata,args.chainId,args.nonce,args.accountDeploymentData,args.nonceDataAvailabilityMode,args.feeDataAvailabilityMode,args.resourceBounds,args.tip,args.paymasterData):calculateTransactionHash(args.senderAddress,args.version,args.compiledCalldata,args.maxFee,args.chainId,args.nonce)}function calculateDeclareTransactionHash3(args){return function(args){return[api_exports.ETransactionVersion.V3,api_exports.ETransactionVersion.F3].includes(args.version)}(args)?calculateDeclareTransactionHash2(args.classHash,args.compiledClassHash,args.senderAddress,args.version,args.chainId,args.nonce,args.accountDeploymentData,args.nonceDataAvailabilityMode,args.feeDataAvailabilityMode,args.resourceBounds,args.tip,args.paymasterData):calculateDeclareTransactionHash(args.classHash,args.senderAddress,args.version,args.maxFee,args.chainId,args.nonce,args.compiledClassHash)}function calculateDeployAccountTransactionHash3(args){return function(args){return[api_exports.ETransactionVersion.V3,api_exports.ETransactionVersion.F3].includes(args.version)}(args)?calculateDeployAccountTransactionHash2(args.contractAddress,args.classHash,args.compiledConstructorCalldata,args.salt,args.version,args.chainId,args.nonce,args.nonceDataAvailabilityMode,args.feeDataAvailabilityMode,args.resourceBounds,args.tip,args.paymasterData):calculateDeployAccountTransactionHash(args.contractAddress,args.classHash,args.constructorCalldata,args.salt,args.version,args.maxFee,args.chainId,args.nonce)}var import_starknet3=__webpack_require__(4246);function computePedersenHash(a,b){return starkCurve.pedersen(BigInt(a),BigInt(b))}function computePoseidonHash(a,b){return toHex(starkCurve.poseidonHash(BigInt(a),BigInt(b)))}function computeHashOnElements2(data){return[...data,data.length].reduce(((x,y)=>starkCurve.pedersen(BigInt(x),BigInt(y))),0).toString()}var computePedersenHashOnElements=computeHashOnElements2;function computePoseidonHashOnElements(data){return toHex((0,import_starknet3.poseidonHashMany)(data.map((x=>BigInt(x)))))}function calculateContractAddressFromHash(salt,classHash,constructorCalldata,deployerAddress){const constructorCalldataHash=computeHashOnElements2(CallData.compile(constructorCalldata)),hash=computeHashOnElements2([felt("0x535441524b4e45545f434f4e54524143545f41444452455353"),deployerAddress,salt,classHash,constructorCalldataHash]);return toHex(BigInt(hash)%ADDR_BOUND)}function nullSkipReplacer(key,value){return"attributes"===key||"accessible_scopes"===key?Array.isArray(value)&&0===value.length?void 0:value:"debug_info"===key?null:null===value?void 0:value}function formatSpaces(json2){let insideQuotes=!1;const newString=[];for(const char of json2)'"'===char&&!1==(newString.length>0&&"\\"===newString.slice(-1)[0])&&(insideQuotes=!insideQuotes),insideQuotes?newString.push(char):newString.push(":"===char?": ":","===char?", ":char);return newString.join("")}function computeHintedClassHash(compiledContract){const{abi,program}=compiledContract,serializedJson=formatSpaces(stringify2({abi,program},nullSkipReplacer));return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16))}function computeLegacyContractClassHash(contract){const compiledContract=isString(contract)?parse2(contract):contract,apiVersion=toHex(API_VERSION),externalEntryPointsHash=computeHashOnElements2(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e=>[e.selector,e.offset]))),l1HandlerEntryPointsHash=computeHashOnElements2(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e=>[e.selector,e.offset]))),constructorEntryPointHash=computeHashOnElements2(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e=>[e.selector,e.offset]))),builtinsHash=computeHashOnElements2(compiledContract.program.builtins.map((s=>encodeShortString(s)))),hintedClassHash=computeHintedClassHash(compiledContract),dataHash=computeHashOnElements2(compiledContract.program.data);return computeHashOnElements2([apiVersion,externalEntryPointsHash,l1HandlerEntryPointsHash,constructorEntryPointHash,builtinsHash,hintedClassHash,dataHash])}function hashEntryPoint(data){const base=data.flatMap((it=>{return[BigInt(it.selector),BigInt(it.offset),(builtins=it.builtins,(0,import_starknet3.poseidonHashMany)(builtins.flatMap((it=>BigInt(encodeShortString(it))))))];var builtins}));return(0,import_starknet3.poseidonHashMany)(base)}function hashByteCodeSegments(casm){const byteCode=casm.bytecode.map((n=>BigInt(n))),bytecodeSegmentLengths=casm.bytecode_segment_lengths??[];let segmentStart=0;const hashLeaves=bytecodeSegmentLengths.flatMap((len=>{const segment=byteCode.slice(segmentStart,segmentStart+=len);return[BigInt(len),(0,import_starknet3.poseidonHashMany)(segment)]}));return 1n+(0,import_starknet3.poseidonHashMany)(hashLeaves)}function computeCompiledClassHash(casm){const compiledClassVersion=BigInt(encodeShortString("COMPILED_CLASS_V1")),externalEntryPointsHash=hashEntryPoint(casm.entry_points_by_type.EXTERNAL),l1Handlers=hashEntryPoint(casm.entry_points_by_type.L1_HANDLER),constructor=hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR),bytecode=casm.bytecode_segment_lengths?hashByteCodeSegments(casm):(0,import_starknet3.poseidonHashMany)(casm.bytecode.map((it=>BigInt(it))));return toHex((0,import_starknet3.poseidonHashMany)([compiledClassVersion,externalEntryPointsHash,l1Handlers,constructor,bytecode]))}function hashEntryPointSierra(data){const base=data.flatMap((it=>[BigInt(it.selector),BigInt(it.function_idx)]));return(0,import_starknet3.poseidonHashMany)(base)}function computeSierraContractClassHash(sierra){const compiledClassVersion=BigInt(encodeShortString("CONTRACT_CLASS_V0.1.0")),externalEntryPointsHash=hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL),l1Handlers=hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER),constructor=hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR),abiHash=function(sierra){const indentString=formatSpaces(stringify2(sierra.abi,null));return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)))}(sierra),sierraProgram=(0,import_starknet3.poseidonHashMany)(sierra.sierra_program.map((it=>BigInt(it))));return toHex((0,import_starknet3.poseidonHashMany)([compiledClassVersion,externalEntryPointsHash,l1Handlers,constructor,abiHash,sierraProgram]))}function computeContractClassHash(contract){const compiledContract=isString(contract)?parse2(contract):contract;return"sierra_program"in compiledContract?computeSierraContractClassHash(compiledContract):computeLegacyContractClassHash(compiledContract)}var stark_exports={};__export(stark_exports,{ZEROFee:()=>ZEROFee,compressProgram:()=>compressProgram,decompressProgram:()=>decompressProgram,estimateFeeToBounds:()=>estimateFeeToBounds3,estimatedFeeToMaxFee:()=>estimatedFeeToMaxFee,formatSignature:()=>formatSignature,getFullPublicKey:()=>getFullPublicKey,intDAM:()=>intDAM,randomAddress:()=>randomAddress,reduceV2:()=>reduceV2,signatureToDecimalArray:()=>signatureToDecimalArray,signatureToHexArray:()=>signatureToHexArray,toFeeVersion:()=>toFeeVersion,toTransactionVersion:()=>toTransactionVersion,v3Details:()=>v3Details});var import_starknet4=__webpack_require__(4246),import_pako=__webpack_require__(59760);function isV3Tx(details){const version=details.version?toHex(details.version):ETransactionVersion2.V3;return version===ETransactionVersion2.V3||version===ETransactionVersion2.F3}function isVersion(expected,provided){const expectedParts=expected.split("."),providedParts=provided.split(".");return expectedParts.every(((part,index)=>"*"===part||part===providedParts[index]))}function isSupportedSpecVersion(version,options={allowAnyPatchVersion:!1}){return Object.values(_SupportedRpcVersion).some((v=>isVersion(options.allowAnyPatchVersion?toAnyPatchVersion(v):v,version)))}function toAnyPatchVersion(version){const parts=version.split(".");return parts.length<3?version:`${parts[0]}.${parts[1]}.*`}function isPendingBlock(response){return"PENDING"===response.status}function isPendingTransaction(response){return!("block_hash"in response)}function isPendingStateUpdate(response){return!("block_hash"in response)}function compressProgram(jsonProgram){const stringified=isString(jsonProgram)?jsonProgram:stringify2(jsonProgram);return btoaUniversal((0,import_pako.gzip)(stringified))}function decompressProgram(base642){if(Array.isArray(base642))return base642;const decompressed=arrayBufferToString((0,import_pako.ungzip)(atobUniversal(base642)));return parse2(decompressed)}function randomAddress(){const randomKeyPair=import_starknet4.utils.randomPrivateKey();return(0,import_starknet4.getStarkKey)(randomKeyPair)}function formatSignature(sig){if(!sig)throw Error("formatSignature: provided signature is undefined");if(Array.isArray(sig))return sig.map((it=>toHex(it)));try{const{r,s}=sig;return[toHex(r),toHex(s)]}catch(e){throw new Error("Signature need to be weierstrass.SignatureType or an array for custom")}}function signatureToDecimalArray(sig){return bigNumberishArrayToDecimalStringArray(formatSignature(sig))}function signatureToHexArray(sig){return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig))}function estimatedFeeToMaxFee(estimatedFee,overhead=config.get("feeMarginPercentage").maxFee){return addPercent(estimatedFee,overhead)}function estimateFeeToBounds3(estimate,overhead=config.get("feeMarginPercentage").bounds,specVersion){return isBigInt(estimate)?{l2_gas:{max_amount:"0x0",max_price_per_unit:"0x0"},l1_gas:{max_amount:"0x0",max_price_per_unit:"0x0"},...specVersion&&isVersion("0.8",specVersion)&&{l1_data_gas:{max_amount:"0x0",max_price_per_unit:"0x0"}}}:isRPC08_FeeEstimate(estimate)?function(estimate,overhead){return{l2_gas:{max_amount:toHex(addPercent(estimate.l2_gas_consumed,overhead.l2_gas.max_amount)),max_price_per_unit:toHex(addPercent(estimate.l2_gas_price,overhead.l2_gas.max_price_per_unit))},l1_gas:{max_amount:toHex(addPercent(estimate.l1_gas_consumed,overhead.l1_gas.max_amount)),max_price_per_unit:toHex(addPercent(estimate.l1_gas_price,overhead.l1_gas.max_price_per_unit))},l1_data_gas:{max_amount:toHex(addPercent(estimate.l1_data_gas_consumed,overhead.l1_data_gas.max_amount)),max_price_per_unit:toHex(addPercent(estimate.l1_data_gas_price,overhead.l1_data_gas.max_price_per_unit))}}}(estimate,overhead):function(estimate,overhead){return{l2_gas:{max_amount:"0x0",max_price_per_unit:"0x0"},l1_gas:{max_amount:void 0!==estimate.data_gas_consumed&&void 0!==estimate.data_gas_price?toHex(addPercent(BigInt(estimate.overall_fee)/BigInt(estimate.gas_price),overhead.l1_gas.max_amount)):toHex(addPercent(estimate.gas_consumed,overhead.l1_gas.max_amount)),max_price_per_unit:toHex(addPercent(estimate.gas_price,overhead.l1_gas.max_price_per_unit))}}}(estimate,overhead)}function ZEROFee(specVersion){return{l1_gas_consumed:0n,l1_gas_price:0n,l1_data_gas_consumed:0n,l1_data_gas_price:0n,l2_gas_consumed:0n,l2_gas_price:0n,overall_fee:ZERO,unit:"FRI",suggestedMaxFee:ZERO,resourceBounds:estimateFeeToBounds3(ZERO,void 0,specVersion)}}function intDAM(dam){if(dam===EDataAvailabilityMode.L1)return EDAMode.L1;if(dam===EDataAvailabilityMode.L2)return EDAMode.L2;throw Error("EDAM conversion")}function toTransactionVersion(defaultVersion,providedVersion){const providedVersion0xs=providedVersion?toHex(providedVersion):void 0,defaultVersion0xs=toHex(defaultVersion);if(providedVersion&&!Object.values(ETransactionVersion2).includes(providedVersion0xs))throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);if(!Object.values(ETransactionVersion2).includes(defaultVersion0xs))throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);return providedVersion?providedVersion0xs:defaultVersion0xs}function toFeeVersion(providedVersion){if(!providedVersion)return;const version=toHex(providedVersion);if(version===ETransactionVersion2.V0)return ETransactionVersion2.F0;if(version===ETransactionVersion2.V1)return ETransactionVersion2.F1;if(version===ETransactionVersion2.V2)return ETransactionVersion2.F2;if(version===ETransactionVersion2.V3)return ETransactionVersion2.F3;throw Error(`toFeeVersion: ${version} is not supported`)}function v3Details(details,specVersion){return{tip:details.tip||0,paymasterData:details.paymasterData||[],accountDeploymentData:details.accountDeploymentData||[],nonceDataAvailabilityMode:details.nonceDataAvailabilityMode||EDataAvailabilityMode.L1,feeDataAvailabilityMode:details.feeDataAvailabilityMode||EDataAvailabilityMode.L1,resourceBounds:details.resourceBounds??estimateFeeToBounds3(ZERO,void 0,specVersion)}}function reduceV2(providedVersion){return providedVersion===ETransactionVersion2.F2?ETransactionVersion2.F1:providedVersion===ETransactionVersion2.V2?ETransactionVersion2.V1:providedVersion}function getFullPublicKey(privateKey){const privKey=toHex(privateKey);return addHexPrefix(buf2hex((0,import_starknet4.getPublicKey)(privKey,!1)))}function isSierra(contract){return"sierra_program"in(isString(contract)?parse2(contract):contract)}function extractContractHashes(payload){const response={...payload};if(isSierra(payload.contract)&&(!payload.compiledClassHash&&payload.casm&&(response.compiledClassHash=computeCompiledClassHash(payload.casm)),!response.compiledClassHash))throw new Error("Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash");if(response.classHash=payload.classHash??computeContractClassHash(payload.contract),!response.classHash)throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");return response}function contractClassResponseToLegacyCompiledContract(ccr){if(isSierra(ccr))throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");const contract=ccr;return{...contract,program:decompressProgram(contract.program)}}var rpc_default={FAILED_TO_RECEIVE_TXN:1,NO_TRACE_AVAILABLE:10,CONTRACT_NOT_FOUND:20,ENTRYPOINT_NOT_FOUND:21,BLOCK_NOT_FOUND:24,INVALID_TXN_INDEX:27,CLASS_HASH_NOT_FOUND:28,TXN_HASH_NOT_FOUND:29,PAGE_SIZE_TOO_BIG:31,NO_BLOCKS:32,INVALID_CONTINUATION_TOKEN:33,TOO_MANY_KEYS_IN_FILTER:34,CONTRACT_ERROR:40,TRANSACTION_EXECUTION_ERROR:41,STORAGE_PROOF_NOT_SUPPORTED:42,CLASS_ALREADY_DECLARED:51,INVALID_TRANSACTION_NONCE:52,INSUFFICIENT_RESOURCES_FOR_VALIDATE:53,INSUFFICIENT_ACCOUNT_BALANCE:54,VALIDATION_FAILURE:55,COMPILATION_FAILED:56,CONTRACT_CLASS_SIZE_IS_TOO_LARGE:57,NON_ACCOUNT:58,DUPLICATE_TX:59,COMPILED_CLASS_HASH_MISMATCH:60,UNSUPPORTED_TX_VERSION:61,UNSUPPORTED_CONTRACT_CLASS_VERSION:62,UNEXPECTED_ERROR:63,INVALID_SUBSCRIPTION_ID:66,TOO_MANY_ADDRESSES_IN_FILTER:67,TOO_MANY_BLOCKS_BACK:68,COMPILATION_ERROR:100,INVALID_ADDRESS:150,TOKEN_NOT_SUPPORTED:151,INVALID_SIGNATURE:153,MAX_AMOUNT_TOO_LOW:154,CLASS_HASH_NOT_SUPPORTED:155,PAYMASTER_TRANSACTION_EXECUTION_ERROR:156,INVALID_TIME_BOUNDS:157,INVALID_DEPLOYMENT_DATA:158,INVALID_CLASS_HASH:159,INVALID_ID:160,UNKNOWN_ERROR:163};function fixStack(target,fn=target.constructor){const{captureStackTrace}=Error;captureStackTrace&&captureStackTrace(target,fn)}function fixProto(target,prototype){const{setPrototypeOf}=Object;setPrototypeOf?setPrototypeOf(target,prototype):target.__proto__=prototype}var CustomError=class extends Error{name;constructor(message){super(message),Object.defineProperty(this,"name",{value:new.target.name,enumerable:!1,configurable:!0}),fixProto(this,new.target.prototype),fixStack(this)}},LibraryError=class extends CustomError{},RpcError=class extends LibraryError{constructor(baseError,method,params){super(`RPC: ${method} with params ${stringify2(params,null,2)}\n\n      ${baseError.code}: ${baseError.message}: ${stringify2(baseError.data)}`),this.baseError=baseError,this.request={method,params}}request;get code(){return this.baseError.code}isType(typeName){return rpc_default[typeName]===this.code}},eth_exports={};__export(eth_exports,{ethRandomPrivateKey:()=>ethRandomPrivateKey,validateAndParseEthAddress:()=>validateAndParseEthAddress});var import_secp256k1=__webpack_require__(8510);function ethRandomPrivateKey(){return sanitizeHex(buf2hex(import_secp256k1.secp256k1.utils.randomPrivateKey()))}function validateAndParseEthAddress(address){assertInRange(address,ZERO,2n**160n-1n,"Ethereum Address ");const result=addHexPrefix(removeHexPrefix(toHex(address)).padStart(40,"0"));return assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)),"Invalid Ethereum Address Format"),result}var fetch_default="undefined"!=typeof globalThis&&globalThis.fetch.bind(globalThis)||"undefined"!=typeof window&&window.fetch.bind(window)||void 0!==__webpack_require__.g&&__webpack_require__.g.fetch.bind(__webpack_require__.g)||(()=>{throw new LibraryError("'fetch()' not detected, use the 'baseFetch' constructor parameter to set it")}),provider_exports={};function wait(delay){return new Promise((res=>{setTimeout(res,delay)}))}function createSierraContractClass(contract){const result={...contract};return delete result.sierra_program_debug_info,result.abi=formatSpaces(stringify2(contract.abi)),result.sierra_program=formatSpaces(stringify2(contract.sierra_program)),result.sierra_program=compressProgram(result.sierra_program),result}function parseContract(contract){const parsedContract=isString(contract)?parse2(contract):contract;return isSierra(contract)?createSierraContractClass(parsedContract):{...parsedContract,..."program"in parsedContract&&{program:compressProgram(parsedContract.program)}}}__export(provider_exports,{Block:()=>Block,createSierraContractClass:()=>createSierraContractClass,getDefaultNodeUrl:()=>getDefaultNodeUrl,getDefaultNodes:()=>getDefaultNodes,parseContract:()=>parseContract,validBlockTags:()=>validBlockTags,wait:()=>wait});var getDefaultNodeUrl=(networkName,mute=!1,rpcVersion)=>{mute||logger.info("Using default public node url, please provide nodeUrl in provider options!");const nodes=getDefaultNodes(rpcVersion??config.get("rpcVersion"))[networkName??_NetworkName.SN_SEPOLIA];return nodes[Math.floor(Math.random()*nodes.length)]};function getDefaultNodes(rpcVersion){const nodes={...RPC_DEFAULT_NODES};return Object.keys(nodes).forEach((function(key,_){nodes[key]=nodes[key].map((it=>{return`${it}${versionString=rpcVersion,`v${versionString.replace(/^v/,"").replace(/\./g,"_")}`}`;var versionString}))})),nodes}var validBlockTags=Object.values(BlockTag),Block=class{hash=null;number=null;tag=null;setIdentifier(__identifier){if(isString(__identifier))if(isDecimalString(__identifier))this.number=parseInt(__identifier,10);else if(isHex(__identifier))this.hash=__identifier;else{if(!validBlockTags.includes(__identifier))throw TypeError(`Block identifier unmanaged: ${__identifier}`);this.tag=__identifier}else isBigInt(__identifier)?this.hash=toHex(__identifier):isNumber(__identifier)?this.number=__identifier:this.tag=BlockTag.PENDING;if(isNumber(this.number)&&this.number<0)throw TypeError(`Block number (${this.number}) can't be negative`)}constructor(_identifier){this.setIdentifier(_identifier)}get queryIdentifier(){return null!==this.number?`blockNumber=${this.number}`:null!==this.hash?`blockHash=${this.hash}`:`blockNumber=${this.tag}`}get identifier(){return null!==this.number?{block_number:this.number}:null!==this.hash?{block_hash:this.hash}:this.tag}set identifier(_identifier){this.setIdentifier(_identifier)}valueOf=()=>this.number;toString=()=>this.hash},transaction_exports={};__export(transaction_exports,{buildUDCCall:()=>buildUDCCall,fromCallsToExecuteCalldata:()=>fromCallsToExecuteCalldata,fromCallsToExecuteCalldata_cairo1:()=>fromCallsToExecuteCalldata_cairo1,getExecuteCalldata:()=>getExecuteCalldata,getVersionsByType:()=>getVersionsByType,transformCallsToMulticallArrays:()=>transformCallsToMulticallArrays});var transformCallsToMulticallArrays=calls=>{const callArray=[],calldata=[];return calls.forEach((call=>{const data=CallData.compile(call.calldata||[]);callArray.push({to:toBigInt(call.contractAddress).toString(10),selector:toBigInt(getSelectorFromName(call.entrypoint)).toString(10),data_offset:calldata.length.toString(),data_len:data.length.toString()}),calldata.push(...data)})),{callArray,calldata:CallData.compile({calldata})}},fromCallsToExecuteCalldata=calls=>{const{callArray,calldata}=transformCallsToMulticallArrays(calls);return[...CallData.compile({callArray}),...calldata]},fromCallsToExecuteCalldata_cairo1=calls=>{const orderCalls=calls.map((call=>({contractAddress:call.contractAddress,entrypoint:call.entrypoint,calldata:Array.isArray(call.calldata)&&"__compiled__"in call.calldata?call.calldata:CallData.compile(call.calldata)})));return CallData.compile({orderCalls})},getExecuteCalldata=(calls,cairoVersion="0")=>"1"===cairoVersion?fromCallsToExecuteCalldata_cairo1(calls):fromCallsToExecuteCalldata(calls);function buildUDCCall(payload,address){const params=[].concat(payload).map((it=>{const{classHash,salt,unique=!0,constructorCalldata=[]}=it,compiledConstructorCallData=CallData.compile(constructorCalldata),deploySalt=salt??randomAddress();return{call:{contractAddress:UDC.ADDRESS,entrypoint:UDC.ENTRYPOINT,calldata:[classHash,deploySalt,toCairoBool(unique),compiledConstructorCallData.length,...compiledConstructorCallData]},address:calculateContractAddressFromHash(unique?starkCurve.pedersen(address,deploySalt):deploySalt,classHash,compiledConstructorCallData,unique?UDC.ADDRESS:0)}}));return{calls:params.map((it=>it.call)),addresses:params.map((it=>it.address))}}function getVersionsByType(versionType){return"fee"===versionType?{v1:ETransactionVersion2.F1,v2:ETransactionVersion2.F2,v3:ETransactionVersion2.F3}:{v1:ETransactionVersion2.V1,v2:ETransactionVersion2.V2,v3:ETransactionVersion2.V3}}var defaultOptions={headers:{"Content-Type":"application/json"},blockIdentifier:BlockTag.PENDING,retries:200},RpcChannel=class{id="RPC071";channelSpecVersion=_SupportedRpcVersion.v0_7_1;nodeUrl;headers;requestId;blockIdentifier;retries;waitMode;chainId;specVersion;transactionRetryIntervalFallback;batchClient;baseFetch;constructor(optionsOrProvider){const{baseFetch,batch,blockIdentifier,chainId,headers,nodeUrl,retries,specVersion,transactionRetryIntervalFallback,waitMode}=optionsOrProvider||{};Object.values(_NetworkName).includes(nodeUrl)?this.nodeUrl=getDefaultNodeUrl(nodeUrl,optionsOrProvider?.default,this.channelSpecVersion):this.nodeUrl=nodeUrl||getDefaultNodeUrl(void 0,optionsOrProvider?.default,this.channelSpecVersion),this.baseFetch=baseFetch||config.get("fetch")||fetch_default,this.blockIdentifier=blockIdentifier??defaultOptions.blockIdentifier,this.chainId=chainId,this.headers={...defaultOptions.headers,...headers},this.retries=retries??defaultOptions.retries,this.specVersion=specVersion,this.transactionRetryIntervalFallback=transactionRetryIntervalFallback,this.waitMode=waitMode??!1,this.requestId=0,"number"==typeof batch&&(this.batchClient=new BatchClient({nodeUrl:this.nodeUrl,headers:this.headers,interval:batch,baseFetch:this.baseFetch})),logger.debug("Using Channel",this.id)}readSpecVersion(){return this.specVersion}get transactionRetryIntervalDefault(){return this.transactionRetryIntervalFallback??5e3}setChainId(chainId){this.chainId=chainId}fetch(method,params,id=0){const rpcRequestBody={id,jsonrpc:"2.0",method,...params&&{params}};return this.baseFetch(this.nodeUrl,{method:"POST",body:stringify2(rpcRequestBody),headers:this.headers})}errorHandler(method,params,rpcError,otherError){if(rpcError)throw new RpcError(rpcError,method,params);if(otherError instanceof LibraryError)throw otherError;if(otherError)throw Error(otherError.message)}async fetchEndpoint(method,params){try{if(this.batchClient){const{error:error2,result:result2}=await this.batchClient.fetch(method,params,this.requestId+=1);return this.errorHandler(method,params,error2),result2}const rawResult=await this.fetch(method,params,this.requestId+=1),{error,result}=await rawResult.json();return this.errorHandler(method,params,error),result}catch(error){throw this.errorHandler(method,params,error?.response?.data,error),error}}async getChainId(){return this.chainId??=await this.fetchEndpoint("starknet_chainId"),this.chainId}getSpecVersion(){return this.fetchEndpoint("starknet_specVersion")}async setUpSpecVersion(){if(!this.specVersion){const unknownSpecVersion=await this.fetchEndpoint("starknet_specVersion");if(isVersion(this.channelSpecVersion,unknownSpecVersion)||logger.error(SYSTEM_MESSAGES.channelVersionMismatch,{channelId:this.id,channelSpecVersion:this.channelSpecVersion,nodeSpecVersion:this.specVersion}),!isSupportedSpecVersion(unknownSpecVersion))throw new LibraryError(`${SYSTEM_MESSAGES.unsupportedSpecVersion}, channelId: ${this.id}`);this.specVersion=unknownSpecVersion}return this.specVersion}getNonceForAddress(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getNonce",{contract_address,block_id})}getBlockLatestAccepted(){return this.fetchEndpoint("starknet_blockHashAndNumber")}getBlockNumber(){return this.fetchEndpoint("starknet_blockNumber")}getBlockWithTxHashes(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithTxHashes",{block_id})}getBlockWithTxs(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithTxs",{block_id})}getBlockWithReceipts(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithReceipts",{block_id})}getBlockStateUpdate(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getStateUpdate",{block_id})}getBlockTransactionsTraces(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_traceBlockTransactions",{block_id})}getBlockTransactionCount(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockTransactionCount",{block_id})}getTransactionByHash(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_getTransactionByHash",{transaction_hash})}getTransactionByBlockIdAndIndex(blockIdentifier,index){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex",{block_id,index})}getTransactionReceipt(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_getTransactionReceipt",{transaction_hash})}getTransactionTrace(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_traceTransaction",{transaction_hash})}getTransactionStatus(transactionHash){const transaction_hash=toHex(transactionHash);return this.fetchEndpoint("starknet_getTransactionStatus",{transaction_hash})}simulateTransaction(invocations,simulateTransactionOptions={}){const{blockIdentifier=this.blockIdentifier,skipValidate=!0,skipFeeCharge=!0}=simulateTransactionOptions,block_id=new Block(blockIdentifier).identifier,simulationFlags=[];return skipValidate&&simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_VALIDATE),skipFeeCharge&&simulationFlags.push(RPCSPEC07.ESimulationFlag.SKIP_FEE_CHARGE),this.fetchEndpoint("starknet_simulateTransactions",{block_id,transactions:invocations.map((it=>this.buildTransaction(it))),simulation_flags:simulationFlags})}async waitForTransaction(txHash,options){const transactionHash=toHex(txHash);let{retries}=this,onchain=!1,isErrorState=!1;const retryInterval=options?.retryInterval??this.transactionRetryIntervalDefault,errorStates=options?.errorStates??[RPCSPEC07.ETransactionStatus.REJECTED],successStates=options?.successStates??[RPCSPEC07.ETransactionExecutionStatus.SUCCEEDED,RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L2,RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L1];let txStatus;for(;!onchain;){await wait(retryInterval);try{txStatus=await this.getTransactionStatus(transactionHash);const executionStatus=txStatus.execution_status,finalityStatus=txStatus.finality_status;if(!finalityStatus){throw new Error("waiting for transaction status")}if(errorStates.includes(executionStatus)||errorStates.includes(finalityStatus)){const message=`${executionStatus}: ${finalityStatus}`,error=new Error(message);throw error.response=txStatus,isErrorState=!0,error}(successStates.includes(executionStatus)||successStates.includes(finalityStatus))&&(onchain=!0)}catch(error){if(error instanceof Error&&isErrorState)throw error;if(retries<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}retries-=1}let txReceipt=null;for(;null===txReceipt;){try{txReceipt=await this.getTransactionReceipt(transactionHash)}catch(error){if(retries<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}retries-=1,await wait(retryInterval)}return txReceipt}getStorageAt(contractAddress,key,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),parsedKey=toStorageKey(key),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getStorageAt",{contract_address,key:parsedKey,block_id})}getClassHashAt(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClassHashAt",{block_id,contract_address})}getClass(classHash,blockIdentifier=this.blockIdentifier){const class_hash=toHex(classHash),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClass",{class_hash,block_id})}getClassAt(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClassAt",{block_id,contract_address})}async getEstimateFee(invocations,{blockIdentifier=this.blockIdentifier,skipValidate=!0}){const block_id=new Block(blockIdentifier).identifier,flags={simulation_flags:skipValidate?[RPCSPEC07.ESimulationFlag.SKIP_VALIDATE]:[]};return this.fetchEndpoint("starknet_estimateFee",{request:invocations.map((it=>this.buildTransaction(it,"fee"))),block_id,...flags})}async invoke(functionInvocation,details){let promise;return isV3Tx(details)?(promise=this.fetchEndpoint("starknet_addInvokeTransaction",{invoke_transaction:{type:RPCSPEC07.ETransactionType.INVOKE,sender_address:functionInvocation.contractAddress,calldata:CallData.toHex(functionInvocation.calldata),version:RPCSPEC07.ETransactionVersion.V3,signature:signatureToHexArray(functionInvocation.signature),nonce:toHex(details.nonce),resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),account_deployment_data:details.accountDeploymentData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),assertX(!details.maxFee,(()=>{logger.warn(SYSTEM_MESSAGES.maxFeeInV3,{type:RPCSPEC07.ETransactionType.INVOKE})}))):(promise=this.fetchEndpoint("starknet_addInvokeTransaction",{invoke_transaction:{sender_address:functionInvocation.contractAddress,calldata:CallData.toHex(functionInvocation.calldata),type:RPCSPEC07.ETransactionType.INVOKE,max_fee:toHex(details.maxFee||0),version:RPCSPEC07.ETransactionVersion.V1,signature:signatureToHexArray(functionInvocation.signature),nonce:toHex(details.nonce)}}),logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage,{version:RPCSPEC07.ETransactionVersion.V1,type:RPCSPEC07.ETransactionType.INVOKE})),this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}async declare({contract,signature,senderAddress,compiledClassHash},details){let promise;if(isSierra(contract)||isV3Tx(details))if(isSierra(contract)&&!isV3Tx(details))promise=this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:RPCSPEC07.ETransactionType.DECLARE,contract_class:{sierra_program:decompressProgram(contract.sierra_program),contract_class_version:contract.contract_class_version,entry_points_by_type:contract.entry_points_by_type,abi:contract.abi},compiled_class_hash:compiledClassHash||"",version:RPCSPEC07.ETransactionVersion.V2,max_fee:toHex(details.maxFee||0),signature:signatureToHexArray(signature),sender_address:senderAddress,nonce:toHex(details.nonce)}}),logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage,{version:RPCSPEC07.ETransactionVersion.V2,type:RPCSPEC07.ETransactionType.DECLARE});else{if(!isSierra(contract)||!isV3Tx(details))throw Error("declare unspotted parameters");promise=this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:RPCSPEC07.ETransactionType.DECLARE,sender_address:senderAddress,compiled_class_hash:compiledClassHash||"",version:RPCSPEC07.ETransactionVersion.V3,signature:signatureToHexArray(signature),nonce:toHex(details.nonce),contract_class:{sierra_program:decompressProgram(contract.sierra_program),contract_class_version:contract.contract_class_version,entry_points_by_type:contract.entry_points_by_type,abi:contract.abi},resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),account_deployment_data:details.accountDeploymentData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),assertX(!details.maxFee,(()=>{logger.warn(SYSTEM_MESSAGES.maxFeeInV3,{type:RPCSPEC07.ETransactionType.DECLARE})}))}else promise=this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:RPCSPEC07.ETransactionType.DECLARE,contract_class:{program:contract.program,entry_points_by_type:contract.entry_points_by_type,abi:contract.abi},version:RPCSPEC07.ETransactionVersion.V1,max_fee:toHex(details.maxFee||0),signature:signatureToHexArray(signature),sender_address:senderAddress,nonce:toHex(details.nonce)}}),logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage,{version:RPCSPEC07.ETransactionVersion.V1,type:RPCSPEC07.ETransactionType.DECLARE});return this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}async deployAccount({classHash,constructorCalldata,addressSalt,signature},details){let promise;return isV3Tx(details)?(promise=this.fetchEndpoint("starknet_addDeployAccountTransaction",{deploy_account_transaction:{type:RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,version:RPCSPEC07.ETransactionVersion.V3,signature:signatureToHexArray(signature),nonce:toHex(details.nonce),contract_address_salt:toHex(addressSalt||0),constructor_calldata:CallData.toHex(constructorCalldata||[]),class_hash:toHex(classHash),resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),assertX(!details.maxFee,(()=>{logger.warn(SYSTEM_MESSAGES.maxFeeInV3,{type:RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT})}))):(promise=this.fetchEndpoint("starknet_addDeployAccountTransaction",{deploy_account_transaction:{constructor_calldata:CallData.toHex(constructorCalldata||[]),class_hash:toHex(classHash),contract_address_salt:toHex(addressSalt||0),type:RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,max_fee:toHex(details.maxFee||0),version:RPCSPEC07.ETransactionVersion.V1,signature:signatureToHexArray(signature),nonce:toHex(details.nonce)}}),logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage,{version:RPCSPEC07.ETransactionVersion.V1,type:RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT})),this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}callContract(call,blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_call",{request:{contract_address:call.contractAddress,entry_point_selector:getSelectorFromName(call.entrypoint),calldata:CallData.toHex(call.calldata)},block_id})}estimateMessageFee(message,blockIdentifier=this.blockIdentifier){const{from_address,to_address,entry_point_selector,payload}=message,formattedMessage={from_address:validateAndParseEthAddress(from_address),to_address:toHex(to_address),entry_point_selector:getSelector(entry_point_selector),payload:getHexStringArray(payload)},block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_estimateMessageFee",{message:formattedMessage,block_id})}getSyncingStats(){return this.fetchEndpoint("starknet_syncing")}getEvents(eventFilter){return this.fetchEndpoint("starknet_getEvents",{filter:eventFilter})}buildTransaction(invocation,versionType){const defaultVersions=getVersionsByType(versionType);let details;if(isV3Tx(invocation)?(details={signature:signatureToHexArray(invocation.signature),nonce:toHex(invocation.nonce),resource_bounds:invocation.resourceBounds,tip:toHex(invocation.tip),paymaster_data:invocation.paymasterData.map((it=>toHex(it))),nonce_data_availability_mode:invocation.nonceDataAvailabilityMode,fee_data_availability_mode:invocation.feeDataAvailabilityMode,account_deployment_data:invocation.accountDeploymentData.map((it=>toHex(it)))},assertX(!invocation.maxFee,(()=>{logger.warn(SYSTEM_MESSAGES.maxFeeInV3,{type:invocation.type,versionType})}))):(details={signature:signatureToHexArray(invocation.signature),nonce:toHex(invocation.nonce),max_fee:toHex(invocation.maxFee||0)},logger.warn(SYSTEM_MESSAGES.legacyTxWarningMessage,{version:invocation.version,type:invocation.type})),invocation.type===TransactionType.INVOKE)return{type:RPCSPEC07.ETransactionType.INVOKE,sender_address:invocation.contractAddress,calldata:CallData.toHex(invocation.calldata),version:toHex(invocation.version||defaultVersions.v3),...details};if(invocation.type===TransactionType.DECLARE)return isSierra(invocation.contract)?{type:invocation.type,contract_class:{...invocation.contract,sierra_program:decompressProgram(invocation.contract.sierra_program)},compiled_class_hash:invocation.compiledClassHash||"",sender_address:invocation.senderAddress,version:toHex(invocation.version||defaultVersions.v3),...details}:{type:invocation.type,contract_class:invocation.contract,sender_address:invocation.senderAddress,version:toHex(invocation.version||defaultVersions.v1),...details};if(invocation.type===TransactionType.DEPLOY_ACCOUNT){const{account_deployment_data,...restDetails}=details;return{type:invocation.type,constructor_calldata:CallData.toHex(invocation.constructorCalldata||[]),class_hash:toHex(invocation.classHash),contract_address_salt:toHex(invocation.addressSalt||0),version:toHex(invocation.version||defaultVersions.v3),...restDetails}}throw Error("RPC buildTransaction received unknown TransactionType")}},rpc_0_8_1_exports={};__export(rpc_0_8_1_exports,{RpcChannel:()=>RpcChannel2});var defaultOptions2={headers:{"Content-Type":"application/json"},blockIdentifier:BlockTag.PENDING,retries:200},RpcChannel2=class{id="RPC081";channelSpecVersion=_SupportedRpcVersion.v0_8_1;nodeUrl;headers;requestId;blockIdentifier;retries;waitMode;chainId;specVersion;transactionRetryIntervalFallback;batchClient;baseFetch;constructor(optionsOrProvider){const{baseFetch,batch,blockIdentifier,chainId,headers,nodeUrl,retries,specVersion,transactionRetryIntervalFallback,waitMode}=optionsOrProvider||{};Object.values(_NetworkName).includes(nodeUrl)?this.nodeUrl=getDefaultNodeUrl(nodeUrl,optionsOrProvider?.default,this.channelSpecVersion):this.nodeUrl=nodeUrl||getDefaultNodeUrl(void 0,optionsOrProvider?.default,this.channelSpecVersion),this.baseFetch=baseFetch||config.get("fetch")||fetch_default,this.blockIdentifier=blockIdentifier??defaultOptions2.blockIdentifier,this.chainId=chainId,this.headers={...defaultOptions2.headers,...headers},this.retries=retries??defaultOptions2.retries,this.specVersion=specVersion,this.transactionRetryIntervalFallback=transactionRetryIntervalFallback,this.waitMode=waitMode??!1,this.requestId=0,"number"==typeof batch&&(this.batchClient=new BatchClient({nodeUrl:this.nodeUrl,headers:this.headers,interval:batch,baseFetch:this.baseFetch})),logger.debug("Using Channel",this.id)}readSpecVersion(){return this.specVersion}get transactionRetryIntervalDefault(){return this.transactionRetryIntervalFallback??5e3}setChainId(chainId){this.chainId=chainId}fetch(method,params,id=0){const rpcRequestBody={id,jsonrpc:"2.0",method,...params&&{params}};return this.baseFetch(this.nodeUrl,{method:"POST",body:stringify2(rpcRequestBody),headers:this.headers})}errorHandler(method,params,rpcError,otherError){if(rpcError)throw new RpcError(rpcError,method,params);if(otherError instanceof LibraryError)throw otherError;if(otherError)throw Error(otherError.message)}async fetchEndpoint(method,params){try{if(this.batchClient){const{error:error2,result:result2}=await this.batchClient.fetch(method,params,this.requestId+=1);return this.errorHandler(method,params,error2),result2}const rawResult=await this.fetch(method,params,this.requestId+=1),{error,result}=await rawResult.json();return this.errorHandler(method,params,error),result}catch(error){throw this.errorHandler(method,params,error?.response?.data,error),error}}async getChainId(){return this.chainId??=await this.fetchEndpoint("starknet_chainId"),this.chainId}getSpecVersion(){return this.fetchEndpoint("starknet_specVersion")}async setUpSpecVersion(){if(!this.specVersion){const unknownSpecVersion=await this.fetchEndpoint("starknet_specVersion");if(isVersion(this.channelSpecVersion,unknownSpecVersion)||logger.error(SYSTEM_MESSAGES.channelVersionMismatch,{channelId:this.id,channelSpecVersion:this.channelSpecVersion,nodeSpecVersion:this.specVersion}),!isSupportedSpecVersion(unknownSpecVersion))throw new LibraryError(`${SYSTEM_MESSAGES.unsupportedSpecVersion}, channelId: ${this.id}`);this.specVersion=unknownSpecVersion}return this.specVersion}getMessagesStatus(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_getMessagesStatus",{transaction_hash})}getStorageProof(classHashes=[],contractAddresses=[],contractsStorageKeys=[],blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier,class_hashes=bigNumberishArrayToHexadecimalStringArray(classHashes),contract_addresses=bigNumberishArrayToHexadecimalStringArray(contractAddresses);return this.fetchEndpoint("starknet_getStorageProof",{block_id,class_hashes,contract_addresses,contracts_storage_keys:contractsStorageKeys})}getCompiledCasm(classHash){const class_hash=toHex(classHash);return this.fetchEndpoint("starknet_getCompiledCasm",{class_hash})}getNonceForAddress(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getNonce",{contract_address,block_id})}getBlockLatestAccepted(){return this.fetchEndpoint("starknet_blockHashAndNumber")}getBlockNumber(){return this.fetchEndpoint("starknet_blockNumber")}getBlockWithTxHashes(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithTxHashes",{block_id})}getBlockWithTxs(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithTxs",{block_id})}getBlockWithReceipts(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockWithReceipts",{block_id})}getBlockStateUpdate(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getStateUpdate",{block_id})}getBlockTransactionsTraces(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_traceBlockTransactions",{block_id})}getBlockTransactionCount(blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getBlockTransactionCount",{block_id})}getTransactionByHash(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_getTransactionByHash",{transaction_hash})}getTransactionByBlockIdAndIndex(blockIdentifier,index){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex",{block_id,index})}getTransactionReceipt(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_getTransactionReceipt",{transaction_hash})}getTransactionTrace(txHash){const transaction_hash=toHex(txHash);return this.fetchEndpoint("starknet_traceTransaction",{transaction_hash})}getTransactionStatus(transactionHash){const transaction_hash=toHex(transactionHash);return this.fetchEndpoint("starknet_getTransactionStatus",{transaction_hash})}simulateTransaction(invocations,simulateTransactionOptions={}){const{blockIdentifier=this.blockIdentifier,skipValidate=!0,skipFeeCharge=!0}=simulateTransactionOptions,block_id=new Block(blockIdentifier).identifier,simulationFlags=[];return skipValidate&&simulationFlags.push(RPCSPEC08.ESimulationFlag.SKIP_VALIDATE),skipFeeCharge&&simulationFlags.push(RPCSPEC08.ESimulationFlag.SKIP_FEE_CHARGE),this.fetchEndpoint("starknet_simulateTransactions",{block_id,transactions:invocations.map((it=>this.buildTransaction(it))),simulation_flags:simulationFlags})}async waitForTransaction(txHash,options){const transactionHash=toHex(txHash);let{retries}=this,onchain=!1,isErrorState=!1;const retryInterval=options?.retryInterval??this.transactionRetryIntervalDefault,errorStates=options?.errorStates??[RPCSPEC08.ETransactionStatus.REJECTED],successStates=options?.successStates??[RPCSPEC08.ETransactionExecutionStatus.SUCCEEDED,RPCSPEC08.ETransactionStatus.ACCEPTED_ON_L2,RPCSPEC08.ETransactionStatus.ACCEPTED_ON_L1];let txStatus;for(;!onchain;){await wait(retryInterval);try{txStatus=await this.getTransactionStatus(transactionHash);const executionStatus=txStatus.execution_status,finalityStatus=txStatus.finality_status;if(!finalityStatus){throw new Error("waiting for transaction status")}if(errorStates.includes(executionStatus)||errorStates.includes(finalityStatus)){const message=`${executionStatus}: ${finalityStatus}`,error=new Error(message);throw error.response=txStatus,isErrorState=!0,error}(successStates.includes(executionStatus)||successStates.includes(finalityStatus))&&(onchain=!0)}catch(error){if(error instanceof Error&&isErrorState)throw error;if(retries<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}retries-=1}let txReceipt=null;for(;null===txReceipt;){try{txReceipt=await this.getTransactionReceipt(transactionHash)}catch(error){if(retries<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}retries-=1,await wait(retryInterval)}return txReceipt}getStorageAt(contractAddress,key,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),parsedKey=toStorageKey(key),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getStorageAt",{contract_address,key:parsedKey,block_id})}getClassHashAt(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClassHashAt",{block_id,contract_address})}getClass(classHash,blockIdentifier=this.blockIdentifier){const class_hash=toHex(classHash),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClass",{class_hash,block_id})}getClassAt(contractAddress,blockIdentifier=this.blockIdentifier){const contract_address=toHex(contractAddress),block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_getClassAt",{block_id,contract_address})}async getEstimateFee(invocations,{blockIdentifier=this.blockIdentifier,skipValidate=!0}){const block_id=new Block(blockIdentifier).identifier,flags={simulation_flags:skipValidate?[RPCSPEC08.ESimulationFlag.SKIP_VALIDATE]:[]};return this.fetchEndpoint("starknet_estimateFee",{request:invocations.map((it=>this.buildTransaction(it,"fee"))),block_id,...flags})}async invoke(functionInvocation,details){let promise;if(!isV3Tx(details))throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);if(!isRPC08_ResourceBounds(details.resourceBounds))throw Error(SYSTEM_MESSAGES.SWOldV3);return promise=this.fetchEndpoint("starknet_addInvokeTransaction",{invoke_transaction:{type:RPCSPEC08.ETransactionType.INVOKE,sender_address:functionInvocation.contractAddress,calldata:CallData.toHex(functionInvocation.calldata),version:RPCSPEC08.ETransactionVersion.V3,signature:signatureToHexArray(functionInvocation.signature),nonce:toHex(details.nonce),resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),account_deployment_data:details.accountDeploymentData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}async declare({contract,signature,senderAddress,compiledClassHash},details){let promise;if(!isSierra(contract)||!isV3Tx(details))throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);if(!isRPC08_ResourceBounds(details.resourceBounds))throw Error(SYSTEM_MESSAGES.SWOldV3);return promise=this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:RPCSPEC08.ETransactionType.DECLARE,sender_address:senderAddress,compiled_class_hash:compiledClassHash||"",version:RPCSPEC08.ETransactionVersion.V3,signature:signatureToHexArray(signature),nonce:toHex(details.nonce),contract_class:{sierra_program:decompressProgram(contract.sierra_program),contract_class_version:contract.contract_class_version,entry_points_by_type:contract.entry_points_by_type,abi:contract.abi},resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),account_deployment_data:details.accountDeploymentData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}async deployAccount({classHash,constructorCalldata,addressSalt,signature},details){let promise;if(!isV3Tx(details))throw Error(SYSTEM_MESSAGES.legacyTxRPC08Message);if(!isRPC08_ResourceBounds(details.resourceBounds))throw Error(SYSTEM_MESSAGES.SWOldV3);return promise=this.fetchEndpoint("starknet_addDeployAccountTransaction",{deploy_account_transaction:{type:RPCSPEC08.ETransactionType.DEPLOY_ACCOUNT,version:RPCSPEC08.ETransactionVersion.V3,signature:signatureToHexArray(signature),nonce:toHex(details.nonce),contract_address_salt:toHex(addressSalt||0),constructor_calldata:CallData.toHex(constructorCalldata||[]),class_hash:toHex(classHash),resource_bounds:details.resourceBounds,tip:toHex(details.tip),paymaster_data:details.paymasterData.map((it=>toHex(it))),nonce_data_availability_mode:details.nonceDataAvailabilityMode,fee_data_availability_mode:details.feeDataAvailabilityMode}}),this.waitMode?this.waitForTransaction((await promise).transaction_hash):promise}callContract(call,blockIdentifier=this.blockIdentifier){const block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_call",{request:{contract_address:call.contractAddress,entry_point_selector:getSelectorFromName(call.entrypoint),calldata:CallData.toHex(call.calldata)},block_id})}estimateMessageFee(message,blockIdentifier=this.blockIdentifier){const{from_address,to_address,entry_point_selector,payload}=message,formattedMessage={from_address:validateAndParseEthAddress(from_address),to_address:toHex(to_address),entry_point_selector:getSelector(entry_point_selector),payload:getHexStringArray(payload)},block_id=new Block(blockIdentifier).identifier;return this.fetchEndpoint("starknet_estimateMessageFee",{message:formattedMessage,block_id})}getSyncingStats(){return this.fetchEndpoint("starknet_syncing")}getEvents(eventFilter){return this.fetchEndpoint("starknet_getEvents",{filter:eventFilter})}buildTransaction(invocation,versionType){const defaultVersions=getVersionsByType(versionType);let details;if(!isV3Tx(invocation))throw Error("v0,v1,v2 tx are not supported on RPC 0.8");if(details={signature:signatureToHexArray(invocation.signature),nonce:toHex(invocation.nonce),resource_bounds:invocation.resourceBounds,tip:toHex(invocation.tip),paymaster_data:invocation.paymasterData.map((it=>toHex(it))),nonce_data_availability_mode:invocation.nonceDataAvailabilityMode,fee_data_availability_mode:invocation.feeDataAvailabilityMode,account_deployment_data:invocation.accountDeploymentData.map((it=>toHex(it)))},invocation.type===TransactionType.INVOKE)return{type:RPCSPEC08.ETransactionType.INVOKE,sender_address:invocation.contractAddress,calldata:CallData.toHex(invocation.calldata),version:toHex(invocation.version||defaultVersions.v3),...details};if(invocation.type===TransactionType.DECLARE){if(!isSierra(invocation.contract))throw logger.error("Cairo 0 -  non Sierra v1 tx are not supported"),Error("Declaring non Sierra contract using RPC 0.8");return{type:invocation.type,contract_class:{...invocation.contract,sierra_program:decompressProgram(invocation.contract.sierra_program)},compiled_class_hash:invocation.compiledClassHash||"",sender_address:invocation.senderAddress,version:toHex(invocation.version||defaultVersions.v3),...details}}if(invocation.type===TransactionType.DEPLOY_ACCOUNT){const{account_deployment_data,...restDetails}=details;return{type:invocation.type,constructor_calldata:CallData.toHex(invocation.constructorCalldata||[]),class_hash:toHex(invocation.classHash),contract_address_salt:toHex(invocation.addressSalt||0),version:toHex(invocation.version||defaultVersions.v3),...restDetails}}throw Error("RPC buildTransaction received unknown TransactionType")}},ws_default="undefined"!=typeof WebSocket&&WebSocket||"undefined"!=typeof globalThis&&globalThis.WebSocket||"undefined"!=typeof window&&window.WebSocket.bind(window)||void 0!==__webpack_require__.g&&__webpack_require__.g.WebSocket||class{constructor(){throw new LibraryError("WebSocket module not detected, use the 'websocket' constructor parameter to set a compatible connection")}},WSSubscriptions={NEW_HEADS:"newHeads",EVENTS:"events",TRANSACTION_STATUS:"transactionStatus",PENDING_TRANSACTION:"pendingTransactions"},WebSocketChannel=class{nodeUrl;websocket;onReorg=()=>{};onNewHeads=()=>{};onEvents=()=>{};onTransactionStatus=()=>{};onPendingTransaction=()=>{};onOpen=()=>{};onClose=()=>{};onMessage=()=>{};onError=()=>{};onUnsubscribe=()=>{};onUnsubscribeLocal=()=>{};sendId=0;subscriptions=new Map;constructor(options={}){const nodeUrl=options.nodeUrl||"http://localhost:3000 ";this.nodeUrl=options.websocket?options.websocket.url:nodeUrl,this.websocket=options.websocket||config.get("websocket")||new ws_default(nodeUrl),this.websocket.addEventListener("open",this.onOpen.bind(this)),this.websocket.addEventListener("close",this.onCloseProxy.bind(this)),this.websocket.addEventListener("message",this.onMessageProxy.bind(this)),this.websocket.addEventListener("error",this.onError.bind(this))}idResolver(id){return id||this.sendId++}send(method,params,id){if(!this.isConnected())throw Error("WebSocketChannel.send() fail due to socket disconnected");const usedId=this.idResolver(id),rpcRequestBody={id:usedId,jsonrpc:"2.0",method,...params&&{params}};return this.websocket.send(stringify2(rpcRequestBody)),usedId}sendReceiveAny(method,params){return this.sendReceive(method,params)}sendReceive(method,params){const sendId=this.send(method,params);return new Promise(((resolve,reject)=>{this.websocket&&(this.websocket.onmessage=({data})=>{const message=JSON.parse(data);message.id===sendId&&("result"in message?resolve(message.result):reject(Error(`error on ${method}, ${message.error}`)))},this.websocket.onerror=reject)}))}isConnected(){return this.websocket.readyState===ws_default.OPEN}async waitForConnection(){return this.websocket.readyState!==ws_default.OPEN?new Promise(((resolve,reject)=>{this.websocket&&(this.websocket.onopen=()=>resolve(this.websocket.readyState),this.websocket.onerror=error=>reject(error))})):this.websocket.readyState}disconnect(code,reason){this.websocket.close(code,reason)}async waitForDisconnection(){return this.websocket.readyState!==ws_default.CLOSED?new Promise(((resolve,reject)=>{this.websocket&&(this.websocket.onclose=()=>resolve(this.websocket.readyState),this.websocket.onerror=reject)})):this.websocket.readyState}async unsubscribe(subscriptionId,ref){const status=await this.sendReceive("starknet_unsubscribe",{subscription_id:subscriptionId});return status&&(ref&&this.subscriptions.delete(ref),this.onUnsubscribeLocal(subscriptionId),this.onUnsubscribe(subscriptionId)),status}async waitForUnsubscription(forSubscriptionId){return new Promise(((resolve,reject)=>{this.websocket&&(this.onUnsubscribeLocal=subscriptionId=>{(void 0===forSubscriptionId||subscriptionId===forSubscriptionId)&&resolve(subscriptionId)},this.websocket.onerror=reject)}))}reconnect(){this.websocket=new ws_default(this.nodeUrl),this.websocket.addEventListener("open",this.onOpen.bind(this)),this.websocket.addEventListener("close",this.onCloseProxy.bind(this)),this.websocket.addEventListener("message",this.onMessageProxy.bind(this)),this.websocket.addEventListener("error",this.onError.bind(this))}reconnectAndUpdate(){this.reconnect()}onCloseProxy(ev){this.websocket.removeEventListener("open",this.onOpen),this.websocket.removeEventListener("close",this.onCloseProxy),this.websocket.removeEventListener("message",this.onMessageProxy),this.websocket.removeEventListener("error",this.onError),this.onClose(ev)}onMessageProxy(event){const message=JSON.parse(event.data);switch(message.method){case"starknet_subscriptionReorg":this.onReorg(message.params);break;case"starknet_subscriptionNewHeads":this.onNewHeads(message.params);break;case"starknet_subscriptionEvents":this.onEvents(message.params);break;case"starknet_subscriptionTransactionStatus":this.onTransactionStatus(message.params);break;case"starknet_subscriptionPendingTransactions":this.onPendingTransaction(message.params)}this.onMessage(event)}subscribeNewHeadsUnmanaged(blockIdentifier){const block_id=blockIdentifier?new Block(blockIdentifier).identifier:void 0;return this.sendReceive("starknet_subscribeNewHeads",{block_id})}async subscribeNewHeads(blockIdentifier){if(this.subscriptions.get(WSSubscriptions.NEW_HEADS))return!1;const subId=await this.subscribeNewHeadsUnmanaged(blockIdentifier);return this.subscriptions.set(WSSubscriptions.NEW_HEADS,subId),subId}async unsubscribeNewHeads(){const subId=this.subscriptions.get(WSSubscriptions.NEW_HEADS);if(!subId)throw Error("There is no subscription on this event");return this.unsubscribe(subId,WSSubscriptions.NEW_HEADS)}subscribeEventsUnmanaged(fromAddress,keys,blockIdentifier){const block_id=blockIdentifier?new Block(blockIdentifier).identifier:void 0;return this.sendReceive("starknet_subscribeEvents",{from_address:void 0!==fromAddress?toHex(fromAddress):void 0,keys,block_id})}async subscribeEvents(fromAddress,keys,blockIdentifier){if(this.subscriptions.get(WSSubscriptions.EVENTS))return!1;const subId=await this.subscribeEventsUnmanaged(fromAddress,keys,blockIdentifier);return this.subscriptions.set(WSSubscriptions.EVENTS,subId),subId}unsubscribeEvents(){const subId=this.subscriptions.get(WSSubscriptions.EVENTS);if(!subId)throw Error("There is no subscription ID for this event");return this.unsubscribe(subId,WSSubscriptions.EVENTS)}subscribeTransactionStatusUnmanaged(transactionHash,blockIdentifier){const transaction_hash=toHex(transactionHash),block_id=blockIdentifier?new Block(blockIdentifier).identifier:void 0;return this.sendReceive("starknet_subscribeTransactionStatus",{transaction_hash,block_id})}async subscribeTransactionStatus(transactionHash){if(this.subscriptions.get(WSSubscriptions.TRANSACTION_STATUS))return!1;const subId=await this.subscribeTransactionStatusUnmanaged(transactionHash);return this.subscriptions.set(WSSubscriptions.TRANSACTION_STATUS,subId),subId}async unsubscribeTransactionStatus(){const subId=this.subscriptions.get(WSSubscriptions.TRANSACTION_STATUS);if(!subId)throw Error("There is no subscription ID for this event");return this.unsubscribe(subId,WSSubscriptions.TRANSACTION_STATUS)}subscribePendingTransactionUnmanaged(transactionDetails,senderAddress){return this.sendReceive("starknet_subscribePendingTransactions",{transaction_details:transactionDetails,sender_address:senderAddress&&bigNumberishArrayToHexadecimalStringArray(senderAddress)})}async subscribePendingTransaction(transactionDetails,senderAddress){if(this.subscriptions.get(WSSubscriptions.TRANSACTION_STATUS))return!1;const subId=await this.subscribePendingTransactionUnmanaged(transactionDetails,senderAddress);return this.subscriptions.set(WSSubscriptions.PENDING_TRANSACTION,subId),subId}async unsubscribePendingTransaction(){const subId=this.subscriptions.get(WSSubscriptions.PENDING_TRANSACTION);if(!subId)throw Error("There is no subscription ID for this event");return this.unsubscribe(subId,WSSubscriptions.PENDING_TRANSACTION)}},RPCResponseParser=class{margin;constructor(margin){this.margin=margin}estimatedFeeToMaxFee(estimatedFee){return estimatedFeeToMaxFee(estimatedFee,this.margin?.maxFee)}estimateFeeToBounds(estimate){return estimateFeeToBounds3(estimate,this.margin?.bounds)}parseGetBlockResponse(res){return res}parseTransactionReceipt(res){return res}parseFeeEstimateResponse(res){const val=res[0];return{overall_fee:toBigInt(val.overall_fee),unit:val.unit,l1_gas_consumed:tryToBigInt(val.l1_gas_consumed)??tryToBigInt(val.gas_consumed)??0n,l1_gas_price:tryToBigInt(val.l1_gas_price)??tryToBigInt(val.gas_price)??0n,l2_gas_consumed:tryToBigInt(val.l2_gas_consumed)??void 0,l2_gas_price:tryToBigInt(val.l2_gas_price)??void 0,l1_data_gas_consumed:tryToBigInt(val.l1_data_gas_consumed)??tryToBigInt(val.data_gas_consumed)??0n,l1_data_gas_price:tryToBigInt(val.l1_data_gas_price)??tryToBigInt(val.gas_price)??0n,suggestedMaxFee:this.estimatedFeeToMaxFee(val.overall_fee),resourceBounds:this.estimateFeeToBounds(val)}}parseFeeEstimateBulkResponse(res){return res.map((val=>({overall_fee:toBigInt(val.overall_fee),unit:val.unit,l1_gas_consumed:tryToBigInt(val.l1_gas_consumed)??tryToBigInt(val.gas_consumed)??0n,l1_gas_price:tryToBigInt(val.l1_gas_price)??tryToBigInt(val.gas_price)??0n,l2_gas_consumed:tryToBigInt(val.l2_gas_consumed)??void 0,l2_gas_price:tryToBigInt(val.l2_gas_price)??void 0,l1_data_gas_consumed:tryToBigInt(val.l1_data_gas_consumed)??tryToBigInt(val.data_gas_consumed)??0n,l1_data_gas_price:tryToBigInt(val.l1_data_gas_price)??tryToBigInt(val.gas_price)??0n,suggestedMaxFee:this.estimatedFeeToMaxFee(val.overall_fee),resourceBounds:this.estimateFeeToBounds(val)})))}parseSimulateTransactionResponse(res){return res.map((it=>({...it,suggestedMaxFee:this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),resourceBounds:this.estimateFeeToBounds(it.fee_estimation)})))}parseContractClassResponse(res){return{...res,abi:isString(res.abi)?JSON.parse(res.abi):res.abi}}parseL1GasPriceResponse(res){return res.l1_gas_price.price_in_wei}},ReceiptTx=class _ReceiptTx{statusReceipt;value;constructor(receipt){[this.statusReceipt,this.value]=_ReceiptTx.isSuccess(receipt)?["success",receipt]:_ReceiptTx.isReverted(receipt)?["reverted",receipt]:["error",new Error("Unknown response type")];for(const[key]of Object.entries(this))Object.defineProperty(this,key,{enumerable:!1});for(const[key,value]of Object.entries(receipt))Object.defineProperty(this,key,{enumerable:!0,writable:!1,value})}match(callbacks){return this.statusReceipt in callbacks?callbacks[this.statusReceipt](this.value):callbacks._()}isSuccess(){return"success"===this.statusReceipt}isReverted(){return"reverted"===this.statusReceipt}isError(){return"error"===this.statusReceipt}static isSuccess(transactionReceipt){return transactionReceipt.execution_status===TransactionExecutionStatus.SUCCEEDED}static isReverted(transactionReceipt){return transactionReceipt.execution_status===TransactionExecutionStatus.REVERTED}},typedData_exports={};__export(typedData_exports,{encodeData:()=>encodeData,encodeType:()=>encodeType,encodeValue:()=>encodeValue,getDependencies:()=>getDependencies,getMessageHash:()=>getMessageHash,getStructHash:()=>getStructHash,getTypeHash:()=>getTypeHash,isMerkleTreeType:()=>isMerkleTreeType,prepareSelector:()=>prepareSelector,validateTypedData:()=>validateTypedData,verifyMessage:()=>verifyMessage});var merkle_exports={};__export(merkle_exports,{MerkleTree:()=>MerkleTree,proofMerklePath:()=>proofMerklePath});var MerkleTree=class _MerkleTree{leaves;branches=[];root;hashMethod;constructor(leafHashes,hashMethod=computePedersenHash){this.hashMethod=hashMethod,this.leaves=leafHashes,this.root=this.build(leafHashes)}build(leaves){if(1===leaves.length)return leaves[0];leaves.length!==this.leaves.length&&this.branches.push(leaves);const newLeaves=[];for(let i=0;i<leaves.length;i+=2)i+1===leaves.length?newLeaves.push(_MerkleTree.hash(leaves[i],"0x0",this.hashMethod)):newLeaves.push(_MerkleTree.hash(leaves[i],leaves[i+1],this.hashMethod));return this.build(newLeaves)}static hash(a,b,hashMethod=computePedersenHash){const[aSorted,bSorted]=[BigInt(a),BigInt(b)].sort(((x,y)=>x>=y?1:-1));return hashMethod(aSorted,bSorted)}getProof(leaf,branch=this.leaves,hashPath=[]){const index=branch.indexOf(leaf);if(-1===index)throw new Error("leaf not found");if(1===branch.length)return hashPath;const isLeft=index%2==0,neededBranch=(isLeft?branch[index+1]:branch[index-1])??"0x0",newHashPath=[...hashPath,neededBranch],currentBranchLevelIndex=this.leaves.length===branch.length?-1:this.branches.findIndex((b=>b.length===branch.length)),nextBranch=this.branches[currentBranchLevelIndex+1]??[this.root];return this.getProof(_MerkleTree.hash(isLeft?leaf:neededBranch,isLeft?neededBranch:leaf,this.hashMethod),nextBranch,newHashPath)}};function proofMerklePath(root,leaf,path,hashMethod=computePedersenHash){if(0===path.length)return root===leaf;const[next,...rest]=path;return proofMerklePath(root,MerkleTree.hash(leaf,next,hashMethod),rest,hashMethod)}var presetTypes={u256:JSON.parse('[{ "name": "low", "type": "u128" }, { "name": "high", "type": "u128" }]'),TokenAmount:JSON.parse('[{ "name": "token_address", "type": "ContractAddress" }, { "name": "amount", "type": "u256" }]'),NftId:JSON.parse('[{ "name": "collection_address", "type": "ContractAddress" }, { "name": "token_id", "type": "u256" }]')},revisionConfiguration={[import_starknet_types_07.TypedDataRevision.ACTIVE]:{domain:"StarknetDomain",hashMethod:computePoseidonHashOnElements,hashMerkleMethod:computePoseidonHash,escapeTypeString:s=>`"${s}"`,presetTypes},[import_starknet_types_07.TypedDataRevision.LEGACY]:{domain:"StarkNetDomain",hashMethod:computePedersenHashOnElements,hashMerkleMethod:computePedersenHash,escapeTypeString:s=>s,presetTypes:{}}};function assertRange(data,type,{min,max}){const value=BigInt(data);assert(value>=min&&value<=max,`${value} (${type}) is out of bounds [${min}, ${max}]`)}function identifyRevision({types,domain}){return revisionConfiguration[import_starknet_types_07.TypedDataRevision.ACTIVE].domain in types&&domain.revision===import_starknet_types_07.TypedDataRevision.ACTIVE?import_starknet_types_07.TypedDataRevision.ACTIVE:revisionConfiguration[import_starknet_types_07.TypedDataRevision.LEGACY].domain in types&&(domain.revision??import_starknet_types_07.TypedDataRevision.LEGACY)===import_starknet_types_07.TypedDataRevision.LEGACY?import_starknet_types_07.TypedDataRevision.LEGACY:void 0}function getHex(value){try{return toHex(value)}catch(e){if(isString(value))return toHex(encodeShortString(value));throw new Error(`Invalid BigNumberish: ${value}`)}}function validateTypedData(data){const typedData=data;return Boolean(typedData.message&&typedData.primaryType&&typedData.types&&identifyRevision(typedData))}function prepareSelector(selector){return isHex(selector)?selector:getSelectorFromName(selector)}function isMerkleTreeType(type){return"merkletree"===type.type}function getDependencies(types,type,dependencies=[],contains="",revision=import_starknet_types_07.TypedDataRevision.LEGACY){let dependencyTypes=[type];return"*"===type[type.length-1]?dependencyTypes=[type.slice(0,-1)]:revision===import_starknet_types_07.TypedDataRevision.ACTIVE&&("enum"===type?dependencyTypes=[contains]:type.match(/^\(.*\)$/)&&(dependencyTypes=type.slice(1,-1).split(",").map((depType=>"*"===depType[depType.length-1]?depType.slice(0,-1):depType)))),dependencyTypes.filter((t=>!dependencies.includes(t)&&types[t])).reduce(((p,depType)=>[...p,...[depType,...types[depType].reduce(((previous,t)=>[...previous,...getDependencies(types,t.type,previous,t.contains,revision).filter((dependency=>!previous.includes(dependency)))]),[])].filter((dependency=>!p.includes(dependency)))]),[])}function encodeType(types,type,revision=import_starknet_types_07.TypedDataRevision.LEGACY){const allTypes=revision===import_starknet_types_07.TypedDataRevision.ACTIVE?{...types,...revisionConfiguration[revision].presetTypes}:types,[primary,...dependencies]=getDependencies(allTypes,type,void 0,void 0,revision),newTypes=primary?[primary,...dependencies.sort()]:[],esc=revisionConfiguration[revision].escapeTypeString;return newTypes.map((dependency=>{const dependencyElements=allTypes[dependency].map((t=>{const targetType="enum"===t.type&&revision===import_starknet_types_07.TypedDataRevision.ACTIVE?t.contains:t.type,typeString=targetType.match(/^\(.*\)$/)?`(${targetType.slice(1,-1).split(",").map((e=>e?esc(e):e)).join(",")})`:esc(targetType);return`${esc(t.name)}:${typeString}`}));return`${esc(dependency)}(${dependencyElements})`})).join("")}function getTypeHash(types,type,revision=import_starknet_types_07.TypedDataRevision.LEGACY){return getSelectorFromName(encodeType(types,type,revision))}function encodeValue(types,type,data,ctx={},revision=import_starknet_types_07.TypedDataRevision.LEGACY){if(types[type])return[type,getStructHash(types,type,data,revision)];if(revisionConfiguration[revision].presetTypes[type])return[type,getStructHash(revisionConfiguration[revision].presetTypes,type,data,revision)];if(type.endsWith("*")){const hashes=data.map((entry=>encodeValue(types,type.slice(0,-1),entry,void 0,revision)[1]));return[type,revisionConfiguration[revision].hashMethod(hashes)]}switch(type){case"enum":if(revision===import_starknet_types_07.TypedDataRevision.ACTIVE){const[variantKey,variantData]=Object.entries(data)[0],parentType=types[ctx.parent].find((t=>t.name===ctx.key)),enumType=types[parentType.contains],variantType=enumType.find((t=>t.name===variantKey)),variantIndex=enumType.indexOf(variantType),encodedSubtypes=variantType.type.slice(1,-1).split(",").map(((subtype,index)=>{if(!subtype)return subtype;const subtypeData=variantData[index];return encodeValue(types,subtype,subtypeData,void 0,revision)[1]}));return[type,revisionConfiguration[revision].hashMethod([variantIndex,...encodedSubtypes])]}return[type,getHex(data)];case"merkletree":{const merkleTreeType=function(types,ctx){if(ctx.parent&&ctx.key){const merkleType=types[ctx.parent].find((t=>t.name===ctx.key));if(!isMerkleTreeType(merkleType))throw new Error(`${ctx.key} is not a merkle tree`);if(merkleType.contains.endsWith("*"))throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);return merkleType.contains}return"raw"}(types,ctx),structHashes=data.map((struct=>encodeValue(types,merkleTreeType,struct,void 0,revision)[1])),{root}=new MerkleTree(structHashes,revisionConfiguration[revision].hashMerkleMethod);return["felt",root]}case"selector":return["felt",prepareSelector(data)];case"string":if(revision===import_starknet_types_07.TypedDataRevision.ACTIVE){const byteArray=byteArrayFromString(data),elements=[byteArray.data.length,...byteArray.data,byteArray.pending_word,byteArray.pending_word_len];return[type,revisionConfiguration[revision].hashMethod(elements)]}return[type,getHex(data)];case"i128":if(revision===import_starknet_types_07.TypedDataRevision.ACTIVE){const value=BigInt(data);return assertRange(value,type,RANGE_I128),[type,getHex(value<0n?PRIME+value:value)]}return[type,getHex(data)];case"timestamp":case"u128":return revision===import_starknet_types_07.TypedDataRevision.ACTIVE&&assertRange(data,type,RANGE_U128),[type,getHex(data)];case"felt":case"shortstring":return revision===import_starknet_types_07.TypedDataRevision.ACTIVE&&assertRange(getHex(data),type,RANGE_FELT),[type,getHex(data)];case"ClassHash":case"ContractAddress":return revision===import_starknet_types_07.TypedDataRevision.ACTIVE&&assertRange(data,type,RANGE_FELT),[type,getHex(data)];case"bool":return revision===import_starknet_types_07.TypedDataRevision.ACTIVE&&assert(isBoolean(data),`Type mismatch for ${type} ${data}`),[type,getHex(data)];default:if(revision===import_starknet_types_07.TypedDataRevision.ACTIVE)throw new Error(`Unsupported type: ${type}`);return[type,getHex(data)]}}function encodeData(types,type,data,revision=import_starknet_types_07.TypedDataRevision.LEGACY){const targetType=types[type]??revisionConfiguration[revision].presetTypes[type],[returnTypes,values]=targetType.reduce((([ts,vs],field)=>{if(void 0===data[field.name]||null===data[field.name]&&"enum"!==field.type)throw new Error(`Cannot encode data: missing data for '${field.name}'`);const value=data[field.name],ctx={parent:type,key:field.name},[t,encodedValue]=encodeValue(types,field.type,value,ctx,revision);return[[...ts,t],[...vs,encodedValue]]}),[["felt"],[getTypeHash(types,type,revision)]]);return[returnTypes,values]}function getStructHash(types,type,data,revision=import_starknet_types_07.TypedDataRevision.LEGACY){return revisionConfiguration[revision].hashMethod(encodeData(types,type,data,revision)[1])}function getMessageHash(typedData,accountAddress){if(!validateTypedData(typedData))throw new Error("Typed data does not match JSON schema");const revision=identifyRevision(typedData),{domain,hashMethod}=revisionConfiguration[revision];return hashMethod([encodeShortString("StarkNet Message"),getStructHash(typedData.types,domain,typedData.domain,revision),accountAddress,getStructHash(typedData.types,typedData.primaryType,typedData.message,revision)])}function verifyMessage(message,signature,fullPublicKey,accountAddress){const isTypedData=validateTypedData(message);if(!isBigNumberish(message)&&!isTypedData)throw new Error("message has a wrong format.");if(isTypedData&&void 0===accountAddress)throw new Error("When providing a TypedData in message parameter, the accountAddress parameter has to be provided.");if(isTypedData&&!isBigNumberish(accountAddress))throw new Error("accountAddress shall be a BigNumberish");const messageHash=isTypedData?getMessageHash(message,accountAddress):toHex(message),sign=Array.isArray(signature)?new starkCurve.Signature(BigInt(signature[0]),BigInt(signature[1])):signature,fullPubKey=toHex(fullPublicKey);return starkCurve.verify(sign,messageHash,fullPubKey)}var RpcProvider=class{responseParser;channel;constructor(optionsOrProvider){if(optionsOrProvider&&"channel"in optionsOrProvider)this.channel=optionsOrProvider.channel,this.responseParser="responseParser"in optionsOrProvider?optionsOrProvider.responseParser:new RPCResponseParser;else{if(optionsOrProvider&&optionsOrProvider.specVersion)if(isVersion("0.8",optionsOrProvider.specVersion))this.channel=new rpc_0_8_1_exports.RpcChannel({...optionsOrProvider,waitMode:!1});else{if(!isVersion("0.7",optionsOrProvider.specVersion))throw new Error(`unsupported channel for spec version: ${optionsOrProvider.specVersion}`);this.channel=new rpc_0_7_1_exports.RpcChannel({...optionsOrProvider,waitMode:!1})}else if(isVersion("0.8",config.get("rpcVersion")))this.channel=new rpc_0_8_1_exports.RpcChannel({...optionsOrProvider,waitMode:!1});else{if(!isVersion("0.7",config.get("rpcVersion")))throw new Error("unable to define spec version for channel");this.channel=new rpc_0_7_1_exports.RpcChannel({...optionsOrProvider,waitMode:!1})}this.responseParser=new RPCResponseParser(optionsOrProvider?.feeMarginPercentage)}}static async create(optionsOrProvider){const channel=new rpc_0_7_1_exports.RpcChannel({...optionsOrProvider}),spec=await channel.getSpecVersion();if(isSupportedSpecVersion(spec)||logger.warn(`Using incompatible node spec version ${spec}`),isVersion("0.7",spec))return new this({...optionsOrProvider,specVersion:_SupportedRpcVersion.v0_7_1});if(isVersion("0.8",spec))return new this({...optionsOrProvider,specVersion:_SupportedRpcVersion.v0_8_1});throw new LibraryError(`Provided RPC node specification version ${spec} is not compatible with the SDK. SDK supported RPC versions ${Object.keys(_SupportedRpcVersion).toString()}`)}fetch(method,params,id=0){return this.channel.fetch(method,params,id)}async getChainId(){return this.channel.getChainId()}readSpecVersion(){return this.channel.readSpecVersion()}async getSpecVersion(){return this.channel.getSpecVersion()}setUpSpecVersion(){return this.channel.setUpSpecVersion()}async getNonceForAddress(contractAddress,blockIdentifier){return this.channel.getNonceForAddress(contractAddress,blockIdentifier)}async getBlock(blockIdentifier){return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse)}async getBlockLatestAccepted(){return this.channel.getBlockLatestAccepted()}async getBlockNumber(){return this.channel.getBlockNumber()}async getBlockWithTxHashes(blockIdentifier){return this.channel.getBlockWithTxHashes(blockIdentifier)}async getBlockWithTxs(blockIdentifier){return this.channel.getBlockWithTxs(blockIdentifier)}async waitForBlock(blockIdentifier="pending",retryInterval=5e3){if(blockIdentifier===BlockTag.LATEST)return;const currentBlock=await this.getBlockNumber(),targetBlock=blockIdentifier===BlockTag.PENDING?currentBlock+1:Number(toHex(blockIdentifier));if(targetBlock<=currentBlock)return;const{retries}=this.channel;let retriesCount=retries,isTargetBlock=!1;for(;!isTargetBlock;){if(await this.getBlockNumber()===targetBlock?isTargetBlock=!0:await wait(retryInterval),retriesCount-=1,retriesCount<=0)throw new Error(`waitForBlock() timed-out after ${retries} tries.`)}}async getL1GasPrice(blockIdentifier){return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse)}async getL1MessageHash(l2TxHash){const transaction=await this.channel.getTransactionByHash(l2TxHash);assert("L1_HANDLER"===transaction.type,"This L2 transaction is not a L1 message.");const{calldata,contract_address,entry_point_selector,nonce}=transaction;return solidityUint256PackedKeccak256([calldata[0],contract_address,nonce,entry_point_selector,calldata.length-1,...calldata.slice(1)])}async getBlockWithReceipts(blockIdentifier){return this.channel.getBlockWithReceipts(blockIdentifier)}getStateUpdate=this.getBlockStateUpdate;async getBlockStateUpdate(blockIdentifier){return this.channel.getBlockStateUpdate(blockIdentifier)}async getBlockTransactionsTraces(blockIdentifier){return this.channel.getBlockTransactionsTraces(blockIdentifier)}async getBlockTransactionCount(blockIdentifier){return this.channel.getBlockTransactionCount(blockIdentifier)}async getTransaction(txHash){return this.channel.getTransactionByHash(txHash)}async getTransactionByHash(txHash){return this.channel.getTransactionByHash(txHash)}async getTransactionByBlockIdAndIndex(blockIdentifier,index){return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier,index)}async getTransactionReceipt(txHash){const txReceiptWoHelper=await this.channel.getTransactionReceipt(txHash),txReceiptWoHelperModified=this.responseParser.parseTransactionReceipt(txReceiptWoHelper);return new ReceiptTx(txReceiptWoHelperModified)}async getTransactionTrace(txHash){return this.channel.getTransactionTrace(txHash)}async getTransactionStatus(transactionHash){return this.channel.getTransactionStatus(transactionHash)}async getSimulateTransaction(invocations,options){return this.channel.simulateTransaction(invocations,options).then((r=>this.responseParser.parseSimulateTransactionResponse(r)))}async waitForTransaction(txHash,options){const receiptWoHelper=await this.channel.waitForTransaction(txHash,options);return new ReceiptTx(receiptWoHelper)}async getStorageAt(contractAddress,key,blockIdentifier){return this.channel.getStorageAt(contractAddress,key,blockIdentifier)}async getClassHashAt(contractAddress,blockIdentifier){return this.channel.getClassHashAt(contractAddress,blockIdentifier)}async getClassByHash(classHash){return this.getClass(classHash)}async getClass(classHash,blockIdentifier){return this.channel.getClass(classHash,blockIdentifier).then(this.responseParser.parseContractClassResponse)}async getClassAt(contractAddress,blockIdentifier){return this.channel.getClassAt(contractAddress,blockIdentifier).then(this.responseParser.parseContractClassResponse)}async getContractVersion(contractAddress,classHash,{blockIdentifier=this.channel.blockIdentifier,compiler=!0}={}){let contractClass;if(contractAddress)contractClass=await this.getClassAt(contractAddress,blockIdentifier);else{if(!classHash)throw Error("getContractVersion require contractAddress or classHash");contractClass=await this.getClass(classHash,blockIdentifier)}if(isSierra(contractClass)){if(compiler){return{cairo:"1",compiler:getAbiContractVersion(contractClass.abi).compiler}}return{cairo:"1",compiler:void 0}}return{cairo:"0",compiler:"0"}}async getInvokeEstimateFee(invocation,invocationDetails,blockIdentifier,skipValidate){return this.channel.getEstimateFee([{type:TransactionType.INVOKE,...invocation,...invocationDetails}],{blockIdentifier,skipValidate}).then((r=>this.responseParser.parseFeeEstimateResponse(r)))}async getDeclareEstimateFee(invocation,details,blockIdentifier,skipValidate){return this.channel.getEstimateFee([{type:TransactionType.DECLARE,...invocation,...details}],{blockIdentifier,skipValidate}).then((r=>this.responseParser.parseFeeEstimateResponse(r)))}async getDeployAccountEstimateFee(invocation,details,blockIdentifier,skipValidate){return this.channel.getEstimateFee([{type:TransactionType.DEPLOY_ACCOUNT,...invocation,...details}],{blockIdentifier,skipValidate}).then((r=>this.responseParser.parseFeeEstimateResponse(r)))}async getEstimateFeeBulk(invocations,options){return this.channel.getEstimateFee(invocations,options).then((r=>this.responseParser.parseFeeEstimateBulkResponse(r)))}async invokeFunction(functionInvocation,details){return this.channel.invoke(functionInvocation,details)}async declareContract(transaction,details){return this.channel.declare(transaction,details)}async deployAccountContract(transaction,details){return this.channel.deployAccount(transaction,details)}async callContract(call,blockIdentifier){return this.channel.callContract(call,blockIdentifier)}async estimateMessageFee(message,blockIdentifier){return this.channel.estimateMessageFee(message,blockIdentifier)}async getSyncingStats(){return this.channel.getSyncingStats()}async getEvents(eventFilter){return this.channel.getEvents(eventFilter)}async verifyMessageInStarknet(message,signature,accountAddress,signatureVerificationFunctionName,signatureVerificationResponse){const isTypedData=validateTypedData(message);if(!isBigNumberish(message)&&!isTypedData)throw new Error("message has a wrong format.");if(!isBigNumberish(accountAddress))throw new Error("accountAddress shall be a BigNumberish");const messageHash=isTypedData?getMessageHash(message,accountAddress):toHex(message),knownSigVerificationFName=signatureVerificationFunctionName?[signatureVerificationFunctionName]:["isValidSignature","is_valid_signature"],knownSignatureResponse=signatureVerificationResponse||{okResponse:[],nokResponse:["0x0","0x00"],error:["argent/invalid-signature","is invalid, with respect to the public key","INVALID_SIG"]};let error;for(const SigVerificationFName of knownSigVerificationFName)try{const resp=await this.callContract({contractAddress:toHex(accountAddress),entrypoint:SigVerificationFName,calldata:CallData.compile({hash:toBigInt(messageHash).toString(),signature:formatSignature(signature)})});if(knownSignatureResponse.nokResponse.includes(resp[0].toString()))return!1;if(0===knownSignatureResponse.okResponse.length||knownSignatureResponse.okResponse.includes(resp[0].toString()))return!0;throw Error("signatureVerificationResponse Error: response is not part of known responses")}catch(err){if(knownSignatureResponse.error.some((errMessage=>err.message.includes(errMessage))))return!1;error=err}throw Error(`Signature verification Error: ${error}`)}async isClassDeclared(contractClassIdentifier,blockIdentifier){let classHash;if(!contractClassIdentifier.classHash&&"contract"in contractClassIdentifier){classHash=extractContractHashes(contractClassIdentifier).classHash}else{if(!contractClassIdentifier.classHash)throw Error("contractClassIdentifier type not satisfied");classHash=contractClassIdentifier.classHash}try{return await this.getClass(classHash,blockIdentifier)instanceof Object}catch(error){if(error instanceof LibraryError)return!1;throw error}}async prepareInvocations(invocations){const bulk=[];for(const invocation of invocations)if(invocation.type===TransactionType.DECLARE){await this.isClassDeclared("payload"in invocation?invocation.payload:invocation)||bulk.unshift(invocation)}else bulk.push(invocation);return bulk}async getL1MessagesStatus(transactionHash){if(this.channel instanceof rpc_0_8_1_exports.RpcChannel)return this.channel.getMessagesStatus(transactionHash);throw new LibraryError("Unsupported method for RPC version")}async getStorageProof(classHashes,contractAddresses,contractsStorageKeys,blockIdentifier){if(this.channel instanceof rpc_0_8_1_exports.RpcChannel)return this.channel.getStorageProof(classHashes,contractAddresses,contractsStorageKeys,blockIdentifier);throw new LibraryError("Unsupported method for RPC version")}async getCompiledCasm(classHash){if(this.channel instanceof rpc_0_8_1_exports.RpcChannel)return this.channel.getCompiledCasm(classHash);throw new LibraryError("Unsupported method for RPC version")}},import_ts_mixer=__webpack_require__(6993),starknetId_exports={};__export(starknetId_exports,{StarknetIdContract:()=>StarknetIdContract,StarknetIdIdentityContract:()=>StarknetIdIdentityContract,StarknetIdMulticallContract:()=>StarknetIdMulticallContract,StarknetIdPfpContract:()=>StarknetIdPfpContract,StarknetIdPopContract:()=>StarknetIdPopContract,StarknetIdVerifierContract:()=>StarknetIdVerifierContract,dynamicCallData:()=>dynamicCallData,dynamicFelt:()=>dynamicFelt,execution:()=>execution,getStarknetIdContract:()=>getStarknetIdContract,getStarknetIdIdentityContract:()=>getStarknetIdIdentityContract,getStarknetIdMulticallContract:()=>getStarknetIdMulticallContract,getStarknetIdPfpContract:()=>getStarknetIdPfpContract,getStarknetIdPopContract:()=>getStarknetIdPopContract,getStarknetIdVerifierContract:()=>getStarknetIdVerifierContract,isStarkDomain:()=>isStarkDomain,useDecoded:()=>useDecoded,useEncoded:()=>useEncoded});var basicAlphabet="abcdefghijklmnopqrstuvwxyz0123456789-",basicSizePlusOne=BigInt(basicAlphabet.length+1),bigAlphabet="这来",basicAlphabetSize=BigInt(basicAlphabet.length),bigAlphabetSize=BigInt(bigAlphabet.length),bigAlphabetSizePlusOne=BigInt(bigAlphabet.length+1);function extractStars(str){let k=0;for(;str.endsWith(bigAlphabet[bigAlphabet.length-1]);)str=str.substring(0,str.length-1),k+=1;return[str,k]}function useDecoded(encoded){let decoded="";return encoded.forEach((subdomain=>{for(;subdomain!==ZERO;){const code=subdomain%basicSizePlusOne;if(subdomain/=basicSizePlusOne,code===BigInt(basicAlphabet.length)){const nextSubdomain=subdomain/bigAlphabetSizePlusOne;if(nextSubdomain===ZERO){const code2=subdomain%bigAlphabetSizePlusOne;subdomain=nextSubdomain,decoded+=code2===ZERO?basicAlphabet[0]:bigAlphabet[Number(code2)-1]}else{decoded+=bigAlphabet[Number(subdomain%bigAlphabetSize)],subdomain/=bigAlphabetSize}}else decoded+=basicAlphabet[Number(code)]}const[str,k]=extractStars(decoded);k&&(decoded=str+(k%2==0?bigAlphabet[bigAlphabet.length-1].repeat(k/2-1)+bigAlphabet[0]+basicAlphabet[1]:bigAlphabet[bigAlphabet.length-1].repeat((k-1)/2+1))),decoded+="."})),decoded?decoded.concat("stark"):decoded}function useEncoded(decoded){let encoded=BigInt(0),multiplier=BigInt(1);if(decoded.endsWith(bigAlphabet[0]+basicAlphabet[1])){const[str,k]=extractStars(decoded.substring(0,decoded.length-2));decoded=str+bigAlphabet[bigAlphabet.length-1].repeat(2*(k+1))}else{const[str,k]=extractStars(decoded);k&&(decoded=str+bigAlphabet[bigAlphabet.length-1].repeat(1+2*(k-1)))}for(let i=0;i<decoded.length;i+=1){const char=decoded[i],index=basicAlphabet.indexOf(char),bnIndex=BigInt(basicAlphabet.indexOf(char));if(-1!==index)i===decoded.length-1&&decoded[i]===basicAlphabet[0]?(encoded+=multiplier*basicAlphabetSize,multiplier*=basicSizePlusOne,multiplier*=basicSizePlusOne):(encoded+=multiplier*bnIndex,multiplier*=basicSizePlusOne);else if(-1!==bigAlphabet.indexOf(char)){encoded+=multiplier*basicAlphabetSize,multiplier*=basicSizePlusOne;const newid=(i===decoded.length-1?1:0)+bigAlphabet.indexOf(char);encoded+=multiplier*BigInt(newid),multiplier*=bigAlphabetSize}}return encoded}var StarknetIdContract={MAINNET:"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",TESTNET_SEPOLIA:"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474"};function getStarknetIdContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:return StarknetIdContract.MAINNET;case _StarknetChainId.SN_SEPOLIA:return StarknetIdContract.TESTNET_SEPOLIA;default:throw new Error("Starknet.id is not yet deployed on this network")}}var StarknetIdIdentityContract={MAINNET:"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af",TESTNET_SEPOLIA:"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda"};function getStarknetIdIdentityContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:return StarknetIdIdentityContract.MAINNET;case _StarknetChainId.SN_SEPOLIA:return StarknetIdIdentityContract.TESTNET_SEPOLIA;default:throw new Error("Starknet.id verifier contract is not yet deployed on this network")}}var StarknetIdMulticallContract="0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970";function getStarknetIdMulticallContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:case _StarknetChainId.SN_SEPOLIA:return StarknetIdMulticallContract;default:throw new Error("Starknet.id multicall contract is not yet deployed on this network")}}var StarknetIdVerifierContract={MAINNET:"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf",TESTNET_SEPOLIA:"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566"};function getStarknetIdVerifierContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:return StarknetIdVerifierContract.MAINNET;case _StarknetChainId.SN_SEPOLIA:return StarknetIdVerifierContract.TESTNET_SEPOLIA;default:throw new Error("Starknet.id verifier contract is not yet deployed on this network")}}var StarknetIdPfpContract={MAINNET:"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7",TESTNET_SEPOLIA:"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02"};function getStarknetIdPfpContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:return StarknetIdPfpContract.MAINNET;case _StarknetChainId.SN_SEPOLIA:return StarknetIdPfpContract.TESTNET_SEPOLIA;default:throw new Error("Starknet.id profile picture verifier contract is not yet deployed on this network")}}var StarknetIdPopContract={MAINNET:"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4",TESTNET_SEPOLIA:"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a"};function getStarknetIdPopContract(chainId){switch(chainId){case _StarknetChainId.SN_MAIN:return StarknetIdPopContract.MAINNET;case _StarknetChainId.SN_SEPOLIA:return StarknetIdPopContract.TESTNET_SEPOLIA;default:throw new Error("Starknet.id proof of personhood verifier contract is not yet deployed on this network")}}function execution(staticEx,ifEqual=void 0,ifNotEqual=void 0){return new CairoCustomEnum({Static:staticEx,IfEqual:ifEqual?tuple(ifEqual[0],ifEqual[1],ifEqual[2]):void 0,IfNotEqual:ifNotEqual?tuple(ifNotEqual[0],ifNotEqual[1],ifNotEqual[2]):void 0})}function dynamicFelt(hardcoded,reference=void 0){return new CairoCustomEnum({Hardcoded:hardcoded,Reference:reference?tuple(reference[0],reference[1]):void 0})}function dynamicCallData(hardcoded,reference=void 0,arrayReference=void 0){return new CairoCustomEnum({Hardcoded:hardcoded,Reference:reference?tuple(reference[0],reference[1]):void 0,ArrayReference:arrayReference?tuple(arrayReference[0],arrayReference[1]):void 0})}function isStarkDomain(domain){return/^(?:[a-z0-9-]{1,48}(?:[a-z0-9-]{1,48}[a-z0-9-])?\.)*[a-z0-9-]{1,48}\.stark$/.test(domain)}var StarknetId=class _StarknetId{async getStarkName(address,StarknetIdContract2){return _StarknetId.getStarkName(this,address,StarknetIdContract2)}async getAddressFromStarkName(name,StarknetIdContract2){return _StarknetId.getAddressFromStarkName(this,name,StarknetIdContract2)}async getStarkProfile(address,StarknetIdContract2,StarknetIdIdentityContract2,StarknetIdVerifierContract2,StarknetIdPfpContract2,StarknetIdPopContract2,StarknetIdMulticallContract2){return _StarknetId.getStarkProfile(this,address,StarknetIdContract2,StarknetIdIdentityContract2,StarknetIdVerifierContract2,StarknetIdPfpContract2,StarknetIdPopContract2,StarknetIdMulticallContract2)}static async getStarkName(provider,address,StarknetIdContract2){const chainId=await provider.getChainId(),contract=StarknetIdContract2??getStarknetIdContract(chainId);try{const hexDomain=await provider.callContract({contractAddress:contract,entrypoint:"address_to_domain",calldata:CallData.compile({address,hint:[]})}),stringDomain=useDecoded(hexDomain.map((element=>BigInt(element))).slice(1));if(!stringDomain)throw Error("Starkname not found");return stringDomain}catch(e){if(e instanceof Error&&"Starkname not found"===e.message)throw e;throw Error("Could not get stark name")}}static async getAddressFromStarkName(provider,name,StarknetIdContract2){const starkName=name.endsWith(".stark")?name:`${name}.stark`;if(!isStarkDomain(starkName))throw new Error("Invalid domain, must be a valid .stark domain");const chainId=await provider.getChainId(),contract=StarknetIdContract2??getStarknetIdContract(chainId);try{const encodedDomain=starkName.replace(".stark","").split(".").map((part=>useEncoded(part).toString(10)));return(await provider.callContract({contractAddress:contract,entrypoint:"domain_to_address",calldata:CallData.compile({domain:encodedDomain,hint:[]})}))[0]}catch{throw Error("Could not get address from stark name")}}static async getStarkProfile(provider,address,StarknetIdContract2,StarknetIdIdentityContract2,StarknetIdVerifierContract2,StarknetIdPfpContract2,StarknetIdPopContract2,StarknetIdMulticallContract2){const chainId=await provider.getChainId(),contract=StarknetIdContract2??getStarknetIdContract(chainId),identityContract=StarknetIdIdentityContract2??getStarknetIdIdentityContract(chainId),verifierContract=StarknetIdVerifierContract2??getStarknetIdVerifierContract(chainId),pfpContract=StarknetIdPfpContract2??getStarknetIdPfpContract(chainId),popContract=StarknetIdPopContract2??getStarknetIdPopContract(chainId),multicallAddress=StarknetIdMulticallContract2??getStarknetIdMulticallContract(chainId);try{const calls=[{execution:execution({}),to:dynamicCallData(contract),selector:dynamicCallData(getSelectorFromName("address_to_domain")),calldata:[dynamicCallData(address),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(contract),selector:dynamicFelt(getSelectorFromName("domain_to_id")),calldata:[dynamicCallData(void 0,void 0,[0,0])]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("twitter")),dynamicCallData(verifierContract),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("github")),dynamicCallData(verifierContract),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("discord")),dynamicCallData(verifierContract),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("proof_of_personhood")),dynamicCallData(popContract),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("nft_pp_contract")),dynamicCallData(pfpContract),dynamicCallData("0")]},{execution:execution({}),to:dynamicFelt(identityContract),selector:dynamicFelt(getSelectorFromName("get_extended_verifier_data")),calldata:[dynamicCallData(void 0,[1,0]),dynamicCallData(encodeShortString("nft_pp_id")),dynamicCallData("2"),dynamicCallData(pfpContract),dynamicCallData("0")]},{execution:execution(void 0,void 0,[6,0,0]),to:dynamicFelt(void 0,[6,0]),selector:dynamicFelt(getSelectorFromName("tokenURI")),calldata:[dynamicCallData(void 0,[7,1]),dynamicCallData(void 0,[7,2])]}],data=await provider.callContract({contractAddress:multicallAddress,entrypoint:"aggregate",calldata:CallData.compile({calls})});if(Array.isArray(data)){const size=parseInt(data[0],16),finalArray=[];let index=1;for(let i=0;i<size&&index<data.length;i+=1){const subArraySize=parseInt(data[index],16);index+=1;const subArray=data.slice(index,index+subArraySize);finalArray.push(subArray),index+=subArraySize}const name=useDecoded(finalArray[0].slice(1).map((hexString=>BigInt(hexString)))),twitter="0x0"!==finalArray[2][0]?BigInt(finalArray[2][0]).toString():void 0,github="0x0"!==finalArray[3][0]?BigInt(finalArray[3][0]).toString():void 0,discord="0x0"!==finalArray[4][0]?BigInt(finalArray[4][0]).toString():void 0,proofOfPersonhood="0x1"===finalArray[5][0],profilePictureMetadata="0x9"===data[0]?finalArray[8].slice(1).map((val=>decodeShortString(val))).join(""):void 0;return{name,twitter,github,discord,proofOfPersonhood,profilePicture:profilePictureMetadata||`https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`}}throw Error("Error while calling aggregate function")}catch(e){if(e instanceof Error)throw e;throw Error("Could not get user stark profile data from address")}}},RpcProvider2=class extends((0,import_ts_mixer.Mixin)(RpcProvider,StarknetId)){},ProviderInterface=class{},defaultProvider=new RpcProvider({default:!0}),SignerInterface=class{},Signer=class{pk;constructor(pk=starkCurve.utils.randomPrivateKey()){this.pk=pk instanceof Uint8Array?buf2hex(pk):toHex(pk)}async getPubKey(){return starkCurve.getStarkKey(this.pk)}async signMessage(typedData,accountAddress){const msgHash=getMessageHash(typedData,accountAddress);return this.signRaw(msgHash)}async signTransaction(transactions,details){const compiledCalldata=getExecuteCalldata(transactions,details.cairoVersion);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signTransaction version");{const det=details;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signDeployAccountTransaction(details){const compiledConstructorCalldata=CallData.compile(details.constructorCalldata);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,constructorCalldata:compiledConstructorCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeployAccountTransaction version");{const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,compiledConstructorCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signDeclareTransaction(details){let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeclareTransaction version");{const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signRaw(msgHash){return starkCurve.sign(msgHash,this.pk)}},import_secp256k12=__webpack_require__(8510),uint256_exports={};function uint256ToBN(uint2562){return new CairoUint256(uint2562).toBigInt()}function isUint256(bn){return CairoUint256.is(bn)}function bnToUint256(bn){return new CairoUint256(bn).toUint256HexString()}__export(uint256_exports,{bnToUint256:()=>bnToUint256,isUint256:()=>isUint256,uint256ToBN:()=>uint256ToBN});var EthSigner=class{pk;constructor(pk=ethRandomPrivateKey()){this.pk=pk instanceof Uint8Array?buf2hex(pk).padStart(64,"0"):removeHexPrefix(toHex(pk)).padStart(64,"0")}async getPubKey(){return addHexPrefix(buf2hex(import_secp256k12.secp256k1.getPublicKey(this.pk,!1)).padStart(130,"0").slice(2))}async signMessage(typedData,accountAddress){const msgHash=getMessageHash(typedData,accountAddress),signature=import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)),this.pk);return this.formatEthSignature(signature)}async signTransaction(transactions,details){const compiledCalldata=getExecuteCalldata(transactions,details.cairoVersion);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signTransaction version");{const det=details;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}const signature=import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)),this.pk);return this.formatEthSignature(signature)}async signDeployAccountTransaction(details){const compiledConstructorCalldata=CallData.compile(details.constructorCalldata);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,constructorCalldata:compiledConstructorCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeployAccountTransaction version");{const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,compiledConstructorCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}const signature=import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)),this.pk);return this.formatEthSignature(signature)}async signDeclareTransaction(details){let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeclareTransaction version");{const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}const signature=import_secp256k12.secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)),this.pk);return this.formatEthSignature(signature)}formatEthSignature(ethSignature){const r=bnToUint256(ethSignature.r),s=bnToUint256(ethSignature.s);return[toHex(r.low),toHex(r.high),toHex(s.low),toHex(s.high),toHex(ethSignature.recovery)]}},LedgerSigner111=class{transporter;_transporter;accountID;eip2645applicationName;pathBuffer;appVersion;pubKey;fullPubKey;constructor(transport,accountID,eip2645application="LedgerW",pathFunction=getLedgerPathBuffer111){assert(accountID>=0,"Ledger account ID shall not be a negative number."),assert(accountID<=MASK_31,"Ledger account ID shall be < 2**31."),assert(!!eip2645application,"Ledger application name shall not be empty."),this.transporter=transport,this._transporter=this.transporter,this.accountID=accountID,this.pubKey="",this.fullPubKey="",this.eip2645applicationName=eip2645application,this.appVersion="",this.pathBuffer=pathFunction(this.accountID,this.eip2645applicationName)}async getPubKey(){return this.pubKey||await this.getPublicKeys(),this.pubKey}async getFullPubKey(){return this.fullPubKey||await this.getPublicKeys(),this.fullPubKey}async getAppVersion(){if(!this.appVersion){const resp=await this._transporter.send(Number("0x5a"),0,0,0);this.appVersion=`${resp[0]}.${resp[1]}.${resp[2]}`}return this.appVersion}async signMessage(typedDataToHash,accountAddress){const msgHash=getMessageHash(typedDataToHash,accountAddress);return this.signRaw(msgHash)}async signTransaction(transactions,transactionsDetail){const compiledCalldata=getExecuteCalldata(transactions,transactionsDetail.cairoVersion);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(transactionsDetail.version)){const det=transactionsDetail;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(transactionsDetail.version))throw Error("unsupported signTransaction version");{const det=transactionsDetail;msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signDeployAccountTransaction(details){const compiledConstructorCalldata=CallData.compile(details.constructorCalldata);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,constructorCalldata:compiledConstructorCalldata,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeployAccountTransaction version");{const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,compiledConstructorCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signDeclareTransaction(details){let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version})}else{if(!Object.values(api_exports.ETransactionVersion3).includes(details.version))throw Error("unsupported signDeclareTransaction version");{const det=details;msgHash=calculateDeclareTransactionHash3({...det,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)})}}return this.signRaw(msgHash)}async signRaw(msgHash){addHexPrefix(buf2hex(await this._transporter.send(Number("0x5a"),2,0,0,Buffer.from(this.pathBuffer))));const buff2=hexToBytes(toHex(BigInt(msgHash)<<4n)),respSign2=Uint8Array.from(await this._transporter.send(Number("0x5a"),2,1,0,Buffer.from(buff2))),r=BigInt(addHexPrefix(buf2hex(respSign2.subarray(1,33)))),s=BigInt(addHexPrefix(buf2hex(respSign2.subarray(33,65)))),v=respSign2[65];return new starkCurve.Signature(r,s).addRecoveryBit(v)}async getPublicKeys(){const pathBuff=this.pathBuffer,respGetPublic=Uint8Array.from(await this._transporter.send(Number("0x5a"),1,0,0,Buffer.from(pathBuff)));this.pubKey=addHexPrefix(buf2hex(respGetPublic.subarray(1,33))),this.fullPubKey=addHexPrefix(buf2hex(respGetPublic.subarray(0,65)))}};function getLedgerPathBuffer111(accountId,applicationName="LedgerW"){return concatenateArrayBuffer([new Uint8Array([128,0,10,85]),new Uint8Array([71,65,233,201]),"LedgerW"===applicationName?new Uint8Array([43,206,231,219]):stringToSha256ToArrayBuff4(applicationName),new Uint8Array([0,0,0,0]),hexToBytes(addHexPrefix(removeHexPrefix(toHex(accountId)).padStart(8,"0"))),new Uint8Array([0,0,0,0])])}var import_utils3=__webpack_require__(91484);function addAddressPadding(address){const hex=toHex(isString(address)?addHexPrefix(address):address);return addHexPrefix(removeHexPrefix(hex).padStart(64,"0"))}function validateAndParseAddress(address){const result=addAddressPadding(address);if(!result.match(/^(0x)?[0-9a-fA-F]{64}$/))throw new Error("Invalid Address Format");return assertInRange(result,ZERO,ADDR_BOUND-1n,"Starknet Address"),result}function getChecksumAddress(address){const chars=removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(""),hex=removeHexPrefix(keccakBn(address)),hashed=(0,import_utils3.hexToBytes)(hex.padStart(64,"0"));for(let i=0;i<chars.length;i+=2)hashed[i>>1]>>4>=8&&(chars[i]=chars[i].toUpperCase()),(15&hashed[i>>1])>=8&&(chars[i+1]=chars[i+1].toUpperCase());return addHexPrefix(chars.join(""))}function validateChecksumAddress(address){return getChecksumAddress(address)===address}var LedgerSigner221=class extends LedgerSigner111{constructor(transport,accountID,eip2645application="LedgerW",pathFunction=getLedgerPathBuffer221){super(transport,accountID,eip2645application,pathFunction)}async signTransaction(transactions,transactionsDetail){const compiledCalldata=getExecuteCalldata(transactions,transactionsDetail.cairoVersion);if(Object.values(api_exports.ETransactionVersion2).includes(transactionsDetail.version)){const det=transactionsDetail,msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version}),ledgerResponse=await this.signTxV1(det,transactions);return assert(toBigInt(msgHash)===ledgerResponse.hash,"The V1 transaction hash calculated by Starknet.js is different from the one calculated by the Ledger."),ledgerResponse.signature}if(Object.values(api_exports.ETransactionVersion3).includes(transactionsDetail.version)){const det=transactionsDetail,msgHash=calculateInvokeTransactionHash2({...det,senderAddress:det.walletAddress,compiledCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)}),ledgerResponse=await this.signTxV3(det,transactions);return assert(toBigInt(msgHash)===ledgerResponse.hash,"The V3 transaction hash calculated by Starknet.js is different from the one calculated by the Ledger."),ledgerResponse.signature}throw Error("unsupported signTransaction version")}async signDeployAccountTransaction(details){const compiledConstructorCalldata=CallData.compile(details.constructorCalldata);let msgHash;if(Object.values(api_exports.ETransactionVersion2).includes(details.version)){const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,constructorCalldata:compiledConstructorCalldata,version:det.version});const ledgerResponse=await this.signDeployAccountV1(det);return assert(toBigInt(msgHash)===ledgerResponse.hash,"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger."),ledgerResponse.signature}if(Object.values(api_exports.ETransactionVersion3).includes(details.version)){const det=details;msgHash=calculateDeployAccountTransactionHash3({...det,salt:det.addressSalt,compiledConstructorCalldata,version:det.version,nonceDataAvailabilityMode:intDAM(det.nonceDataAvailabilityMode),feeDataAvailabilityMode:intDAM(det.feeDataAvailabilityMode)});const ledgerResponse=await this.signDeployAccountV3(det);return assert(toBigInt(msgHash)===ledgerResponse.hash,"The transaction hash calculated by Starknet.js is different from the one calculated by the Ledger."),ledgerResponse.signature}throw Error("unsupported signDeployAccountTransaction version")}convertBnToLedger(input){return hexToBytes(addAddressPadding(toHex(input)))}decodeSignatureLedger(respSign){const h=BigInt(addHexPrefix(buf2hex(respSign.subarray(0,32)))),r=BigInt(addHexPrefix(buf2hex(respSign.subarray(33,65)))),s=BigInt(addHexPrefix(buf2hex(respSign.subarray(65,97)))),v=respSign[97];return{hash:h,signature:new starkCurve.Signature(r,s).addRecoveryBit(v)}}encodeCall(call){const toBuf=this.convertBnToLedger(call.contractAddress),selectorBuf=hexToBytes(addAddressPadding(getSelector(call.entrypoint)));let calldataBuf=new Uint8Array([]);if(call.calldata){calldataBuf=concatenateArrayBuffer(CallData.compile(call.calldata).map((parameter=>this.convertBnToLedger(parameter))))}const callBuf=concatenateArrayBuffer([toBuf,selectorBuf,calldataBuf]),calldatas=[];for(let i=0;i<callBuf.length;i+=224)calldatas.push(callBuf.subarray(i,i+224));return calldatas}async signTxV1(txDetails,calls){await this._transporter.send(Number("0x5a"),4,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(txDetails.walletAddress),this.convertBnToLedger(txDetails.maxFee),this.convertBnToLedger(txDetails.chainId),this.convertBnToLedger(txDetails.nonce)]);await this._transporter.send(Number("0x5a"),4,1,0,Buffer.from(dataBuf));const nbCallsBuf=this.convertBnToLedger(calls.length);await this._transporter.send(Number("0x5a"),4,2,0,Buffer.from(nbCallsBuf));let respSign=new Uint8Array(0);for(const call of calls){const calldatas=this.encodeCall(call);await this._transporter.send(Number("0x5a"),4,3,0,Buffer.from(calldatas[0])),calldatas.length>1&&calldatas.slice(1).forEach((async part=>{await this._transporter.send(Number("0x5a"),4,3,1,Buffer.from(part))})),respSign=await this._transporter.send(Number("0x5a"),4,3,2)}return this.decodeSignatureLedger(respSign)}async signTxV3(txDetails,calls){assert(txDetails.paymasterData.length<=7,"Paymaster data includes more than 7 items."),assert(txDetails.accountDeploymentData.length<=7,"accountDeploymentData includes more than 7 items"),await this._transporter.send(Number("0x5a"),3,0,0,Buffer.from(this.pathBuffer));const accountAddressBuf=this.convertBnToLedger(txDetails.walletAddress),tipBuf=this.convertBnToLedger(txDetails.tip),chainIdBuf=this.convertBnToLedger(txDetails.chainId),nonceBuf=this.convertBnToLedger(txDetails.nonce),dAModeHashBuf=this.convertBnToLedger(hashDAMode(txDetails.nonceDataAvailabilityMode===api_exports.EDataAvailabilityMode.L1?api_exports.EDAMode.L1:api_exports.EDAMode.L2,txDetails.feeDataAvailabilityMode===api_exports.EDataAvailabilityMode.L1?api_exports.EDAMode.L1:api_exports.EDAMode.L2)),dataBuf=concatenateArrayBuffer([accountAddressBuf,tipBuf,this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds)),chainIdBuf,nonceBuf,dAModeHashBuf]);await this._transporter.send(Number("0x5a"),3,1,0,Buffer.from(dataBuf));const paymasterBuf=concatenateArrayBuffer(txDetails.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),3,2,0,Buffer.from(paymasterBuf));const accountDeployDataBuf=concatenateArrayBuffer(txDetails.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),3,3,0,Buffer.from(accountDeployDataBuf));const nbCallsBuf=this.convertBnToLedger(calls.length);await this._transporter.send(Number("0x5a"),3,4,0,Buffer.from(nbCallsBuf));let respSign=new Uint8Array(0);for(const call of calls){const calldatas=this.encodeCall(call);await this._transporter.send(Number("0x5a"),3,5,0,Buffer.from(calldatas[0])),calldatas.length>1&&calldatas.slice(1).forEach((async part=>{await this._transporter.send(Number("0x5a"),3,5,1,Buffer.from(part))})),respSign=await this._transporter.send(Number("0x5a"),3,5,2)}return this.decodeSignatureLedger(respSign)}async signDeployAccountV1(deployAccountDetail){await this._transporter.send(Number("0x5a"),6,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.contractAddress),this.convertBnToLedger(deployAccountDetail.classHash),this.convertBnToLedger(deployAccountDetail.addressSalt),this.convertBnToLedger(deployAccountDetail.chainId),this.convertBnToLedger(deployAccountDetail.nonce)]);await this._transporter.send(Number("0x5a"),6,1,0,Buffer.from(dataBuf));const maxFreeBuf=this.convertBnToLedger(deployAccountDetail.maxFee);await this._transporter.send(Number("0x5a"),6,2,0,Buffer.from(maxFreeBuf));const compiledConstructor=CallData.compile(deployAccountDetail.constructorCalldata),constructorLengthBuf=this.convertBnToLedger(compiledConstructor.length);await this._transporter.send(Number("0x5a"),6,3,0,Buffer.from(constructorLengthBuf));const constructorBuf=concatenateArrayBuffer(compiledConstructor.map((parameter=>this.convertBnToLedger(parameter)))),constructorChunks=[];for(let i=0;i<constructorBuf.length;i+=224)constructorChunks.push(constructorBuf.subarray(i,i+224));let respSign=new Uint8Array(0);for(const chunk of constructorChunks)respSign=await this._transporter.send(Number("0x5a"),6,4,0,Buffer.from(chunk));return this.decodeSignatureLedger(respSign)}async signDeployAccountV3(deployAccountDetail){await this._transporter.send(Number("0x5a"),5,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.contractAddress),this.convertBnToLedger(deployAccountDetail.chainId),this.convertBnToLedger(deployAccountDetail.nonce),this.convertBnToLedger(hashDAMode(deployAccountDetail.nonceDataAvailabilityMode===api_exports.EDataAvailabilityMode.L1?api_exports.EDAMode.L1:api_exports.EDAMode.L2,deployAccountDetail.feeDataAvailabilityMode===api_exports.EDataAvailabilityMode.L1?api_exports.EDAMode.L1:api_exports.EDAMode.L2)),this.convertBnToLedger(deployAccountDetail.classHash),this.convertBnToLedger(deployAccountDetail.addressSalt)]);await this._transporter.send(Number("0x5a"),5,1,0,Buffer.from(dataBuf));const feeBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.tip),this.convertBnToLedger(encodeResourceBoundsL1(deployAccountDetail.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(deployAccountDetail.resourceBounds))]);await this._transporter.send(Number("0x5a"),5,2,0,Buffer.from(feeBuf));const paymasterBuf=concatenateArrayBuffer(deployAccountDetail.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),5,3,0,Buffer.from(paymasterBuf));const compiledConstructor=CallData.compile(deployAccountDetail.constructorCalldata),constructorLengthBuf=this.convertBnToLedger(compiledConstructor.length);await this._transporter.send(Number("0x5a"),5,4,0,Buffer.from(constructorLengthBuf));const constructorBuf=concatenateArrayBuffer(compiledConstructor.map((parameter=>this.convertBnToLedger(parameter)))),constructorChunks=[];for(let i=0;i<constructorBuf.length;i+=224)constructorChunks.push(constructorBuf.subarray(i,i+224));let respSign=new Uint8Array(0);for(const chunk of constructorChunks)respSign=await this._transporter.send(Number("0x5a"),5,5,0,Buffer.from(chunk));return this.decodeSignatureLedger(respSign)}};function getLedgerPathBuffer221(accountId,applicationName="LedgerW"){const path0buff=new Uint8Array([HARDENING_BYTE,0,10,85]),path1buff=new Uint8Array([71|HARDENING_BYTE,65,233,201]),path2Base="LedgerW"===applicationName?new Uint8Array([43,206,231,219]):stringToSha256ToArrayBuff4(applicationName),path2buff=concatenateArrayBuffer([new Uint8Array([path2Base[0]|HARDENING_BYTE]),path2Base.subarray(1)]);return concatenateArrayBuffer([path0buff,path1buff,path2buff,new Uint8Array([HARDENING_BYTE,0,0,0]),hexToBytes(addHexPrefix(removeHexPrefix(toHex(BigInt(accountId)|HARDENING_4BYTES)).padStart(8,"0"))),new Uint8Array([0,0,0,0])])}var LedgerSigner231=class extends LedgerSigner221{constructor(transport,accountID,eip2645application="LedgerW",pathFunction=getLedgerPathBuffer221){super(transport,accountID,eip2645application,pathFunction)}async signTxV1(txDetails,calls){await this._transporter.send(Number("0x5a"),4,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(txDetails.walletAddress),this.convertBnToLedger(txDetails.maxFee),this.convertBnToLedger(txDetails.chainId),this.convertBnToLedger(txDetails.nonce)]);await this._transporter.send(Number("0x5a"),4,1,0,Buffer.from(dataBuf));const nbCallsBuf=this.convertBnToLedger(calls.length);await this._transporter.send(Number("0x5a"),4,2,0,Buffer.from(nbCallsBuf));let respSign=new Uint8Array(0);for(const call of calls){const calldatas=this.encodeCall(call);respSign=await this._transporter.send(Number("0x5a"),4,3,0,Buffer.from(calldatas[0])),calldatas.length>1&&calldatas.slice(1).forEach((async part=>{respSign=await this._transporter.send(Number("0x5a"),4,3,1,Buffer.from(part))}))}return this.decodeSignatureLedger(respSign)}async signTxV3(txDetails,calls){assert(txDetails.paymasterData.length<=7,"Paymaster data includes more than 7 items."),assert(txDetails.accountDeploymentData.length<=7,"accountDeploymentData includes more than 7 items"),await this._transporter.send(Number("0x5a"),3,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(txDetails.walletAddress),this.convertBnToLedger(txDetails.chainId),this.convertBnToLedger(txDetails.nonce),this.convertBnToLedger(hashDAMode(intDAM(txDetails.nonceDataAvailabilityMode),intDAM(txDetails.feeDataAvailabilityMode)))]);if(await this._transporter.send(Number("0x5a"),3,1,0,Buffer.from(dataBuf)),isRPC08_ResourceBounds(txDetails.resourceBounds)){const feeBuf=concatenateArrayBuffer([this.convertBnToLedger(txDetails.tip),this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds)),this.convertBnToLedger(encodeDataResourceBoundsL1(txDetails.resourceBounds))]);await this._transporter.send(Number("0x5a"),3,2,0,Buffer.from(feeBuf))}else{const feeBuf=concatenateArrayBuffer([this.convertBnToLedger(txDetails.tip),this.convertBnToLedger(encodeResourceBoundsL1(txDetails.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(txDetails.resourceBounds))]);await this._transporter.send(Number("0x5a"),3,2,0,Buffer.from(feeBuf))}const paymasterBuf=concatenateArrayBuffer(txDetails.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),3,3,0,Buffer.from(paymasterBuf));const accountDeployDataBuf=concatenateArrayBuffer(txDetails.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),3,4,0,Buffer.from(accountDeployDataBuf));const nbCallsBuf=this.convertBnToLedger(calls.length);await this._transporter.send(Number("0x5a"),3,5,0,Buffer.from(nbCallsBuf));let respSign=new Uint8Array(0);for(const call of calls){const calldatas=this.encodeCall(call);respSign=await this._transporter.send(Number("0x5a"),3,6,0,Buffer.from(calldatas[0])),calldatas.length>1&&calldatas.slice(1).forEach((async part=>{respSign=await this._transporter.send(Number("0x5a"),3,6,1,Buffer.from(part))}))}return this.decodeSignatureLedger(respSign)}async signDeployAccountV1(deployAccountDetail){await this._transporter.send(Number("0x5a"),6,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.contractAddress),this.convertBnToLedger(deployAccountDetail.classHash),this.convertBnToLedger(deployAccountDetail.addressSalt),this.convertBnToLedger(deployAccountDetail.maxFee),this.convertBnToLedger(deployAccountDetail.chainId),this.convertBnToLedger(deployAccountDetail.nonce)]);await this._transporter.send(Number("0x5a"),6,1,0,Buffer.from(dataBuf));const compiledConstructor=CallData.compile(deployAccountDetail.constructorCalldata),constructorLengthBuf=this.convertBnToLedger(compiledConstructor.length);await this._transporter.send(Number("0x5a"),6,2,0,Buffer.from(constructorLengthBuf));const constructorBuf=concatenateArrayBuffer(compiledConstructor.map((parameter=>this.convertBnToLedger(parameter)))),constructorChunks=[];for(let i=0;i<constructorBuf.length;i+=224)constructorChunks.push(constructorBuf.subarray(i,i+224));let respSign=new Uint8Array(0);for(const chunk of constructorChunks)respSign=await this._transporter.send(Number("0x5a"),6,3,0,Buffer.from(chunk));return this.decodeSignatureLedger(respSign)}async signDeployAccountV3(deployAccountDetail){await this._transporter.send(Number("0x5a"),5,0,0,Buffer.from(this.pathBuffer));const dataBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.contractAddress),this.convertBnToLedger(deployAccountDetail.chainId),this.convertBnToLedger(deployAccountDetail.nonce),this.convertBnToLedger(hashDAMode(intDAM(deployAccountDetail.nonceDataAvailabilityMode),intDAM(deployAccountDetail.feeDataAvailabilityMode))),this.convertBnToLedger(deployAccountDetail.classHash),this.convertBnToLedger(deployAccountDetail.addressSalt)]);if(await this._transporter.send(Number("0x5a"),5,1,0,Buffer.from(dataBuf)),isRPC08_ResourceBounds(deployAccountDetail.resourceBounds)){const feeBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.tip),this.convertBnToLedger(encodeResourceBoundsL1(deployAccountDetail.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(deployAccountDetail.resourceBounds)),this.convertBnToLedger(encodeDataResourceBoundsL1(deployAccountDetail.resourceBounds))]);await this._transporter.send(Number("0x5a"),5,2,0,Buffer.from(feeBuf))}else{const feeBuf=concatenateArrayBuffer([this.convertBnToLedger(deployAccountDetail.tip),this.convertBnToLedger(encodeResourceBoundsL1(deployAccountDetail.resourceBounds)),this.convertBnToLedger(encodeResourceBoundsL2(deployAccountDetail.resourceBounds))]);await this._transporter.send(Number("0x5a"),5,2,0,Buffer.from(feeBuf))}const paymasterBuf=concatenateArrayBuffer(deployAccountDetail.paymasterData.map((value=>this.convertBnToLedger(value))));await this._transporter.send(Number("0x5a"),5,3,0,Buffer.from(paymasterBuf));const compiledConstructor=CallData.compile(deployAccountDetail.constructorCalldata),constructorLengthBuf=this.convertBnToLedger(compiledConstructor.length);await this._transporter.send(Number("0x5a"),5,4,0,Buffer.from(constructorLengthBuf));const constructorBuf=concatenateArrayBuffer(compiledConstructor.map((parameter=>this.convertBnToLedger(parameter)))),constructorChunks=[];for(let i=0;i<constructorBuf.length;i+=224)constructorChunks.push(constructorBuf.subarray(i,i+224));let respSign=new Uint8Array(0);for(const chunk of constructorChunks)respSign=await this._transporter.send(Number("0x5a"),5,5,0,Buffer.from(chunk));return this.decodeSignatureLedger(respSign)}encodeCall(call){const toBuf=this.convertBnToLedger(call.contractAddress),selectorBuf=hexToBytes(addAddressPadding(getSelector(call.entrypoint)));let calldataBuf=new Uint8Array([]);if(call.calldata){const compiledCalldata=CallData.compile(call.calldata);calldataBuf=concatenateArrayBuffer([this.convertBnToLedger(compiledCalldata.length),...compiledCalldata.map((parameter=>this.convertBnToLedger(parameter)))])}else calldataBuf=this.convertBnToLedger("0x00");const callBuf=concatenateArrayBuffer([toBuf,selectorBuf,calldataBuf]),calldatas=[];for(let i=0;i<callBuf.length;i+=224)calldatas.push(callBuf.subarray(i,i+224));return calldatas}},events_exports={};function isAbiEvent(object){return"event"===object.type}function getCairo1AbiEvents(abi){const abiEventsStructs=abi.filter((obj=>isAbiEvent(obj)&&"struct"===obj.kind)),abiEventsEnums=abi.filter((obj=>isAbiEvent(obj)&&"enum"===obj.kind));return abiEventsStructs.reduce(((acc,event)=>{let nameList=[],{name}=event,flat=!1;const findName=variant=>variant.type===name;for(;;){const eventEnum=abiEventsEnums.find((eventE=>eventE.variants.some(findName)));if(isUndefined(eventEnum))break;const variant=eventEnum.variants.find(findName);nameList.unshift(variant.name),"flat"===variant.kind&&(flat=!0),name=eventEnum.name}if(0===nameList.length)throw new Error("inconsistency in ABI events definition.");flat&&(nameList=[nameList[nameList.length-1]]);const final=nameList.pop();let result={[addHexPrefix(starkCurve.keccak(utf8ToArray(final)).toString(16))]:event};for(;nameList.length>0;)result={[addHexPrefix(starkCurve.keccak(utf8ToArray(nameList.pop())).toString(16))]:result};return result={...result},mergeAbiEvents(acc,result)}),{})}function getAbiEvents(abi){return isCairo1Abi(abi)?getCairo1AbiEvents(abi):function(abi){return abi.filter((abiEntry=>"event"===abiEntry.type)).reduce(((acc,abiEntry)=>{const entryName=abiEntry.name,abiEntryMod={...abiEntry};return abiEntryMod.name=entryName,{...acc,[addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]:abiEntryMod}}),{})}(abi)}function mergeAbiEvents(target,source){const output={...target};return isObject(target)&&isObject(source)&&Object.keys(source).forEach((key=>{isObject(source[key])?key in target?output[key]=mergeAbiEvents(target[key],source[key]):Object.assign(output,{[key]:source[key]}):Object.assign(output,{[key]:source[key]})})),output}function parseEvents(providerReceivedEvents,abiEvents,abiStructs,abiEnums){return providerReceivedEvents.flat().reduce(((acc,recEvent)=>{const currentEvent=JSON.parse(JSON.stringify(recEvent));let abiEvent=abiEvents[currentEvent.keys.shift()??0];if(!abiEvent)return acc;for(;!abiEvent.name;){const hashName=currentEvent.keys.shift();assert(!!hashName,'Not enough data in "keys" property of this event.'),abiEvent=abiEvent[hashName]}const parsedEvent={};parsedEvent[abiEvent.name]={};const keysIter=currentEvent.keys[Symbol.iterator](),dataIter=currentEvent.data[Symbol.iterator](),abiEventKeys=abiEvent.members?.filter((it=>"key"===it.kind))||abiEvent.keys,abiEventData=abiEvent.members?.filter((it=>"data"===it.kind))||abiEvent.data;return abiEventKeys.forEach((key=>{parsedEvent[abiEvent.name][key.name]=responseParser(keysIter,key,abiStructs,abiEnums,parsedEvent[abiEvent.name])})),abiEventData.forEach((data=>{parsedEvent[abiEvent.name][data.name]=responseParser(dataIter,data,abiStructs,abiEnums,parsedEvent[abiEvent.name])})),"block_hash"in currentEvent&&(parsedEvent.block_hash=currentEvent.block_hash),"block_number"in currentEvent&&(parsedEvent.block_number=currentEvent.block_number),"transaction_hash"in currentEvent&&(parsedEvent.transaction_hash=currentEvent.transaction_hash),acc.push(parsedEvent),acc}),[])}function parseUDCEvent(txReceipt){if(!txReceipt.events?.length)throw new Error("UDC emitted event is empty");const event=txReceipt.events.find((it=>cleanHex(it.from_address)===cleanHex(UDC.ADDRESS)))||{data:[]};return{transaction_hash:txReceipt.transaction_hash,contract_address:event.data[0],address:event.data[0],deployer:event.data[1],unique:event.data[2],classHash:event.data[3],calldata_len:event.data[4],calldata:event.data.slice(5,5+parseInt(event.data[4],16)),salt:event.data[event.data.length-1]}}__export(events_exports,{getAbiEvents:()=>getAbiEvents,isAbiEvent:()=>isAbiEvent,parseEvents:()=>parseEvents,parseUDCEvent:()=>parseUDCEvent});var outsideExecution_exports={};function toOutsideCallV2(call){return"calldata_len"in call?{To:call.to,Selector:call.selector,Calldata:call.calldata}:call}function getOutsideCall(call){const callData=call.calldata??[],callDataCompiled=Array.isArray(callData)?callData:CallData.compile(callData);return{to:call.contractAddress,selector:getSelectorFromName(call.entrypoint),calldata:callDataCompiled}}function callToTypedData(call,version){const outsideCall=getOutsideCall(call);return"1"===version?{...outsideCall,calldata_len:outsideCall.calldata.length,calldata:outsideCall.calldata}:{To:outsideCall.to,Selector:outsideCall.selector,Calldata:outsideCall.calldata}}function getDomain(chainId,version){return{name:"Account.execute_from_outside",version,chainId,..."2"===version?{revision:"1"}:{}}}function getTypedData(chainId,options,nonce,myCalls,version){return"1"===version?{types:OutsideExecutionTypesV1,primaryType:"OutsideExecution",domain:getDomain(chainId,version),message:{...options,nonce,calls_len:myCalls.length,calls:myCalls.map((call=>callToTypedData(call,version)))}}:{types:OutsideExecutionTypesV2,primaryType:"OutsideExecution",domain:getDomain(chainId,version),message:{Caller:options.caller,Nonce:nonce,"Execute After":options.execute_after,"Execute Before":options.execute_before,Calls:myCalls.map((call=>callToTypedData(call,version)))}}}function buildExecuteFromOutsideCallData(outsideTransaction){const execution2=outsideTransaction.outsideExecution,formattedSignature=formatSignature(outsideTransaction.signature);return CallData.compile({outside_execution:execution2,signature:formattedSignature})}function buildExecuteFromOutsideCall(outsideTransaction){return(Array.isArray(outsideTransaction)?outsideTransaction:[outsideTransaction]).map((outsideTx=>{let entrypoint;if(outsideTx.version===OutsideExecutionVersion.V1)entrypoint="execute_from_outside";else{if(outsideTx.version!==OutsideExecutionVersion.V2)throw new Error("Unsupported OutsideExecution version");entrypoint="execute_from_outside_v2"}return{contractAddress:toHex(outsideTx.signerAddress),entrypoint,calldata:buildExecuteFromOutsideCallData(outsideTx)}}))}__export(outsideExecution_exports,{buildExecuteFromOutsideCall:()=>buildExecuteFromOutsideCall,buildExecuteFromOutsideCallData:()=>buildExecuteFromOutsideCallData,getOutsideCall:()=>getOutsideCall,getTypedData:()=>getTypedData,toOutsideCallV2:()=>toOutsideCallV2});var src5_exports={};async function supportsInterface(provider,contractAddress,interfaceId){const call={contractAddress:toHex(contractAddress),entrypoint:"supports_interface",calldata:[toHex(interfaceId)]};try{const resp=await provider.callContract(call);return 0n!==BigInt(resp[0])}catch{return!1}}__export(src5_exports,{supportsInterface:()=>supportsInterface});var paymaster_exports={};__export(paymaster_exports,{assertCallsAreStrictlyEqual:()=>assertCallsAreStrictlyEqual,assertPaymasterTransactionSafety:()=>assertPaymasterTransactionSafety,getDefaultPaymasterNodeUrl:()=>getDefaultPaymasterNodeUrl});var getDefaultPaymasterNodeUrl=(networkName,mute=!1)=>{mute||logger.info("Using default public node url, please provide nodeUrl in provider options!");const nodes=PAYMASTER_RPC_NODES[networkName??_NetworkName.SN_SEPOLIA];return nodes[Math.floor(Math.random()*nodes.length)]};function assertCallsAreStrictlyEqual(originalCalls,unsafeCalls){const baseError="Provided calls are not strictly equal to the returned calls";assert(unsafeCalls.length-1===originalCalls.length,`${baseError}: Expected ${originalCalls.length+1} calls, got ${unsafeCalls.length}`);for(let callIndex=0;callIndex<originalCalls.length;callIndex+=1){const originalCall=originalCalls[callIndex],unsafeCall=toOutsideCallV2(unsafeCalls[callIndex]),normalizeAddress=address=>toBigInt(address).toString(16).toLowerCase();assert(normalizeAddress(originalCall.contractAddress)===normalizeAddress(unsafeCall.To),`${baseError}: Contract address mismatch at call ${callIndex}. Expected: ${originalCall.contractAddress}, Got: ${unsafeCall.To}`),assert(getSelectorFromName(originalCall.entrypoint)===unsafeCall.Selector,`${baseError}: Entrypoint mismatch at call ${callIndex}. Expected: ${originalCall.entrypoint}, Got: ${unsafeCall.Selector}`);const originalCalldata=CallData.toCalldata(originalCall.calldata),unsafeCalldata=CallData.toCalldata(unsafeCall.Calldata);assert(originalCalldata.length===unsafeCalldata.length,`${baseError}: Calldata length mismatch at call ${callIndex}. Expected length: ${originalCalldata.length}, Got length: ${unsafeCalldata.length}`);for(let dataIndex=0;dataIndex<originalCalldata.length;dataIndex+=1){assert(BigInt(originalCalldata[dataIndex])===BigInt(unsafeCalldata[dataIndex]),`${baseError}: Calldata value mismatch at call ${callIndex}, parameter ${dataIndex}. Expected: ${originalCalldata[dataIndex]}, Got: ${unsafeCalldata[dataIndex]}`)}}}var assertPaymasterTransactionSafety=(preparedTransaction,calls,paymasterDetails,maxFeeInGasToken)=>{if("sponsored"!==paymasterDetails.feeMode.mode&&("invoke"===preparedTransaction.type||"deploy_and_invoke"===preparedTransaction.type)){const unsafeCalls="calls"in preparedTransaction.typed_data.message?preparedTransaction.typed_data.message.calls:preparedTransaction.typed_data.message.Calls;assertCallsAreStrictlyEqual(calls,unsafeCalls),((unsafeCalls,gasToken)=>{const unsafeCall=toOutsideCallV2(unsafeCalls[unsafeCalls.length-1]);assert(BigInt(unsafeCall.To)===BigInt(gasToken),"Gas token address is not equal to the provided gas token")})(unsafeCalls,paymasterDetails.feeMode.gasToken),maxFeeInGasToken&&(assert(preparedTransaction.fee.suggested_max_fee_in_gas_token<=maxFeeInGasToken,"Gas token price is too high"),((unsafeCalls,fees)=>{const unsafeCall=toOutsideCallV2(unsafeCalls[unsafeCalls.length-1]),unsafeGasTokenValue=CallData.toCalldata(unsafeCall.Calldata)[1];assert(BigInt(unsafeGasTokenValue)===BigInt(fees),"Gas token value is not equal to the provided gas fees")})(unsafeCalls,preparedTransaction.fee.suggested_max_fee_in_gas_token))}},convertCalls=calls=>calls.map((call=>({to:call.contractAddress,selector:getSelectorFromName(call.entrypoint),calldata:CallData.toHex(call.calldata)}))),convertFeeMode=feeMode=>"sponsored"===feeMode.mode?{mode:"sponsored"}:{mode:"default",gas_token:feeMode.gasToken},convertTimeBounds=timeBounds=>timeBounds&&timeBounds.executeAfter&&timeBounds.executeBefore?{execute_after:timeBounds.executeAfter.getTime().toString(),execute_before:timeBounds.executeBefore.getTime().toString()}:void 0,convertEXECUTION_PARAMETERS=parameters=>{return{version:parameters.version,feeMode:(feeMode=parameters.fee_mode,"sponsored"===feeMode.mode?{mode:"sponsored"}:{mode:"default",gasToken:feeMode.gas_token}),timeBounds:(timeBounds=parameters.time_bounds,timeBounds&&timeBounds.execute_after&&timeBounds.execute_before?{executeAfter:new Date(timeBounds.execute_after),executeBefore:new Date(timeBounds.execute_before)}:void 0)};var timeBounds,feeMode},defaultOptions3_headers={"Content-Type":"application/json"},PaymasterRpc=class _PaymasterRpc{nodeUrl;headers;baseFetch;requestId;constructor(options){if(options instanceof _PaymasterRpc)return this.nodeUrl=options.nodeUrl,this.headers={...defaultOptions3_headers,...options.headers},this.baseFetch=options.baseFetch,void(this.requestId=options.requestId);if(options&&"nodeUrl"in options&&"headers"in options&&"baseFetch"in options)return this.nodeUrl=options.nodeUrl??getDefaultPaymasterNodeUrl(void 0),this.headers={...defaultOptions3_headers,...options.headers},this.baseFetch=options.baseFetch??fetch_default,void(this.requestId=0);const{nodeUrl,headers,baseFetch}=options||{};nodeUrl&&Object.values(_NetworkName).includes(nodeUrl)?this.nodeUrl=getDefaultPaymasterNodeUrl(nodeUrl,options?.default):this.nodeUrl=nodeUrl||getDefaultPaymasterNodeUrl(void 0,options?.default),this.baseFetch=baseFetch??fetch_default,this.headers={...defaultOptions3_headers,...headers},this.requestId=0}fetch(method,params,id=0){const rpcRequestBody={id,jsonrpc:"2.0",method,...params&&{params}};return this.baseFetch(this.nodeUrl,{method:"POST",body:stringify2(rpcRequestBody),headers:this.headers})}errorHandler(method,params,rpcError,otherError){if(rpcError)throw new RpcError(rpcError,method,params);if(otherError instanceof LibraryError)throw otherError;if(otherError)throw Error(otherError.message)}async fetchEndpoint(method,params){try{this.requestId+=1;const rawResult=await this.fetch(method,params,this.requestId),{error,result}=await rawResult.json();return this.errorHandler(method,params,error),result}catch(error){throw this.errorHandler(method,params,error?.response?.data,error),error}}async isAvailable(){return this.fetchEndpoint("paymaster_isAvailable")}async buildTransaction(transaction,parameters){let userTransaction;switch(transaction.type){case"invoke":case"deploy_and_invoke":userTransaction={...transaction,invoke:{user_address:transaction.invoke.userAddress,calls:convertCalls(transaction.invoke.calls)}};break;default:userTransaction=transaction}const executionParameters={version:parameters.version,fee_mode:convertFeeMode(parameters.feeMode),time_bounds:convertTimeBounds(parameters.timeBounds)},response=await this.fetchEndpoint("paymaster_buildTransaction",{transaction:userTransaction,parameters:executionParameters}),fee={gas_token_price_in_strk:BigInt(response.fee.gas_token_price_in_strk),estimated_fee_in_strk:BigInt(response.fee.estimated_fee_in_strk),estimated_fee_in_gas_token:BigInt(response.fee.estimated_fee_in_gas_token),suggested_max_fee_in_strk:BigInt(response.fee.suggested_max_fee_in_strk),suggested_max_fee_in_gas_token:BigInt(response.fee.suggested_max_fee_in_gas_token)};switch(response.type){case"invoke":return{type:"invoke",typed_data:response.typed_data,parameters:convertEXECUTION_PARAMETERS(response.parameters),fee};case"deploy_and_invoke":return{type:"deploy_and_invoke",deployment:response.deployment,typed_data:response.typed_data,parameters:convertEXECUTION_PARAMETERS(response.parameters),fee};default:return{type:"deploy",deployment:response.deployment,parameters:convertEXECUTION_PARAMETERS(response.parameters),fee}}}async executeTransaction(transaction,parameters){let user_transaction;switch(transaction.type){case"invoke":case"deploy_and_invoke":user_transaction={...transaction,invoke:{user_address:transaction.invoke.userAddress,typed_data:transaction.invoke.typedData,signature:signatureToHexArray(transaction.invoke.signature)}};break;default:user_transaction=transaction}const executionParameters={version:parameters.version,fee_mode:convertFeeMode(parameters.feeMode),time_bounds:convertTimeBounds(parameters.timeBounds)};return this.fetchEndpoint("paymaster_executeTransaction",{transaction:user_transaction,parameters:executionParameters})}async getSupportedTokens(){return this.fetchEndpoint("paymaster_getSupportedTokens").then((tokens=>tokens.map((token=>({token_address:token.token_address,decimals:token.decimals,priceInStrk:BigInt(token.price_in_strk)})))))}},PaymasterInterface=class{},defaultPaymaster=new PaymasterRpc({default:!0}),Account=class extends RpcProvider2{signer;address;cairoVersion;transactionVersion;paymaster;constructor(providerOrOptions,address,pkOrSigner,cairoVersion,transactionVersion=config.get("transactionVersion"),paymaster){super(providerOrOptions),this.address=address.toLowerCase(),this.signer=isString(pkOrSigner)||pkOrSigner instanceof Uint8Array?new Signer(pkOrSigner):pkOrSigner,cairoVersion&&(this.cairoVersion=cairoVersion.toString()),this.transactionVersion=transactionVersion,this.paymaster=paymaster?new PaymasterRpc(paymaster):defaultPaymaster,logger.debug("Account setup",{transactionVersion:this.transactionVersion,cairoVersion:this.cairoVersion,channel:this.channel.id})}static async create(){throw new LibraryError("Not supported")}getPreferredVersion(type12,type3){return this.transactionVersion===ETransactionVersion2.V3?type3:this.transactionVersion===ETransactionVersion2.V2?type12:ETransactionVersion2.V3}async getNonce(blockIdentifier){return super.getNonceForAddress(this.address,blockIdentifier)}async getNonceSafe(nonce){try{return toBigInt(nonce??await this.getNonce())}catch(error){return 0n}}async getCairoVersion(classHash){if(!this.cairoVersion){const{cairo}=classHash?await super.getContractVersion(void 0,classHash):await super.getContractVersion(this.address);this.cairoVersion=cairo}return this.cairoVersion}async estimateFee(calls,estimateFeeDetails={}){return this.estimateInvokeFee(calls,estimateFeeDetails)}async estimateInvokeFee(calls,details={}){const{nonce:providedNonce,blockIdentifier,version:providedVersion,skipValidate=!0}=details,transactions=Array.isArray(calls)?calls:[calls],nonce=toBigInt(providedNonce??await this.getNonce()),version=toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.F1,ETransactionVersion2.F3),toFeeVersion(providedVersion)),chainId=await this.getChainId(),signerDetails={...v3Details(details,await this.channel.setUpSpecVersion()),walletAddress:this.address,nonce,maxFee:ZERO,version,chainId,cairoVersion:await this.getCairoVersion(),skipValidate},invocation=await this.buildInvocation(transactions,signerDetails);return super.getInvokeEstimateFee({...invocation},{...v3Details(details,await this.channel.setUpSpecVersion()),version,nonce},blockIdentifier,details.skipValidate)}async estimateDeclareFee(payload,details={}){const{blockIdentifier,nonce:providedNonce,version:providedVersion,skipValidate=!0}=details,nonce=toBigInt(providedNonce??await this.getNonce()),version=toTransactionVersion(isSierra(payload.contract)?this.getPreferredVersion(ETransactionVersion2.F2,ETransactionVersion2.F3):ETransactionVersion2.F1,toFeeVersion(providedVersion)),chainId=await this.getChainId(),declareContractTransaction=await this.buildDeclarePayload(payload,{...v3Details(details,await this.channel.setUpSpecVersion()),nonce,chainId,version,walletAddress:this.address,maxFee:ZERO,cairoVersion:void 0,skipValidate});return super.getDeclareEstimateFee(declareContractTransaction,{...v3Details(details,await this.channel.setUpSpecVersion()),version,nonce},blockIdentifier,details.skipValidate)}async estimateAccountDeployFee({classHash,addressSalt=0,constructorCalldata=[],contractAddress},details={}){const{blockIdentifier,version:providedVersion,skipValidate=!0}=details,version=toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.F1,ETransactionVersion2.F3),toFeeVersion(providedVersion)),nonce=ZERO,chainId=await this.getChainId(),payload=await this.buildAccountDeployPayload({classHash,addressSalt,constructorCalldata,contractAddress},{...v3Details(details,await this.channel.setUpSpecVersion()),nonce,chainId,version,walletAddress:this.address,maxFee:ZERO,cairoVersion:void 0,skipValidate});return super.getDeployAccountEstimateFee({...payload},{...v3Details(details,await this.channel.setUpSpecVersion()),version,nonce},blockIdentifier,details.skipValidate)}async estimateDeployFee(payload,details={}){const calls=this.buildUDCContractPayload(payload);return this.estimateInvokeFee(calls,details)}async estimateFeeBulk(invocations,details={}){if(!invocations.length)throw TypeError("Invocations should be non-empty array");const{nonce,blockIdentifier,version,skipValidate}=details,accountInvocations=await this.accountInvocationsFactory(invocations,{...v3Details(details,await this.channel.setUpSpecVersion()),versions:[ETransactionVersion2.F1,toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.F2,ETransactionVersion2.F3),version)],nonce,blockIdentifier,skipValidate});return super.getEstimateFeeBulk(accountInvocations,{blockIdentifier,skipValidate})}async simulateTransaction(invocations,details={}){if(!invocations.length)throw TypeError("Invocations should be non-empty array");const{nonce,blockIdentifier,skipValidate=!0,skipExecute,version}=details,accountInvocations=await this.accountInvocationsFactory(invocations,{...v3Details(details,await this.channel.setUpSpecVersion()),versions:[ETransactionVersion2.V1,toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.V2,ETransactionVersion2.V3),version)],nonce,blockIdentifier,skipValidate});return super.getSimulateTransaction(accountInvocations,{blockIdentifier,skipValidate,skipExecute})}async execute(transactions,transactionsDetail={}){const calls=Array.isArray(transactions)?transactions:[transactions],nonce=toBigInt(transactionsDetail.nonce??await this.getNonce()),version=toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.V1,ETransactionVersion2.V3),transactionsDetail.version),estimate=await this.getUniversalSuggestedFee(version,{type:TransactionType.INVOKE,payload:transactions},{...transactionsDetail,version}),chainId=await this.getChainId(),signerDetails={...v3Details(transactionsDetail,await this.channel.setUpSpecVersion()),resourceBounds:estimate.resourceBounds,walletAddress:this.address,nonce,maxFee:estimate.maxFee,version,chainId,cairoVersion:await this.getCairoVersion()},signature=await this.signer.signTransaction(calls,signerDetails),calldata=getExecuteCalldata(calls,await this.getCairoVersion());return this.invokeFunction({contractAddress:this.address,calldata,signature},{...v3Details(transactionsDetail,await this.channel.setUpSpecVersion()),resourceBounds:estimate.resourceBounds,nonce,maxFee:estimate.maxFee,version})}async buildPaymasterTransaction(calls,paymasterDetails){if(!paymasterDetails.deploymentData){if(await this.getSnip9Version()===OutsideExecutionVersion.UNSUPPORTED)throw Error("Account is not compatible with SNIP-9")}const parameters={version:"0x1",feeMode:paymasterDetails.feeMode,timeBounds:paymasterDetails.timeBounds};let transaction;return transaction=paymasterDetails.deploymentData?calls.length>0?{type:"deploy_and_invoke",invoke:{userAddress:this.address,calls},deployment:paymasterDetails.deploymentData}:{type:"deploy",deployment:paymasterDetails.deploymentData}:{type:"invoke",invoke:{userAddress:this.address,calls}},this.paymaster.buildTransaction(transaction,parameters)}async estimatePaymasterTransactionFee(calls,paymasterDetails){return(await this.buildPaymasterTransaction(calls,paymasterDetails)).fee}async preparePaymasterTransaction(preparedTransaction){let transaction;switch(preparedTransaction.type){case"deploy_and_invoke":{const signature=await this.signMessage(preparedTransaction.typed_data);transaction={type:"deploy_and_invoke",invoke:{userAddress:this.address,typedData:preparedTransaction.typed_data,signature:signatureToHexArray(signature)},deployment:preparedTransaction.deployment};break}case"invoke":{const signature=await this.signMessage(preparedTransaction.typed_data);transaction={type:"invoke",invoke:{userAddress:this.address,typedData:preparedTransaction.typed_data,signature:signatureToHexArray(signature)}};break}case"deploy":transaction={type:"deploy",deployment:preparedTransaction.deployment};break;default:throw Error("Invalid transaction type")}return transaction}async executePaymasterTransaction(calls,paymasterDetails,maxFeeInGasToken){const preparedTransaction=await this.buildPaymasterTransaction(calls,paymasterDetails);assertPaymasterTransactionSafety(preparedTransaction,calls,paymasterDetails,maxFeeInGasToken);const transaction=await this.preparePaymasterTransaction(preparedTransaction);return this.paymaster.executeTransaction(transaction,preparedTransaction.parameters).then((response=>({transaction_hash:response.transaction_hash})))}async declareIfNot(payload,transactionsDetail={}){const declareContractPayload=extractContractHashes(payload);try{await this.getClassByHash(declareContractPayload.classHash)}catch(error){return this.declare(payload,transactionsDetail)}return{transaction_hash:"",class_hash:declareContractPayload.classHash}}async declare(payload,details={}){const declareContractPayload=extractContractHashes(payload),{nonce,version:providedVersion}=details,version=toTransactionVersion(isSierra(payload.contract)?this.getPreferredVersion(ETransactionVersion2.V2,ETransactionVersion2.V3):ETransactionVersion2.V1,providedVersion),estimate=await this.getUniversalSuggestedFee(version,{type:TransactionType.DECLARE,payload:declareContractPayload},{...details,version}),declareDetails={...v3Details(details,await this.channel.setUpSpecVersion()),resourceBounds:estimate.resourceBounds,maxFee:estimate.maxFee,nonce:toBigInt(nonce??await this.getNonce()),version,chainId:await this.getChainId(),walletAddress:this.address,cairoVersion:void 0},declareContractTransaction=await this.buildDeclarePayload(declareContractPayload,declareDetails);return this.declareContract(declareContractTransaction,declareDetails)}async deploy(payload,details={}){const{calls,addresses}=buildUDCCall(payload,this.address);return{...await this.execute(calls,details),contract_address:addresses}}async deployContract(payload,details={}){const deployTx=await this.deploy(payload,details);return parseUDCEvent(await this.waitForTransaction(deployTx.transaction_hash))}async declareAndDeploy(payload,details={}){const{constructorCalldata,salt,unique}=payload;let declare=await this.declareIfNot(payload,details);if(""!==declare.transaction_hash){const tx=await this.waitForTransaction(declare.transaction_hash);declare={...declare,...tx}}const deploy=await this.deployContract({classHash:declare.class_hash,salt,unique,constructorCalldata},details);return{declare:{...declare},deploy}}deploySelf=this.deployAccount;async deployAccount({classHash,constructorCalldata=[],addressSalt=0,contractAddress:providedContractAddress},details={}){const version=toTransactionVersion(this.getPreferredVersion(ETransactionVersion2.V1,ETransactionVersion2.V3),details.version),nonce=ZERO,chainId=await this.getChainId(),compiledCalldata=CallData.compile(constructorCalldata),contractAddress=providedContractAddress??calculateContractAddressFromHash(addressSalt,classHash,compiledCalldata,0),estimate=await this.getUniversalSuggestedFee(version,{type:TransactionType.DEPLOY_ACCOUNT,payload:{classHash,constructorCalldata:compiledCalldata,addressSalt,contractAddress}},details),signature=await this.signer.signDeployAccountTransaction({...v3Details(details,await this.channel.setUpSpecVersion()),classHash,constructorCalldata:compiledCalldata,contractAddress,addressSalt,chainId,resourceBounds:estimate.resourceBounds,maxFee:estimate.maxFee,version,nonce});return this.deployAccountContract({classHash,addressSalt,constructorCalldata,signature},{...v3Details(details,await this.channel.setUpSpecVersion()),nonce,resourceBounds:estimate.resourceBounds,maxFee:estimate.maxFee,version})}async signMessage(typedData){return this.signer.signMessage(typedData,this.address)}async hashMessage(typedData){return getMessageHash(typedData,this.address)}async getSnip9Version(){return await supportsInterface(this,this.address,SNIP9_V2_INTERFACE_ID)?OutsideExecutionVersion.V2:await supportsInterface(this,this.address,SNIP9_V1_INTERFACE_ID)?OutsideExecutionVersion.V1:OutsideExecutionVersion.UNSUPPORTED}async isValidSnip9Nonce(nonce){try{const call={contractAddress:this.address,entrypoint:"is_valid_outside_execution_nonce",calldata:[toHex(nonce)]},resp=await this.callContract(call);return 0n!==BigInt(resp[0])}catch(error){throw new Error(`Failed to check if nonce is valid: ${error}`)}}async getSnip9Nonce(){const nonce=randomAddress();return await this.isValidSnip9Nonce(nonce)?nonce:this.getSnip9Nonce()}async getOutsideTransaction(options,calls,version,nonce){if(!isHex(options.caller)&&"ANY_CALLER"!==options.caller)throw new Error(`The caller ${options.caller} is not valid.`);const codedCaller=isHex(options.caller)?options.caller:OutsideExecutionCallerAny,myCalls=Array.isArray(calls)?calls:[calls],supportedVersion=version??await this.getSnip9Version();if(!supportedVersion)throw new Error("This account is not handling outside transactions.");const myNonce=nonce?toHex(nonce):await this.getSnip9Nonce(),message=getTypedData(await this.getChainId(),{caller:codedCaller,execute_after:options.execute_after,execute_before:options.execute_before},myNonce,myCalls,supportedVersion),sign=await this.signMessage(message);return{outsideExecution:{caller:codedCaller,nonce:myNonce,execute_after:options.execute_after,execute_before:options.execute_before,calls:myCalls.map(getOutsideCall)},signature:sign,signerAddress:this.address,version:supportedVersion}}async executeFromOutside(outsideTransaction,opts){const multiCall=buildExecuteFromOutsideCall(outsideTransaction);return this.execute(multiCall,opts)}async getUniversalSuggestedFee(version,{type,payload},details){let maxFee=0,resourceBounds=estimateFeeToBounds3(ZERO,void 0,await this.channel.setUpSpecVersion());return version===ETransactionVersion2.V3?resourceBounds=details.resourceBounds??(await this.getSuggestedFee({type,payload},details)).resourceBounds:maxFee=details.maxFee??(await this.getSuggestedFee({type,payload},details)).suggestedMaxFee,{maxFee,resourceBounds}}async getSuggestedFee({type,payload},details){switch(type){case TransactionType.INVOKE:return this.estimateInvokeFee(payload,details);case TransactionType.DECLARE:return this.estimateDeclareFee(payload,details);case TransactionType.DEPLOY_ACCOUNT:return this.estimateAccountDeployFee(payload,details);case TransactionType.DEPLOY:return this.estimateDeployFee(payload,details);default:return ZEROFee(await this.channel.setUpSpecVersion())}}async buildInvocation(call,details){const calldata=getExecuteCalldata(call,await this.getCairoVersion()),signature=details.skipValidate?[]:await this.signer.signTransaction(call,details);return{...v3Details(details,await this.channel.setUpSpecVersion()),contractAddress:this.address,calldata,signature}}async buildDeclarePayload(payload,details){const{classHash,contract,compiledClassHash}=extractContractHashes(payload),compressedCompiledContract=parseContract(contract);if(isUndefined(compiledClassHash)&&(details.version===ETransactionVersion3.F3||details.version===ETransactionVersion3.V3))throw Error("V3 Transaction work with Cairo1 Contracts and require compiledClassHash");const signature=details.skipValidate?[]:await this.signer.signDeclareTransaction({...details,...v3Details(details,await this.channel.setUpSpecVersion()),classHash,compiledClassHash,senderAddress:details.walletAddress});return{senderAddress:details.walletAddress,signature,contract:compressedCompiledContract,compiledClassHash}}async buildAccountDeployPayload({classHash,addressSalt=0,constructorCalldata=[],contractAddress:providedContractAddress},details){const compiledCalldata=CallData.compile(constructorCalldata),contractAddress=providedContractAddress??calculateContractAddressFromHash(addressSalt,classHash,compiledCalldata,0),signature=details.skipValidate?[]:await this.signer.signDeployAccountTransaction({...details,...v3Details(details,await this.channel.setUpSpecVersion()),classHash,contractAddress,addressSalt,constructorCalldata:compiledCalldata});return{...v3Details(details,await this.channel.setUpSpecVersion()),classHash,addressSalt,constructorCalldata:compiledCalldata,signature}}buildUDCContractPayload(payload){return[].concat(payload).map((it=>{const{classHash,salt="0",unique=!0,constructorCalldata=[]}=it,compiledConstructorCallData=CallData.compile(constructorCalldata);return{contractAddress:UDC.ADDRESS,entrypoint:UDC.ENTRYPOINT,calldata:[classHash,salt,toCairoBool(unique),compiledConstructorCallData.length,...compiledConstructorCallData]}}))}async accountInvocationsFactory(invocations,details){const{nonce,blockIdentifier,skipValidate=!0}=details,safeNonce=await this.getNonceSafe(nonce),chainId=await this.getChainId(),versions=details.versions.map((it=>toTransactionVersion(it))),tx0Payload="payload"in invocations[0]?invocations[0].payload:invocations[0],cairoVersion=invocations[0].type===TransactionType.DEPLOY_ACCOUNT?await this.getCairoVersion(tx0Payload.classHash):await this.getCairoVersion();return Promise.all([].concat(invocations).map((async(transaction,index)=>{const txPayload="payload"in transaction?transaction.payload:transaction,signerDetails={...v3Details(details,await this.channel.setUpSpecVersion()),walletAddress:this.address,nonce:toBigInt(Number(safeNonce)+index),maxFee:ZERO,chainId,cairoVersion,version:"",skipValidate},common={type:transaction.type,nonce:toBigInt(Number(safeNonce)+index),blockIdentifier,version:""};if(transaction.type===TransactionType.INVOKE){const versionX=reduceV2(versions[1]);signerDetails.version=versionX,common.version=versionX;const payload=await this.buildInvocation([].concat(txPayload),signerDetails);return{...common,...payload,...signerDetails}}if(transaction.type===TransactionType.DEPLOY){const versionX=reduceV2(versions[1]);signerDetails.version=versionX,common.version=versionX;const calls=this.buildUDCContractPayload(txPayload),payload=await this.buildInvocation(calls,signerDetails);return{...common,...payload,...signerDetails,type:TransactionType.INVOKE}}if(transaction.type===TransactionType.DECLARE){const versionX=isSierra(txPayload.contract)?versions[1]:versions[0];signerDetails.version=versionX,common.version=versionX;const payload=await this.buildDeclarePayload(txPayload,signerDetails);return{...common,...payload,...signerDetails}}if(transaction.type===TransactionType.DEPLOY_ACCOUNT){const versionX=reduceV2(versions[1]);signerDetails.version=versionX,common.version=versionX;const payload=await this.buildAccountDeployPayload(txPayload,signerDetails);return{...common,...payload,...signerDetails}}throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`)})))}async getStarkName(address=this.address,StarknetIdContract2){return super.getStarkName(address,StarknetIdContract2)}},AccountInterface=class extends ProviderInterface{},connect_exports={};function requestAccounts(swo,silent_mode=!1){return swo.request({type:"wallet_requestAccounts",params:{silent_mode}})}function getPermissions(swo){return swo.request({type:"wallet_getPermissions"})}function watchAsset(swo,asset){return swo.request({type:"wallet_watchAsset",params:asset})}function addStarknetChain(swo,chain){return swo.request({type:"wallet_addStarknetChain",params:chain})}function switchStarknetChain(swo,chainId){return swo.request({type:"wallet_switchStarknetChain",params:{chainId}})}function requestChainId(swo){return swo.request({type:"wallet_requestChainId"})}function deploymentData(swo){return swo.request({type:"wallet_deploymentData"})}function addInvokeTransaction(swo,params){return swo.request({type:"wallet_addInvokeTransaction",params})}function addDeclareTransaction(swo,params){return swo.request({type:"wallet_addDeclareTransaction",params})}function signMessage(swo,typedData){return swo.request({type:"wallet_signTypedData",params:typedData})}function supportedSpecs(swo){return swo.request({type:"wallet_supportedSpecs"})}function onAccountChange(swo,callback){swo.on("accountsChanged",callback)}function onNetworkChanged(swo,callback){swo.on("networkChanged",callback)}__export(connect_exports,{addDeclareTransaction:()=>addDeclareTransaction,addInvokeTransaction:()=>addInvokeTransaction,addStarknetChain:()=>addStarknetChain,deploymentData:()=>deploymentData,getPermissions:()=>getPermissions,onAccountChange:()=>onAccountChange,onNetworkChanged:()=>onNetworkChanged,requestAccounts:()=>requestAccounts,requestChainId:()=>requestChainId,signMessage:()=>signMessage,supportedSpecs:()=>supportedSpecs,switchStarknetChain:()=>switchStarknetChain,watchAsset:()=>watchAsset});var WalletAccount=class _WalletAccount extends Account{walletProvider;constructor(providerOrOptions,walletProvider,address,cairoVersion,paymaster){super(providerOrOptions,address,"",cairoVersion,void 0,paymaster),this.walletProvider=walletProvider,this.walletProvider.on("accountsChanged",(res=>{res&&(this.address=res[0].toLowerCase())})),this.walletProvider.on("networkChanged",(res=>{res&&this.channel.setChainId(res)}))}onAccountChange(callback){onAccountChange(this.walletProvider,callback)}onNetworkChanged(callback){onNetworkChanged(this.walletProvider,callback)}requestAccounts(silentMode=!1){return requestAccounts(this.walletProvider,silentMode)}getPermissions(){return getPermissions(this.walletProvider)}switchStarknetChain(chainId){return switchStarknetChain(this.walletProvider,chainId)}watchAsset(asset){return watchAsset(this.walletProvider,asset)}addStarknetChain(chain){return addStarknetChain(this.walletProvider,chain)}execute(calls){const params={calls:[].concat(calls).map((it=>{const{contractAddress,entrypoint,calldata}=it;return{contract_address:contractAddress,entry_point:entrypoint,calldata}}))};return addInvokeTransaction(this.walletProvider,params)}declare(payload){const declareContractPayload=extractContractHashes(payload),pContract=payload.contract,cairo1Contract={...pContract,abi:stringify2(pContract.abi)};if(!declareContractPayload.compiledClassHash)throw Error("compiledClassHash is required");const params={compiled_class_hash:declareContractPayload.compiledClassHash,contract_class:cairo1Contract};return addDeclareTransaction(this.walletProvider,params)}async deploy(payload){const{calls,addresses}=buildUDCCall(payload,this.address);return{...await this.execute(calls),contract_address:addresses}}signMessage(typedData){return signMessage(this.walletProvider,typedData)}static async connect(provider,walletProvider,cairoVersion,paymaster,silentMode=!1){const[accountAddress]=await requestAccounts(walletProvider,silentMode);return new _WalletAccount(provider,walletProvider,accountAddress,cairoVersion,paymaster)}static async connectSilent(provider,walletProvider,cairoVersion,paymaster){return _WalletAccount.connect(provider,walletProvider,cairoVersion,paymaster,!0)}};function buildCall(contract,functionAbi){return async function(...args){const options={...contract.contractOptions};return contract.contractOptions=void 0,contract.call(functionAbi.name,args,{parseRequest:!0,parseResponse:!0,...options})}}function buildDefault(contract,functionAbi){return"view"===functionAbi.stateMutability||"view"===functionAbi.state_mutability?buildCall(contract,functionAbi):function(contract,functionAbi){return async function(...args){const options={...contract.contractOptions};return contract.contractOptions=void 0,contract.invoke(functionAbi.name,args,{parseRequest:!0,...options})}}(contract,functionAbi)}function buildEstimate(contract,functionAbi){return function(...args){return contract.estimate(functionAbi.name,args)}}function getCalldata(args,callback){return Array.isArray(args)&&"__compiled__"in args?args:Array.isArray(args)&&Array.isArray(args[0])&&"__compiled__"in args[0]?args[0]:callback()}var Contract=class{abi;address;providerOrAccount;deployTransactionHash;structs;events;functions;callStatic;populateTransaction;estimateFee;callData;contractOptions;constructor(abi,address,providerOrAccount=defaultProvider){this.address=address&&address.toLowerCase(),this.providerOrAccount=providerOrAccount,this.callData=new CallData(abi),this.structs=CallData.getAbiStruct(abi),this.events=getAbiEvents(abi);const parser=createAbiParser(abi);this.abi=parser.getLegacyFormat();const options={enumerable:!0,value:{},writable:!1};Object.defineProperties(this,{functions:{enumerable:!0,value:{},writable:!1},callStatic:{enumerable:!0,value:{},writable:!1},populateTransaction:{enumerable:!0,value:{},writable:!1},estimateFee:{enumerable:!0,value:{},writable:!1}}),this.abi.forEach((abiElement=>{if("function"!==abiElement.type)return;const signature=abiElement.name;var contract,functionAbi;this[signature]||Object.defineProperty(this,signature,{...options,value:buildDefault(this,abiElement)}),this.functions[signature]||Object.defineProperty(this.functions,signature,{...options,value:buildDefault(this,abiElement)}),this.callStatic[signature]||Object.defineProperty(this.callStatic,signature,{...options,value:buildCall(this,abiElement)}),this.populateTransaction[signature]||Object.defineProperty(this.populateTransaction,signature,{...options,value:(contract=this,functionAbi=abiElement,function(...args){return contract.populate(functionAbi.name,args)})}),this.estimateFee[signature]||Object.defineProperty(this.estimateFee,signature,{...options,value:buildEstimate(this,abiElement)})}))}withOptions(options){return this.contractOptions=options,this}attach(address){this.address=address}connect(providerOrAccount){this.providerOrAccount=providerOrAccount}async deployed(){return this.deployTransactionHash&&(await this.providerOrAccount.waitForTransaction(this.deployTransactionHash),this.deployTransactionHash=void 0),this}async call(method,args=[],{parseRequest=!0,parseResponse=!0,formatResponse,blockIdentifier}={}){assert(null!==this.address,"contract is not connected to an address");const calldata=getCalldata(args,(()=>parseRequest?(this.callData.validate(ValidateType.CALL,method,args),this.callData.compile(method,args)):(logger.warn("Call skipped parsing but provided rawArgs, possible malfunction request"),args)));return this.providerOrAccount.callContract({contractAddress:this.address,calldata,entrypoint:method},blockIdentifier).then((it=>parseResponse?formatResponse?this.callData.format(method,it,formatResponse):this.callData.parse(method,it):it))}invoke(method,args=[],{parseRequest=!0,maxFee,nonce,signature}={}){assert(null!==this.address,"contract is not connected to an address");const calldata=getCalldata(args,(()=>parseRequest?(this.callData.validate(ValidateType.INVOKE,method,args),this.callData.compile(method,args)):(logger.warn("Invoke skipped parsing but provided rawArgs, possible malfunction request"),args))),invocation={contractAddress:this.address,calldata,entrypoint:method};if("execute"in this.providerOrAccount)return this.providerOrAccount.execute(invocation,{maxFee,nonce});if(!nonce)throw new Error("Nonce is required when invoking a function without an account");return logger.warn(`Invoking ${method} without an account. This will not work on a public node.`),this.providerOrAccount.invokeFunction({...invocation,signature},{nonce})}async estimate(method,args=[]){assert(null!==this.address,"contract is not connected to an address"),getCalldata(args,(()=>!1))||this.callData.validate(ValidateType.INVOKE,method,args);const invocation=this.populate(method,args);if("estimateInvokeFee"in this.providerOrAccount)return this.providerOrAccount.estimateInvokeFee(invocation);throw Error("Contract must be connected to the account contract to estimate")}populate(method,args=[]){const calldata=getCalldata(args,(()=>this.callData.compile(method,args)));return{contractAddress:this.address,entrypoint:method,calldata}}parseEvents(receipt){let parsed;return receipt.match({success:txR=>{const emittedEvents=txR.events?.map((event=>({block_hash:txR.block_hash,block_number:txR.block_number,transaction_hash:txR.transaction_hash,...event}))).filter((event=>cleanHex(event.from_address)===cleanHex(this.address)),[])||[];parsed=parseEvents(emittedEvents,this.events,this.structs,CallData.getAbiEnum(this.abi))},_:()=>{throw Error("This transaction was not successful.")}}),parsed}isCairo1(){return cairo_exports.isCairo1Abi(this.abi)}async getVersion(){return this.providerOrAccount.getContractVersion(this.address)}typedv2(tAbi){return this}},ContractInterface=class{functions;callStatic;populateTransaction;estimateFee},ContractFactory=class{compiledContract;account;abi;classHash;casm;compiledClassHash;CallData;contractOptions;constructor(params){this.compiledContract=params.compiledContract,this.account=params.account,this.casm=params.casm,this.abi=params.abi??params.compiledContract.abi,this.classHash=params.classHash,this.compiledClassHash=params.compiledClassHash,this.CallData=new CallData(this.abi),this.contractOptions=params.contractOptions}async deploy(...args){const constructorCalldata=getCalldata(args,(()=>this.contractOptions?.parseRequest?(this.CallData.validate(ValidateType.DEPLOY,"constructor",args),this.CallData.compile("constructor",args)):(logger.warn("Call skipped parsing but provided rawArgs, possible malfunction request"),args))),{deploy:{contract_address,transaction_hash}}=await this.account.declareAndDeploy({contract:this.compiledContract,casm:this.casm,classHash:this.classHash,compiledClassHash:this.compiledClassHash,constructorCalldata,salt:this.contractOptions?.addressSalt});assert(Boolean(contract_address),"Deployment of the contract failed");const contractInstance=new Contract(this.compiledContract.abi,contract_address,this.account);return contractInstance.deployTransactionHash=transaction_hash,contractInstance}connect(account){return this.account=account,this}attach(address){return new Contract(this.abi,address,this.account)}},ResponseParser=class{};function units(amount,simbol="fri"){if("strk"===simbol){let numStr="";"bigint"==typeof amount?numStr=amount.toString():"string"==typeof amount&&(numStr=isHex(amount)?BigInt(amount).toString():amount);const[integer,decimal="0"]=numStr.split(".");return`${integer}${decimal.padEnd(18,"0")}`.replace(/\b0+/g,"")}const bis=BigInt(amount).toString();let strk;return strk=bis.length<=18?`0.${bis.padStart(18,"0")}`:`${bis.slice(0,bis.length-18)}.${bis.slice(bis.length-18)}`,strk.replace(/(\.[0-9]*[1-9])0+$|\.0*$/,"$1")}},69467:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.SPEC=exports.Errors=void 0,__exportStar(__webpack_require__(13613),exports),exports.Errors=__webpack_require__(62708),exports.SPEC=__webpack_require__(2731),__exportStar(__webpack_require__(3483),exports)},69973:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TypedDataRevision=void 0,exports.TypedDataRevision={ACTIVE:"1",LEGACY:"0"}},69999:(__unused_webpack_module,exports)=>{"use strict";function isBytes(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name}function isArrayOf(isString,arr){return!!Array.isArray(arr)&&(0===arr.length||(isString?arr.every((item=>"string"==typeof item)):arr.every((item=>Number.isSafeInteger(item)))))}function afn(input){if("function"!=typeof input)throw new Error("function expected");return!0}function astr(label,input){if("string"!=typeof input)throw new Error(`${label}: string expected`);return!0}function anumber(n){if(!Number.isSafeInteger(n))throw new Error(`invalid integer: ${n}`)}function aArr(input){if(!Array.isArray(input))throw new Error("array expected")}function astrArr(label,input){if(!isArrayOf(!0,input))throw new Error(`${label}: array of strings expected`)}function anumArr(label,input){if(!isArrayOf(!1,input))throw new Error(`${label}: array of numbers expected`)}function chain(...args){const id=a=>a,wrap=(a,b)=>c=>a(b(c));return{encode:args.map((x=>x.encode)).reduceRight(wrap,id),decode:args.map((x=>x.decode)).reduce(wrap,id)}}function alphabet(letters){const lettersA="string"==typeof letters?letters.split(""):letters,len=lettersA.length;astrArr("alphabet",lettersA);const indexes=new Map(lettersA.map(((l,i)=>[l,i])));return{encode:digits=>(aArr(digits),digits.map((i=>{if(!Number.isSafeInteger(i)||i<0||i>=len)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);return lettersA[i]}))),decode:input=>(aArr(input),input.map((letter=>{astr("alphabet.decode",letter);const i=indexes.get(letter);if(void 0===i)throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);return i})))}}function join(separator=""){return astr("join",separator),{encode:from=>(astrArr("join.decode",from),from.join(separator)),decode:to=>(astr("join.decode",to),to.split(separator))}}function padding(bits,chr="="){return anumber(bits),astr("padding",chr),{encode(data){for(astrArr("padding.encode",data);data.length*bits%8;)data.push(chr);return data},decode(input){astrArr("padding.decode",input);let end=input.length;if(end*bits%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;end>0&&input[end-1]===chr;end--){if((end-1)*bits%8==0)throw new Error("padding: invalid, string has too much padding")}return input.slice(0,end)}}}function normalize(fn){return afn(fn),{encode:from=>from,decode:to=>fn(to)}}function convertRadix(data,from,to){if(from<2)throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);if(to<2)throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);if(aArr(data),!data.length)return[];let pos=0;const res=[],digits=Array.from(data,(d=>{if(anumber(d),d<0||d>=from)throw new Error(`invalid integer: ${d}`);return d})),dlen=digits.length;for(;;){let carry=0,done=!0;for(let i=pos;i<dlen;i++){const digit=digits[i],fromCarry=from*carry,digitBase=fromCarry+digit;if(!Number.isSafeInteger(digitBase)||fromCarry/from!==carry||digitBase-digit!==fromCarry)throw new Error("convertRadix: carry overflow");const div=digitBase/to;carry=digitBase%to;const rounded=Math.floor(div);if(digits[i]=rounded,!Number.isSafeInteger(rounded)||rounded*to+carry!==digitBase)throw new Error("convertRadix: carry overflow");done&&(rounded?done=!1:pos=i)}if(res.push(carry),done)break}for(let i=0;i<data.length-1&&0===data[i];i++)res.push(0);return res.reverse()}Object.defineProperty(exports,"__esModule",{value:!0}),exports.bytes=exports.stringToBytes=exports.str=exports.bytesToString=exports.hex=exports.utf8=exports.bech32m=exports.bech32=exports.base58check=exports.createBase58check=exports.base58xmr=exports.base58xrp=exports.base58flickr=exports.base58=exports.base64urlnopad=exports.base64url=exports.base64nopad=exports.base64=exports.base32crockford=exports.base32hexnopad=exports.base32hex=exports.base32nopad=exports.base32=exports.base16=exports.utils=exports.assertNumber=void 0,exports.assertNumber=anumber;const gcd=(a,b)=>0===b?a:gcd(b,a%b),radix2carry=(from,to)=>from+(to-gcd(from,to)),powers=(()=>{let res=[];for(let i=0;i<40;i++)res.push(2**i);return res})();function convertRadix2(data,from,to,padding){if(aArr(data),from<=0||from>32)throw new Error(`convertRadix2: wrong from=${from}`);if(to<=0||to>32)throw new Error(`convertRadix2: wrong to=${to}`);if(radix2carry(from,to)>32)throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from,to)}`);let carry=0,pos=0;const max=powers[from],mask=powers[to]-1,res=[];for(const n of data){if(anumber(n),n>=max)throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);if(carry=carry<<from|n,pos+from>32)throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);for(pos+=from;pos>=to;pos-=to)res.push((carry>>pos-to&mask)>>>0);const pow=powers[pos];if(void 0===pow)throw new Error("invalid carry");carry&=pow-1}if(carry=carry<<to-pos&mask,!padding&&pos>=from)throw new Error("Excess padding");if(!padding&&carry>0)throw new Error(`Non-zero padding: ${carry}`);return padding&&pos>0&&res.push(carry>>>0),res}function radix(num){anumber(num);return{encode:bytes=>{if(!isBytes(bytes))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(bytes),256,num)},decode:digits=>(anumArr("radix.decode",digits),Uint8Array.from(convertRadix(digits,num,256)))}}function radix2(bits,revPadding=!1){if(anumber(bits),bits<=0||bits>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,bits)>32||radix2carry(bits,8)>32)throw new Error("radix2: carry overflow");return{encode:bytes=>{if(!isBytes(bytes))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(bytes),8,bits,!revPadding)},decode:digits=>(anumArr("radix2.decode",digits),Uint8Array.from(convertRadix2(digits,bits,8,revPadding)))}}function unsafeWrapper(fn){return afn(fn),function(...args){try{return fn.apply(null,args)}catch(e){}}}function checksum(len,fn){return anumber(len),afn(fn),{encode(data){if(!isBytes(data))throw new Error("checksum.encode: input should be Uint8Array");const sum=fn(data).slice(0,len),res=new Uint8Array(data.length+len);return res.set(data),res.set(sum,data.length),res},decode(data){if(!isBytes(data))throw new Error("checksum.decode: input should be Uint8Array");const payload=data.slice(0,-len),oldChecksum=data.slice(-len),newChecksum=fn(payload).slice(0,len);for(let i=0;i<len;i++)if(newChecksum[i]!==oldChecksum[i])throw new Error("Invalid checksum");return payload}}}exports.utils={alphabet,chain,checksum,convertRadix,convertRadix2,radix,radix2,join,padding},exports.base16=chain(radix2(4),alphabet("0123456789ABCDEF"),join("")),exports.base32=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join("")),exports.base32nopad=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),join("")),exports.base32hex=chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join("")),exports.base32hexnopad=chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),join("")),exports.base32crockford=chain(radix2(5),alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join(""),normalize((s=>s.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")))),exports.base64=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join("")),exports.base64nopad=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),join("")),exports.base64url=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join("")),exports.base64urlnopad=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),join(""));const genBase58=abc=>chain(radix(58),alphabet(abc),join(""));exports.base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),exports.base58flickr=genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),exports.base58xrp=genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11];exports.base58xmr={encode(data){let res="";for(let i=0;i<data.length;i+=8){const block=data.subarray(i,i+8);res+=exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length],"1")}return res},decode(str){let res=[];for(let i=0;i<str.length;i+=11){const slice=str.slice(i,i+11),blockLen=XMR_BLOCK_LEN.indexOf(slice.length),block=exports.base58.decode(slice);for(let j=0;j<block.length-blockLen;j++)if(0!==block[j])throw new Error("base58xmr: wrong padding");res=res.concat(Array.from(block.slice(block.length-blockLen)))}return Uint8Array.from(res)}};exports.createBase58check=sha256=>chain(checksum(4,(data=>sha256(sha256(data)))),exports.base58),exports.base58check=exports.createBase58check;const BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(pre){const b=pre>>25;let chk=(33554431&pre)<<5;for(let i=0;i<POLYMOD_GENERATORS.length;i++)1==(b>>i&1)&&(chk^=POLYMOD_GENERATORS[i]);return chk}function bechChecksum(prefix,words,encodingConst=1){const len=prefix.length;let chk=1;for(let i=0;i<len;i++){const c=prefix.charCodeAt(i);if(c<33||c>126)throw new Error(`Invalid prefix (${prefix})`);chk=bech32Polymod(chk)^c>>5}chk=bech32Polymod(chk);for(let i=0;i<len;i++)chk=bech32Polymod(chk)^31&prefix.charCodeAt(i);for(let v of words)chk=bech32Polymod(chk)^v;for(let i=0;i<6;i++)chk=bech32Polymod(chk);return chk^=encodingConst,BECH_ALPHABET.encode(convertRadix2([chk%powers[30]],30,5,!1))}function genBech32(encoding){const ENCODING_CONST="bech32"===encoding?1:734539939,_words=radix2(5),fromWords=_words.decode,toWords=_words.encode,fromWordsUnsafe=unsafeWrapper(fromWords);function encode(prefix,words,limit=90){astr("bech32.encode prefix",prefix),isBytes(words)&&(words=Array.from(words)),anumArr("bech32.encode",words);const plen=prefix.length;if(0===plen)throw new TypeError(`Invalid prefix length ${plen}`);const actualLength=plen+7+words.length;if(!1!==limit&&actualLength>limit)throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);const lowered=prefix.toLowerCase(),sum=bechChecksum(lowered,words,ENCODING_CONST);return`${lowered}1${BECH_ALPHABET.encode(words)}${sum}`}function decode(str,limit=90){astr("bech32.decode input",str);const slen=str.length;if(slen<8||!1!==limit&&slen>limit)throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);const lowered=str.toLowerCase();if(str!==lowered&&str!==str.toUpperCase())throw new Error("String must be lowercase or uppercase");const sepIndex=lowered.lastIndexOf("1");if(0===sepIndex||-1===sepIndex)throw new Error('Letter "1" must be present between prefix and data only');const prefix=lowered.slice(0,sepIndex),data=lowered.slice(sepIndex+1);if(data.length<6)throw new Error("Data must be at least 6 characters long");const words=BECH_ALPHABET.decode(data).slice(0,-6),sum=bechChecksum(prefix,words,ENCODING_CONST);if(!data.endsWith(sum))throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);return{prefix,words}}return{encode,decode,encodeFromBytes:function(prefix,bytes){return encode(prefix,toWords(bytes))},decodeToBytes:function(str){const{prefix,words}=decode(str,!1);return{prefix,words,bytes:fromWords(words)}},decodeUnsafe:unsafeWrapper(decode),fromWords,fromWordsUnsafe,toWords}}exports.bech32=genBech32("bech32"),exports.bech32m=genBech32("bech32m"),exports.utf8={encode:data=>(new TextDecoder).decode(data),decode:str=>(new TextEncoder).encode(str)},exports.hex=chain(radix2(4),alphabet("0123456789abcdef"),join(""),normalize((s=>{if("string"!=typeof s||s.length%2!=0)throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);return s.toLowerCase()})));const CODERS={utf8:exports.utf8,hex:exports.hex,base16:exports.base16,base32:exports.base32,base64:exports.base64,base64url:exports.base64url,base58:exports.base58,base58xmr:exports.base58xmr},coderTypeError="Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";exports.bytesToString=(type,bytes)=>{if("string"!=typeof type||!CODERS.hasOwnProperty(type))throw new TypeError(coderTypeError);if(!isBytes(bytes))throw new TypeError("bytesToString() expects Uint8Array");return CODERS[type].encode(bytes)},exports.str=exports.bytesToString;exports.stringToBytes=(type,str)=>{if(!CODERS.hasOwnProperty(type))throw new TypeError(coderTypeError);if("string"!=typeof str)throw new TypeError("stringToBytes() expects string");return CODERS[type].decode(str)},exports.bytes=exports.stringToBytes},70079:module=>{module.exports=function(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n},module.exports.__esModule=!0,module.exports.default=module.exports},71761:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expand_message_xmd=expand_message_xmd,exports.expand_message_xof=expand_message_xof,exports.hash_to_field=hash_to_field,exports.isogenyMap=function(field,map){const COEFF=map.map((i=>Array.from(i).reverse()));return(x,y)=>{const[xNum,xDen,yNum,yDen]=COEFF.map((val=>val.reduce(((acc,i)=>field.add(field.mul(acc,x),i)))));return x=field.div(xNum,xDen),y=field.mul(y,field.div(yNum,yDen)),{x,y}}},exports.createHasher=function(Point,mapToCurve,def){if("function"!=typeof mapToCurve)throw new Error("mapToCurve() must be defined");return{hashToCurve(msg,options){const u=hash_to_field(msg,2,{...def,DST:def.DST,...options}),u0=Point.fromAffine(mapToCurve(u[0])),u1=Point.fromAffine(mapToCurve(u[1])),P=u0.add(u1).clearCofactor();return P.assertValidity(),P},encodeToCurve(msg,options){const u=hash_to_field(msg,1,{...def,DST:def.encodeDST,...options}),P=Point.fromAffine(mapToCurve(u[0])).clearCofactor();return P.assertValidity(),P},mapToCurve(scalars){if(!Array.isArray(scalars))throw new Error("mapToCurve: expected array of bigints");for(const i of scalars)if("bigint"!=typeof i)throw new Error("mapToCurve: expected array of bigints");const P=Point.fromAffine(mapToCurve(scalars)).clearCofactor();return P.assertValidity(),P}}};const modular_js_1=__webpack_require__(24967),utils_js_1=__webpack_require__(91484),os2ip=utils_js_1.bytesToNumberBE;function i2osp(value,length){if(anum(value),anum(length),value<0||value>=1<<8*length)throw new Error("invalid I2OSP input: "+value);const res=Array.from({length}).fill(0);for(let i=length-1;i>=0;i--)res[i]=255&value,value>>>=8;return new Uint8Array(res)}function strxor(a,b){const arr=new Uint8Array(a.length);for(let i=0;i<a.length;i++)arr[i]=a[i]^b[i];return arr}function anum(item){if(!Number.isSafeInteger(item))throw new Error("number expected")}function expand_message_xmd(msg,DST,lenInBytes,H){(0,utils_js_1.abytes)(msg),(0,utils_js_1.abytes)(DST),anum(lenInBytes),DST.length>255&&(DST=H((0,utils_js_1.concatBytes)((0,utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"),DST)));const{outputLen:b_in_bytes,blockLen:r_in_bytes}=H,ell=Math.ceil(lenInBytes/b_in_bytes);if(lenInBytes>65535||ell>255)throw new Error("expand_message_xmd: invalid lenInBytes");const DST_prime=(0,utils_js_1.concatBytes)(DST,i2osp(DST.length,1)),Z_pad=i2osp(0,r_in_bytes),l_i_b_str=i2osp(lenInBytes,2),b=new Array(ell),b_0=H((0,utils_js_1.concatBytes)(Z_pad,msg,l_i_b_str,i2osp(0,1),DST_prime));b[0]=H((0,utils_js_1.concatBytes)(b_0,i2osp(1,1),DST_prime));for(let i=1;i<=ell;i++){const args=[strxor(b_0,b[i-1]),i2osp(i+1,1),DST_prime];b[i]=H((0,utils_js_1.concatBytes)(...args))}return(0,utils_js_1.concatBytes)(...b).slice(0,lenInBytes)}function expand_message_xof(msg,DST,lenInBytes,k,H){if((0,utils_js_1.abytes)(msg),(0,utils_js_1.abytes)(DST),anum(lenInBytes),DST.length>255){const dkLen=Math.ceil(2*k/8);DST=H.create({dkLen}).update((0,utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest()}if(lenInBytes>65535||DST.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return H.create({dkLen:lenInBytes}).update(msg).update(i2osp(lenInBytes,2)).update(DST).update(i2osp(DST.length,1)).digest()}function hash_to_field(msg,count,options){(0,utils_js_1.validateObject)(options,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p,k,m,hash,expand,DST:_DST}=options;(0,utils_js_1.abytes)(msg),anum(count);const DST="string"==typeof _DST?(0,utils_js_1.utf8ToBytes)(_DST):_DST,log2p=p.toString(2).length,L=Math.ceil((log2p+k)/8),len_in_bytes=count*m*L;let prb;if("xmd"===expand)prb=expand_message_xmd(msg,DST,len_in_bytes,hash);else if("xof"===expand)prb=expand_message_xof(msg,DST,len_in_bytes,k,hash);else{if("_internal_pass"!==expand)throw new Error('expand must be "xmd" or "xof"');prb=msg}const u=new Array(count);for(let i=0;i<count;i++){const e=new Array(m);for(let j=0;j<m;j++){const elm_offset=L*(j+i*m),tv=prb.subarray(elm_offset,elm_offset+L);e[j]=(0,modular_js_1.mod)(os2ip(tv),p)}u[i]=e}return u}},72669:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.crypto=void 0,exports.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},72787:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},73562:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getHash=getHash,exports.createCurve=function(curveDef,defHash){const create=hash=>(0,weierstrass_js_1.weierstrass)({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create})};const hmac_1=__webpack_require__(83788),utils_1=__webpack_require__(81130),weierstrass_js_1=__webpack_require__(91705);function getHash(hash){return{hash,hmac:(key,...msgs)=>(0,hmac_1.hmac)(hash,key,(0,utils_1.concatBytes)(...msgs)),randomBytes:utils_1.randomBytes}}},73738:module=>{function _typeof(o){return module.exports=_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},module.exports.__esModule=!0,module.exports.default=module.exports,_typeof(o)}module.exports=_typeof,module.exports.__esModule=!0,module.exports.default=module.exports},74509:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},74930:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},77324:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},77736:(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__(73738).default,toPrimitive=__webpack_require__(89045);module.exports=function(t){var i=toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""},module.exports.__esModule=!0,module.exports.default=module.exports},78112:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sha224=exports.sha256=exports.SHA256=void 0;const _md_js_1=__webpack_require__(83487),utils_js_1=__webpack_require__(14762),SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends _md_js_1.HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=(0,utils_js_1.rotr)(W15,7)^(0,utils_js_1.rotr)(W15,18)^W15>>>3,s1=(0,utils_js_1.rotr)(W2,17)^(0,utils_js_1.rotr)(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+((0,utils_js_1.rotr)(E,6)^(0,utils_js_1.rotr)(E,11)^(0,utils_js_1.rotr)(E,25))+(0,_md_js_1.Chi)(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=((0,utils_js_1.rotr)(A,2)^(0,utils_js_1.rotr)(A,13)^(0,utils_js_1.rotr)(A,22))+(0,_md_js_1.Maj)(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}exports.SHA256=SHA256;class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}exports.sha256=(0,utils_js_1.wrapConstructor)((()=>new SHA256)),exports.sha224=(0,utils_js_1.wrapConstructor)((()=>new SHA224))},79097:module=>{"use strict";module.exports=function(strm,start){let _in,last,_out,beg,end,dmax,wsize,whave,wnext,s_window,hold,bits,lcode,dcode,lmask,dmask,here,op,len,dist,from,from_source,input,output;const state=strm.state;_in=strm.next_in,input=strm.input,last=_in+(strm.avail_in-5),_out=strm.next_out,output=strm.output,beg=_out-(start-strm.avail_out),end=_out+(strm.avail_out-257),dmax=state.dmax,wsize=state.wsize,whave=state.whave,wnext=state.wnext,s_window=state.window,hold=state.hold,bits=state.bits,lcode=state.lencode,dcode=state.distcode,lmask=(1<<state.lenbits)-1,dmask=(1<<state.distbits)-1;top:do{bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=lcode[hold&lmask];dolen:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,0===op)output[_out++]=65535&here;else{if(!(16&op)){if(64&op){if(32&op){state.mode=16191;break top}strm.msg="invalid literal/length code",state.mode=16209;break top}here=lcode[(65535&here)+(hold&(1<<op)-1)];continue dolen}for(len=65535&here,op&=15,op&&(bits<op&&(hold+=input[_in++]<<bits,bits+=8),len+=hold&(1<<op)-1,hold>>>=op,bits-=op),bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=dcode[hold&dmask];;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,16&op){if(dist=65535&here,op&=15,bits<op&&(hold+=input[_in++]<<bits,bits+=8,bits<op&&(hold+=input[_in++]<<bits,bits+=8)),dist+=hold&(1<<op)-1,dist>dmax){strm.msg="invalid distance too far back",state.mode=16209;break top}if(hold>>>=op,bits-=op,op=_out-beg,dist>op){if(op=dist-op,op>whave&&state.sane){strm.msg="invalid distance too far back",state.mode=16209;break top}if(from=0,from_source=s_window,0===wnext){if(from+=wsize-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}else if(wnext<op){if(from+=wsize+wnext-op,op-=wnext,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);if(from=0,wnext<len){op=wnext,len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}}else if(from+=wnext-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}for(;len>2;)output[_out++]=from_source[from++],output[_out++]=from_source[from++],output[_out++]=from_source[from++],len-=3;len&&(output[_out++]=from_source[from++],len>1&&(output[_out++]=from_source[from++]))}else{from=_out-dist;do{output[_out++]=output[from++],output[_out++]=output[from++],output[_out++]=output[from++],len-=3}while(len>2);len&&(output[_out++]=output[from++],len>1&&(output[_out++]=output[from++]))}break}if(64&op){strm.msg="invalid distance code",state.mode=16209;break top}here=dcode[(65535&here)+(hold&(1<<op)-1)]}}break}}while(_in<last&&_out<end);len=bits>>3,_in-=len,bits-=len<<3,hold&=(1<<bits)-1,strm.next_in=_in,strm.next_out=_out,strm.avail_in=_in<last?last-_in+5:5-(_in-last),strm.avail_out=_out<end?end-_out+257:257-(_out-end),state.hold=hold,state.bits=bits}},81130:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Hash=exports.nextTick=exports.byteSwapIfBE=exports.byteSwap=exports.isLE=exports.rotl=exports.rotr=exports.createView=exports.u32=exports.u8=void 0,exports.isBytes=function(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name},exports.byteSwap32=function(arr){for(let i=0;i<arr.length;i++)arr[i]=(0,exports.byteSwap)(arr[i])},exports.bytesToHex=function(bytes){(0,_assert_js_1.abytes)(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex},exports.hexToBytes=function(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("padded hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=asciiToBase16(hex.charCodeAt(hi)),n2=asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array},exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;diff>=0&&diff<tick||(await(0,exports.nextTick)(),ts+=diff)}},exports.utf8ToBytes=utf8ToBytes,exports.toBytes=toBytes,exports.concatBytes=function(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];(0,_assert_js_1.abytes)(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res},exports.checkOpts=function(defaults,opts){if(void 0!==opts&&"[object Object]"!=={}.toString.call(opts))throw new Error("Options should be object or undefined");return Object.assign(defaults,opts)},exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC},exports.wrapConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=opts=>hashCons(opts),hashC},exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));if(crypto_1.crypto&&"function"==typeof crypto_1.crypto.randomBytes)return crypto_1.crypto.randomBytes(bytesLength);throw new Error("crypto.getRandomValues must be defined")};const crypto_1=__webpack_require__(55510),_assert_js_1=__webpack_require__(53764);exports.u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);exports.u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));exports.createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);exports.rotr=(word,shift)=>word<<32-shift|word>>>shift;exports.rotl=(word,shift)=>word<<shift|word>>>32-shift>>>0,exports.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];exports.byteSwap=word=>word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255,exports.byteSwapIfBE=exports.isLE?n=>n:n=>(0,exports.byteSwap)(n);const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(ch){return ch>=asciis._0&&ch<=asciis._9?ch-asciis._0:ch>=asciis.A&&ch<=asciis.F?ch-(asciis.A-10):ch>=asciis.a&&ch<=asciis.f?ch-(asciis.a-10):void 0}function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){return"string"==typeof data&&(data=utf8ToBytes(data)),(0,_assert_js_1.abytes)(data),data}exports.nextTick=async()=>{};exports.Hash=class{clone(){return this._cloneInto()}}},81452:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},81494:module=>{"use strict";module.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},81696:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sha224=exports.sha256=exports.SHA256=void 0;const _md_js_1=__webpack_require__(65311),utils_js_1=__webpack_require__(81130),SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends _md_js_1.HashMD{constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=(0,utils_js_1.rotr)(W15,7)^(0,utils_js_1.rotr)(W15,18)^W15>>>3,s1=(0,utils_js_1.rotr)(W2,17)^(0,utils_js_1.rotr)(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+((0,utils_js_1.rotr)(E,6)^(0,utils_js_1.rotr)(E,11)^(0,utils_js_1.rotr)(E,25))+(0,_md_js_1.Chi)(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=((0,utils_js_1.rotr)(A,2)^(0,utils_js_1.rotr)(A,13)^(0,utils_js_1.rotr)(A,22))+(0,_md_js_1.Maj)(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}exports.SHA256=SHA256;class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}exports.sha256=(0,utils_js_1.wrapConstructor)((()=>new SHA256)),exports.sha224=(0,utils_js_1.wrapConstructor)((()=>new SHA224))},82217:module=>{"use strict";module.exports=(adler,buf,len,pos)=>{let s1=65535&adler,s2=adler>>>16&65535,n=0;for(;0!==len;){n=len>2e3?2e3:len,len-=n;do{s1=s1+buf[pos++]|0,s2=s2+s1|0}while(--n);s1%=65521,s2%=65521}return s1|s2<<16}},82923:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},83304:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.WALLET_API=exports.API=void 0,__exportStar(__webpack_require__(69467),exports),exports.API=__webpack_require__(69467),__exportStar(__webpack_require__(48801),exports),exports.WALLET_API=__webpack_require__(48801)},83487:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HashMD=exports.Maj=exports.Chi=void 0;const _assert_js_1=__webpack_require__(90788),utils_js_1=__webpack_require__(14762);exports.Chi=(a,b,c)=>a&b^~a&c;exports.Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends utils_js_1.Hash{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=(0,utils_js_1.createView)(this.buffer)}update(data){(0,_assert_js_1.aexists)(this);const{view,buffer,blockLen}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=(0,utils_js_1.createView)(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.aoutput)(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=(0,utils_js_1.createView)(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}exports.HashMD=HashMD},83788:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hmac=exports.HMAC=void 0;const _assert_js_1=__webpack_require__(53764),utils_js_1=__webpack_require__(81130);class HMAC extends utils_js_1.Hash{constructor(hash,_key){super(),this.finished=!1,this.destroyed=!1,(0,_assert_js_1.ahash)(hash);const key=(0,utils_js_1.toBytes)(_key);if(this.iHash=hash.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen,pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad),this.oHash=hash.create();for(let i=0;i<pad.length;i++)pad[i]^=106;this.oHash.update(pad),pad.fill(0)}update(buf){return(0,_assert_js_1.aexists)(this),this.iHash.update(buf),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.abytes)(out,this.outputLen),this.finished=!0,this.iHash.digestInto(out),this.oHash.update(out),this.oHash.digestInto(out),this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);return this.digestInto(out),out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;return to.finished=finished,to.destroyed=destroyed,to.blockLen=blockLen,to.outputLen=outputLen,to.oHash=oHash._cloneInto(to.oHash),to.iHash=iHash._cloneInto(to.iHash),to}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}exports.HMAC=HMAC;exports.hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest(),exports.hmac.create=(hash,key)=>new HMAC(hash,key)},84557:(__unused_webpack_module,exports)=>{var StarknetDappMethod;Object.defineProperty(exports,"__esModule",{value:!0}),exports.StarknetDappMethod=void 0,function(StarknetDappMethod){StarknetDappMethod.IS_AUTHORIZED="STARKNET_IS_AUTHORIZED",StarknetDappMethod.CONNECT="STARKNET_CONNECT",StarknetDappMethod.INVOKE="STARKNET_INVOKE",StarknetDappMethod.WATCH_ASSET="STARKNET_WATCH_ASSET",StarknetDappMethod.SIGN_MESSAGE="STARKNET_SIGN_MESSAGE",StarknetDappMethod.DECLARE_CONTRACT="STARKNET_DECLARE_CONTRACT",StarknetDappMethod.DEPLOY_CONTRACT="STARKNET_DEPLOY_CONTRACT",StarknetDappMethod.GET_DEPLOYMENT_DATA="STARKNET_GET_DEPLOYMENT_DATA",StarknetDappMethod.GET_NODE="STARKNET_GET_NODE",StarknetDappMethod.GET_CHAIN_ID="STARKNET_GET_CHAIN_ID",StarknetDappMethod.GET_SUPPORTED_SPECS="STARKNET_GET_SUPPORTED_SPECS"}(StarknetDappMethod||(exports.StarknetDappMethod=StarknetDappMethod={}))},85409:(__unused_webpack_module,exports)=>{"use strict";function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(b,...lengths){if(!((a=b)instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name))throw new Error("Uint8Array expected");var a;if(lengths.length>0&&!lengths.includes(b.length))throw new Error("Uint8Array expected of length "+lengths+", got length="+b.length)}function ahash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber(h.outputLen),anumber(h.blockLen)}function aexists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function aoutput(out,instance){abytes(out);const min=instance.outputLen;if(out.length<min)throw new Error("digestInto() expects output buffer of length at least "+min)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.anumber=anumber,exports.number=anumber,exports.abytes=abytes,exports.bytes=abytes,exports.ahash=ahash,exports.aexists=aexists,exports.aoutput=aoutput;const assert={number:anumber,bytes:abytes,hash:ahash,exists:aexists,output:aoutput};exports.default=assert},87695:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},89045:(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__(73738).default;module.exports=function(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)},module.exports.__esModule=!0,module.exports.default=module.exports},90675:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.TokenSigner=exports.createUnsecuredToken=void 0;const base64url=__webpack_require__(35921),cryptoClients_1=__webpack_require__(61161),errors_1=__webpack_require__(68886),sha256_1=__webpack_require__(97990);function createSigningInput(payload,header){const tokenParts=[],encodedHeader=base64url.encode(JSON.stringify(header));tokenParts.push(encodedHeader);const encodedPayload=base64url.encode(JSON.stringify(payload));tokenParts.push(encodedPayload);return tokenParts.join(".")}exports.createUnsecuredToken=function(payload){return createSigningInput(payload,{typ:"JWT",alg:"none"})+"."};exports.TokenSigner=class{constructor(signingAlgorithm,rawPrivateKey){if(!signingAlgorithm||!rawPrivateKey)throw new errors_1.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof signingAlgorithm)throw new Error("signing algorithm parameter must be a string");if(signingAlgorithm=signingAlgorithm.toUpperCase(),!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm))throw new Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=cryptoClients_1.cryptoClients[signingAlgorithm],this.rawPrivateKey=rawPrivateKey}header(header={}){const defaultHeader={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},defaultHeader,header)}sign(payload,expanded=!1,customHeader={}){const header=this.header(customHeader),signingInput=createSigningInput(payload,header),signingInputHash=(0,sha256_1.hashSha256)(signingInput);return this.createWithSignedHash(payload,expanded,header,signingInput,signingInputHash)}signAsync(payload,expanded=!1,customHeader={}){return __awaiter(this,void 0,void 0,(function*(){const header=this.header(customHeader),signingInput=createSigningInput(payload,header),signingInputHash=yield(0,sha256_1.hashSha256Async)(signingInput);return this.createWithSignedHash(payload,expanded,header,signingInput,signingInputHash)}))}createWithSignedHash(payload,expanded,header,signingInput,signingInputHash){const signature=this.cryptoClient.signHash(signingInputHash,this.rawPrivateKey);if(expanded){return{header:[base64url.encode(JSON.stringify(header))],payload:JSON.stringify(payload),signature:[signature]}}return[signingInput,signature].join(".")}}},90774:(__unused_webpack_module,exports,__webpack_require__)=>{var _interopRequireDefault=__webpack_require__(24994);Object.defineProperty(exports,"__esModule",{value:!0}),exports.WithdrawalLimitsRequiredSigner=exports.WithdrawalLimitType=exports.WalletEventType=exports.TransactionVersion=exports.RemoteSigningAction=exports.RECOVERED_ACCOUNT_HINT=exports.PopupWalletListenerUID=exports.MAX_NETWORK_ACCOUNTS=exports.AccountTypeString=exports.AccountType=exports.AccountSignerType=exports.AccountProvider=exports.AccountMode=void 0;var _AccountTypeString,TransactionVersion,AccountProvider,AccountSignerType,WithdrawalLimitsRequiredSigner,WithdrawalLimitType,AccountMode,WalletEventType,RemoteSigningAction,AccountType,_defineProperty2=_interopRequireDefault(__webpack_require__(43693));exports.PopupWalletListenerUID="popup",exports.MAX_NETWORK_ACCOUNTS=25,exports.RECOVERED_ACCOUNT_HINT="N/A RECOVERED";!function(TransactionVersion){TransactionVersion.V0="0x0",TransactionVersion.V1="0x1",TransactionVersion.V2="0x2",TransactionVersion.V3="0x3",TransactionVersion.F0="0x100000000000000000000000000000000",TransactionVersion.F1="0x100000000000000000000000000000001",TransactionVersion.F2="0x100000000000000000000000000000002",TransactionVersion.F3="0x100000000000000000000000000000003"}(TransactionVersion||(exports.TransactionVersion=TransactionVersion={})),function(AccountProvider){AccountProvider.Braavos="braavos",AccountProvider.Argent="argent",AccountProvider.BitcoinSegwit="bitcoin-segwit",AccountProvider.BitcoinTaproot="bitcoin-taproot",AccountProvider.Readonly="readonly",AccountProvider.PrivateKey="private-key"}(AccountProvider||(exports.AccountProvider=AccountProvider={})),function(AccountSignerType){AccountSignerType[AccountSignerType.Unused=0]="Unused",AccountSignerType[AccountSignerType.Stark=1]="Stark",AccountSignerType[AccountSignerType.Secp256r1=2]="Secp256r1",AccountSignerType[AccountSignerType.Secp256r1Deprecated=3]="Secp256r1Deprecated",AccountSignerType[AccountSignerType.External=4]="External",AccountSignerType[AccountSignerType.WebAuthn=5]="WebAuthn",AccountSignerType[AccountSignerType.Ledger=6]="Ledger",AccountSignerType[AccountSignerType.Bitcoin=-1]="Bitcoin"}(AccountSignerType||(exports.AccountSignerType=AccountSignerType={})),function(WithdrawalLimitsRequiredSigner){WithdrawalLimitsRequiredSigner[WithdrawalLimitsRequiredSigner.NotAssigned=0]="NotAssigned",WithdrawalLimitsRequiredSigner[WithdrawalLimitsRequiredSigner.Stark=1]="Stark",WithdrawalLimitsRequiredSigner[WithdrawalLimitsRequiredSigner.Strong=2]="Strong",WithdrawalLimitsRequiredSigner[WithdrawalLimitsRequiredSigner.Multisig=3]="Multisig"}(WithdrawalLimitsRequiredSigner||(exports.WithdrawalLimitsRequiredSigner=WithdrawalLimitsRequiredSigner={})),function(WithdrawalLimitType){WithdrawalLimitType.LOW="low",WithdrawalLimitType.HIGH="high"}(WithdrawalLimitType||(exports.WithdrawalLimitType=WithdrawalLimitType={})),function(AccountMode){AccountMode.Default="default",AccountMode.Multisig="multisig",AccountMode.MultiOwnerAccount="moa",AccountMode.SecuredSigner="secured-signer"}(AccountMode||(exports.AccountMode=AccountMode={})),function(WalletEventType){WalletEventType.ACCOUNT_UPDATED="ACCOUNT_UPDATED",WalletEventType.ACTIVE_ACCOUNT_CHANGED="ACTIVE_ACCOUNT_CHANGED",WalletEventType.ACTIVE_NETWORK_CHANGED="ACTIVE_NETWORK_CHANGED",WalletEventType.WALLET_LOCKED="WALLET_LOCKED",WalletEventType.WALLET_UNLOCKED="WALLET_UNLOCKED",WalletEventType.WALLET_RESET="WALLET_RESET",WalletEventType.WALLET_RECOVERY_PROGRESS="WALLET_RECOVERY_PROGRESS"}(WalletEventType||(exports.WalletEventType=WalletEventType={})),function(RemoteSigningAction){RemoteSigningAction.InvokeAtomic3FA="invoke-atomic-3fa",RemoteSigningAction.InvokePending3FA="invoke-pending-3fa",RemoteSigningAction.Invoke2FA="invoke-2fa",RemoteSigningAction.SignAtomic3FA="sign-atomic-3fa",RemoteSigningAction.SignPending3FA="sign-pending-3fa",RemoteSigningAction.Sign2FA="sign-2fa"}(RemoteSigningAction||(exports.RemoteSigningAction=RemoteSigningAction={})),function(AccountType){AccountType[AccountType.Consumer=0]="Consumer",AccountType[AccountType.MultiOwners=1]="MultiOwners"}(AccountType||(exports.AccountType=AccountType={}));exports.AccountTypeString=(_AccountTypeString={},(0,_defineProperty2.default)(_AccountTypeString,AccountType.Consumer,"consumer"),(0,_defineProperty2.default)(_AccountTypeString,AccountType.MultiOwners,"moa"),_AccountTypeString)},90788:(__unused_webpack_module,exports)=>{"use strict";function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(b,...lengths){if(!((a=b)instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name))throw new Error("Uint8Array expected");var a;if(lengths.length>0&&!lengths.includes(b.length))throw new Error("Uint8Array expected of length "+lengths+", got length="+b.length)}function ahash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber(h.outputLen),anumber(h.blockLen)}function aexists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function aoutput(out,instance){abytes(out);const min=instance.outputLen;if(out.length<min)throw new Error("digestInto() expects output buffer of length at least "+min)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.anumber=anumber,exports.number=anumber,exports.abytes=abytes,exports.bytes=abytes,exports.ahash=ahash,exports.aexists=aexists,exports.aoutput=aoutput;const assert={number:anumber,bytes:abytes,hash:ahash,exists:aexists,output:aoutput};exports.default=assert},91134:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HashMD=exports.Maj=exports.Chi=void 0;const _assert_js_1=__webpack_require__(85409),utils_js_1=__webpack_require__(61667);exports.Chi=(a,b,c)=>a&b^~a&c;exports.Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends utils_js_1.Hash{constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=(0,utils_js_1.createView)(this.buffer)}update(data){(0,_assert_js_1.aexists)(this);const{view,buffer,blockLen}=this,len=(data=(0,utils_js_1.toBytes)(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=(0,utils_js_1.createView)(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){(0,_assert_js_1.aexists)(this),(0,_assert_js_1.aoutput)(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=(0,utils_js_1.createView)(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}}exports.HashMD=HashMD},91484:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.notImplemented=exports.bitMask=void 0,exports.isBytes=isBytes,exports.abytes=abytes,exports.abool=function(title,value){if("boolean"!=typeof value)throw new Error(title+" boolean expected, got "+value)},exports.bytesToHex=bytesToHex,exports.numberToHexUnpadded=numberToHexUnpadded,exports.hexToNumber=hexToNumber,exports.hexToBytes=hexToBytes,exports.bytesToNumberBE=function(bytes){return hexToNumber(bytesToHex(bytes))},exports.bytesToNumberLE=function(bytes){return abytes(bytes),hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))},exports.numberToBytesBE=numberToBytesBE,exports.numberToBytesLE=function(n,len){return numberToBytesBE(n,len).reverse()},exports.numberToVarBytesBE=function(n){return hexToBytes(numberToHexUnpadded(n))},exports.ensureBytes=function(title,hex,expectedLength){let res;if("string"==typeof hex)try{res=hexToBytes(hex)}catch(e){throw new Error(title+" must be hex string or Uint8Array, cause: "+e)}else{if(!isBytes(hex))throw new Error(title+" must be hex string or Uint8Array");res=Uint8Array.from(hex)}const len=res.length;if("number"==typeof expectedLength&&len!==expectedLength)throw new Error(title+" of length "+expectedLength+" expected, got "+len);return res},exports.concatBytes=concatBytes,exports.equalBytes=function(a,b){if(a.length!==b.length)return!1;let diff=0;for(let i=0;i<a.length;i++)diff|=a[i]^b[i];return 0===diff},exports.utf8ToBytes=function(str){if("string"!=typeof str)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(str))},exports.inRange=inRange,exports.aInRange=function(title,n,min,max){if(!inRange(n,min,max))throw new Error("expected valid "+title+": "+min+" <= n < "+max+", got "+n)},exports.bitLen=function(n){let len;for(len=0;n>_0n;n>>=_1n,len+=1);return len},exports.bitGet=function(n,pos){return n>>BigInt(pos)&_1n},exports.bitSet=function(n,pos,value){return n|(value?_1n:_0n)<<BigInt(pos)},exports.createHmacDrbg=function(hashLen,qByteLen,hmacFn){if("number"!=typeof hashLen||hashLen<2)throw new Error("hashLen must be a number");if("number"!=typeof qByteLen||qByteLen<2)throw new Error("qByteLen must be a number");if("function"!=typeof hmacFn)throw new Error("hmacFn must be a function");let v=u8n(hashLen),k=u8n(hashLen),i=0;const reset=()=>{v.fill(1),k.fill(0),i=0},h=(...b)=>hmacFn(k,v,...b),reseed=(seed=u8n())=>{k=h(u8fr([0]),seed),v=h(),0!==seed.length&&(k=h(u8fr([1]),seed),v=h())},gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let len=0;const out=[];for(;len<qByteLen;){v=h();const sl=v.slice();out.push(sl),len+=v.length}return concatBytes(...out)};return(seed,pred)=>{let res;for(reset(),reseed(seed);!(res=pred(gen()));)reseed();return reset(),res}},exports.validateObject=function(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if("function"!=typeof checkVal)throw new Error("invalid validator function");const val=object[fieldName];if(!(isOptional&&void 0===val||checkVal(val,object)))throw new Error("param "+String(fieldName)+" is invalid. Expected "+type+", got "+val)};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,!1);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,!0);return object},exports.memoized=function(fn){const map=new WeakMap;return(arg,...args)=>{const val=map.get(arg);if(void 0!==val)return val;const computed=fn(arg,...args);return map.set(arg,computed),computed}};const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2);function isBytes(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name}function abytes(item){if(!isBytes(item))throw new Error("Uint8Array expected")}const hexes=Array.from({length:256},((_,i)=>i.toString(16).padStart(2,"0")));function bytesToHex(bytes){abytes(bytes);let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex}function numberToHexUnpadded(num){const hex=num.toString(16);return 1&hex.length?"0"+hex:hex}function hexToNumber(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);return""===hex?_0n:BigInt("0x"+hex)}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(ch){return ch>=asciis._0&&ch<=asciis._9?ch-asciis._0:ch>=asciis.A&&ch<=asciis.F?ch-(asciis.A-10):ch>=asciis.a&&ch<=asciis.f?ch-(asciis.a-10):void 0}function hexToBytes(hex){if("string"!=typeof hex)throw new Error("hex string expected, got "+typeof hex);const hl=hex.length,al=hl/2;if(hl%2)throw new Error("hex string expected, got unpadded hex of length "+hl);const array=new Uint8Array(al);for(let ai=0,hi=0;ai<al;ai++,hi+=2){const n1=asciiToBase16(hex.charCodeAt(hi)),n2=asciiToBase16(hex.charCodeAt(hi+1));if(void 0===n1||void 0===n2){const char=hex[hi]+hex[hi+1];throw new Error('hex string expected, got non-hex character "'+char+'" at index '+hi)}array[ai]=16*n1+n2}return array}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(2*len,"0"))}function concatBytes(...arrays){let sum=0;for(let i=0;i<arrays.length;i++){const a=arrays[i];abytes(a),sum+=a.length}const res=new Uint8Array(sum);for(let i=0,pad=0;i<arrays.length;i++){const a=arrays[i];res.set(a,pad),pad+=a.length}return res}const isPosBig=n=>"bigint"==typeof n&&_0n<=n;function inRange(n,min,max){return isPosBig(n)&&isPosBig(min)&&isPosBig(max)&&min<=n&&n<max}exports.bitMask=n=>(_2n<<BigInt(n-1))-_1n;const u8n=data=>new Uint8Array(data),u8fr=arr=>Uint8Array.from(arr);const validatorFns={bigint:val=>"bigint"==typeof val,function:val=>"function"==typeof val,boolean:val=>"boolean"==typeof val,string:val=>"string"==typeof val,stringOrUint8Array:val=>"string"==typeof val||isBytes(val),isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>"function"==typeof val&&Number.isSafeInteger(val.outputLen)};exports.notImplemented=()=>{throw new Error("not implemented")}},91692:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){void 0===k2&&(k2=k);var desc=Object.getOwnPropertyDescriptor(m,k);desc&&!("get"in desc?!m.__esModule:desc.writable||desc.configurable)||(desc={enumerable:!0,get:function(){return m[k]}}),Object.defineProperty(o,k2,desc)}:function(o,m,k,k2){void 0===k2&&(k2=k),o[k2]=m[k]}),__exportStar=this&&this.__exportStar||function(m,exports){for(var p in m)"default"===p||Object.prototype.hasOwnProperty.call(exports,p)||__createBinding(exports,m,p)};Object.defineProperty(exports,"__esModule",{value:!0}),exports.CONTRACT=void 0,__exportStar(__webpack_require__(68574),exports),exports.CONTRACT=__webpack_require__(93732),__exportStar(__webpack_require__(54557),exports),__exportStar(__webpack_require__(56846),exports),__exportStar(__webpack_require__(97176),exports),__exportStar(__webpack_require__(22193),exports),__exportStar(__webpack_require__(17530),exports),__exportStar(__webpack_require__(1819),exports)},91705:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DER=void 0,exports.weierstrassPoints=weierstrassPoints,exports.weierstrass=function(curveDef){const CURVE=function(curve){const opts=(0,curve_js_1.validateBasic)(curve);return ut.validateObject(opts,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...opts})}(curveDef),{Fp,n:CURVE_ORDER}=CURVE,compressedLen=Fp.BYTES+1,uncompressedLen=2*Fp.BYTES+1;function modN(a){return mod.mod(a,CURVE_ORDER)}function invN(a){return mod.invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine(),x=Fp.toBytes(a.x),cat=ut.concatBytes;return(0,utils_js_1.abool)("isCompressed",isCompressed),isCompressed?cat(Uint8Array.from([point.hasEvenY()?2:3]),x):cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))},fromBytes(bytes){const len=bytes.length,head=bytes[0],tail=bytes.subarray(1);if(len!==compressedLen||2!==head&&3!==head){if(len===uncompressedLen&&4===head){return{x:Fp.fromBytes(tail.subarray(0,Fp.BYTES)),y:Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES))}}throw new Error("invalid Point, expected length of "+compressedLen+", or uncompressed "+uncompressedLen+", got "+len)}{const x=ut.bytesToNumberBE(tail);if(!ut.inRange(x,_1n,Fp.ORDER))throw new Error("Point is not on curve");const y2=weierstrassEquation(x);let y;try{y=Fp.sqrt(y2)}catch(sqrtError){const suffix=sqrtError instanceof Error?": "+sqrtError.message:"";throw new Error("Point is not on curve"+suffix)}return!(1&~head)!==((y&_1n)===_1n)&&(y=Fp.neg(y)),{x,y}}}}),numToNByteStr=num=>ut.bytesToHex(ut.numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){return number>CURVE_ORDER>>_1n}const slcNum=(b,from,to)=>ut.bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r,this.s=s,this.recovery=recovery,this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;return hex=(0,utils_js_1.ensureBytes)("compactSignature",hex,2*l),new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=exports.DER.toSig((0,utils_js_1.ensureBytes)("DER",hex));return new Signature(r,s)}assertValidity(){ut.aInRange("r",this.r,_1n,CURVE_ORDER),ut.aInRange("s",this.s,_1n,CURVE_ORDER)}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this,h=bits2int_modN((0,utils_js_1.ensureBytes)("msgHash",msgHash));if(null==rec||![0,1,2,3].includes(rec))throw new Error("recovery id invalid");const radj=2===rec||3===rec?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error("recovery id 2 or 3 invalid");const prefix=1&rec?"03":"02",R=Point.fromHex(prefix+numToNByteStr(radj)),ir=invN(radj),u1=modN(-h*ir),u2=modN(s*ir),Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return ut.hexToBytes(this.toDERHex())}toDERHex(){return exports.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut.hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{return normPrivateKeyToScalar(privateKey),!0}catch(error){return!1}},normPrivateKeyToScalar,randomPrivateKey:()=>{const length=mod.getMinHashLength(CURVE.n);return mod.mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute:(windowSize=8,point=Point.BASE)=>(point._setWindowSize(windowSize),point.multiply(BigInt(3)),point)};function isProbPub(item){const arr=ut.isBytes(item),str="string"==typeof item,len=(arr||str)&&item.length;return arr?len===compressedLen||len===uncompressedLen:str?len===2*compressedLen||len===2*uncompressedLen:item instanceof Point}const bits2int=CURVE.bits2int||function(bytes){if(bytes.length>8192)throw new Error("input is too large");const num=ut.bytesToNumberBE(bytes),delta=8*bytes.length-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num},bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))},ORDER_MASK=ut.bitMask(CURVE.nBitLength);function int2octets(num){return ut.aInRange("num < 2^"+CURVE.nBitLength,num,_0n,ORDER_MASK),ut.numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if(["recovered","canonical"].some((k=>k in opts)))throw new Error("sign() legacy options not supported");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;null==lowS&&(lowS=!0),msgHash=(0,utils_js_1.ensureBytes)("msgHash",msgHash),validateSigVerOpts(opts),prehash&&(msgHash=(0,utils_js_1.ensureBytes)("prehashed msgHash",hash(msgHash)));const h1int=bits2int_modN(msgHash),d=normPrivateKeyToScalar(privateKey),seedArgs=[int2octets(d),int2octets(h1int)];if(null!=ent&&!1!==ent){const e=!0===ent?randomBytes(Fp.BYTES):ent;seedArgs.push((0,utils_js_1.ensureBytes)("extraEntropy",e))}const seed=ut.concatBytes(...seedArgs),m=h1int;return{seed,k2sig:function(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k),q=Point.BASE.multiply(k).toAffine(),r=modN(q.x);if(r===_0n)return;const s=modN(ik*modN(m+r*d));if(s===_0n)return;let recovery=(q.x===r?0:2)|Number(q.y&_1n),normS=s;return lowS&&isBiggerThanHalfOrder(s)&&(normS=function(s){return isBiggerThanHalfOrder(s)?modN(-s):s}(s),recovery^=1),new Signature(r,normS,recovery)}}}const defaultSigOpts={lowS:CURVE.lowS,prehash:!1},defaultVerOpts={lowS:CURVE.lowS,prehash:!1};return Point.BASE._setWindowSize(8),{CURVE,getPublicKey:function(privateKey,isCompressed=!0){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)},getSharedSecret:function(privateA,publicB,isCompressed=!0){if(isProbPub(privateA))throw new Error("first arg must be private key");if(!isProbPub(publicB))throw new Error("second arg must be public key");return Point.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)},sign:function(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts),C=CURVE;return ut.createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac)(seed,k2sig)},verify:function(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;msgHash=(0,utils_js_1.ensureBytes)("msgHash",msgHash),publicKey=(0,utils_js_1.ensureBytes)("publicKey",publicKey);const{lowS,prehash,format}=opts;if(validateSigVerOpts(opts),"strict"in opts)throw new Error("options.strict was renamed to lowS");if(void 0!==format&&"compact"!==format&&"der"!==format)throw new Error("format must be compact or der");const isHex="string"==typeof sg||ut.isBytes(sg),isObj=!isHex&&!format&&"object"==typeof sg&&null!==sg&&"bigint"==typeof sg.r&&"bigint"==typeof sg.s;if(!isHex&&!isObj)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let _sig,P;try{if(isObj&&(_sig=new Signature(sg.r,sg.s)),isHex){try{"compact"!==format&&(_sig=Signature.fromDER(sg))}catch(derError){if(!(derError instanceof exports.DER.Err))throw derError}_sig||"der"===format||(_sig=Signature.fromCompact(sg))}P=Point.fromHex(publicKey)}catch(error){return!1}if(!_sig)return!1;if(lowS&&_sig.hasHighS())return!1;prehash&&(msgHash=CURVE.hash(msgHash));const{r,s}=_sig,h=bits2int_modN(msgHash),is=invN(s),u1=modN(h*is),u2=modN(r*is),R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();if(!R)return!1;return modN(R.x)===r},ProjectivePoint:Point,Signature,utils}},exports.SWUFpSqrtRatio=SWUFpSqrtRatio,exports.mapToCurveSimpleSWU=function(Fp,opts){if(mod.validateField(Fp),!Fp.isValid(opts.A)||!Fp.isValid(opts.B)||!Fp.isValid(opts.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const sqrtRatio=SWUFpSqrtRatio(Fp,opts.Z);if(!Fp.isOdd)throw new Error("Fp.isOdd is not implemented!");return u=>{let tv1,tv2,tv3,tv4,tv5,tv6,x,y;tv1=Fp.sqr(u),tv1=Fp.mul(tv1,opts.Z),tv2=Fp.sqr(tv1),tv2=Fp.add(tv2,tv1),tv3=Fp.add(tv2,Fp.ONE),tv3=Fp.mul(tv3,opts.B),tv4=Fp.cmov(opts.Z,Fp.neg(tv2),!Fp.eql(tv2,Fp.ZERO)),tv4=Fp.mul(tv4,opts.A),tv2=Fp.sqr(tv3),tv6=Fp.sqr(tv4),tv5=Fp.mul(tv6,opts.A),tv2=Fp.add(tv2,tv5),tv2=Fp.mul(tv2,tv3),tv6=Fp.mul(tv6,tv4),tv5=Fp.mul(tv6,opts.B),tv2=Fp.add(tv2,tv5),x=Fp.mul(tv1,tv3);const{isValid,value}=sqrtRatio(tv2,tv6);y=Fp.mul(tv1,u),y=Fp.mul(y,value),x=Fp.cmov(x,tv3,isValid),y=Fp.cmov(y,value,isValid);const e1=Fp.isOdd(u)===Fp.isOdd(y);return y=Fp.cmov(Fp.neg(y),y,e1),x=Fp.div(x,tv4),{x,y}}};const curve_js_1=__webpack_require__(62422),mod=__webpack_require__(24967),ut=__webpack_require__(91484),utils_js_1=__webpack_require__(91484);function validateSigVerOpts(opts){void 0!==opts.lowS&&(0,utils_js_1.abool)("lowS",opts.lowS),void 0!==opts.prehash&&(0,utils_js_1.abool)("prehash",opts.prehash)}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;exports.DER={Err:class extends Error{constructor(m=""){super(m)}},_tlv:{encode:(tag,data)=>{const{Err:E}=exports.DER;if(tag<0||tag>256)throw new E("tlv.encode: wrong tag");if(1&data.length)throw new E("tlv.encode: unpadded data");const dataLen=data.length/2,len=ut.numberToHexUnpadded(dataLen);if(len.length/2&128)throw new E("tlv.encode: long form length too big");const lenLen=dataLen>127?ut.numberToHexUnpadded(len.length/2|128):"";return ut.numberToHexUnpadded(tag)+lenLen+len+data},decode(tag,data){const{Err:E}=exports.DER;let pos=0;if(tag<0||tag>256)throw new E("tlv.encode: wrong tag");if(data.length<2||data[pos++]!==tag)throw new E("tlv.decode: wrong tlv");const first=data[pos++];let length=0;if(!!(128&first)){const lenLen=127&first;if(!lenLen)throw new E("tlv.decode(long): indefinite length not supported");if(lenLen>4)throw new E("tlv.decode(long): byte length is too big");const lengthBytes=data.subarray(pos,pos+lenLen);if(lengthBytes.length!==lenLen)throw new E("tlv.decode: length bytes not complete");if(0===lengthBytes[0])throw new E("tlv.decode(long): zero leftmost byte");for(const b of lengthBytes)length=length<<8|b;if(pos+=lenLen,length<128)throw new E("tlv.decode(long): not minimal encoding")}else length=first;const v=data.subarray(pos,pos+length);if(v.length!==length)throw new E("tlv.decode: wrong value length");return{v,l:data.subarray(pos+length)}}},_int:{encode(num){const{Err:E}=exports.DER;if(num<_0n)throw new E("integer: negative integers are not allowed");let hex=ut.numberToHexUnpadded(num);if(8&Number.parseInt(hex[0],16)&&(hex="00"+hex),1&hex.length)throw new E("unexpected DER parsing assertion: unpadded hex");return hex},decode(data){const{Err:E}=exports.DER;if(128&data[0])throw new E("invalid signature integer: negative");if(0===data[0]&&!(128&data[1]))throw new E("invalid signature integer: unnecessary leading zero");return b2n(data)}},toSig(hex){const{Err:E,_int:int,_tlv:tlv}=exports.DER,data="string"==typeof hex?h2b(hex):hex;ut.abytes(data);const{v:seqBytes,l:seqLeftBytes}=tlv.decode(48,data);if(seqLeftBytes.length)throw new E("invalid signature: left bytes after parsing");const{v:rBytes,l:rLeftBytes}=tlv.decode(2,seqBytes),{v:sBytes,l:sLeftBytes}=tlv.decode(2,rLeftBytes);if(sLeftBytes.length)throw new E("invalid signature: left bytes after parsing");return{r:int.decode(rBytes),s:int.decode(sBytes)}},hexFromSig(sig){const{_tlv:tlv,_int:int}=exports.DER,seq=tlv.encode(2,int.encode(sig.r))+tlv.encode(2,int.encode(sig.s));return tlv.encode(48,seq)}};const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4);function weierstrassPoints(opts){const CURVE=function(curve){const opts=(0,curve_js_1.validateBasic)(curve);ut.validateObject(opts,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof endo||"bigint"!=typeof endo.beta||"function"!=typeof endo.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...opts})}(opts),{Fp}=CURVE,Fn=mod.Field(CURVE.n,CURVE.nBitLength),toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return ut.concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))}),fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);return{x:Fp.fromBytes(tail.subarray(0,Fp.BYTES)),y:Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES))}});function weierstrassEquation(x){const{a,b}=CURVE,x2=Fp.sqr(x),x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error("bad generator point: equation left != right");function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n:N}=CURVE;if(lengths&&"bigint"!=typeof key){if(ut.isBytes(key)&&(key=ut.bytesToHex(key)),"string"!=typeof key||!lengths.includes(key.length))throw new Error("invalid private key");key=key.padStart(2*nByteLength,"0")}let num;try{num="bigint"==typeof key?key:ut.bytesToNumberBE((0,utils_js_1.ensureBytes)("private key",key,nByteLength))}catch(error){throw new Error("invalid private key, expected hex or "+nByteLength+" bytes, got "+typeof key)}return wrapPrivateKey&&(num=mod.mod(num,N)),ut.aInRange("private key",num,_1n,N),num}function assertPrjPoint(other){if(!(other instanceof Point))throw new Error("ProjectivePoint expected")}const toAffineMemo=(0,utils_js_1.memoized)(((p,iz)=>{const{px:x,py:y,pz:z}=p;if(Fp.eql(z,Fp.ONE))return{x,y};const is0=p.is0();null==iz&&(iz=is0?Fp.ONE:Fp.inv(z));const ax=Fp.mul(x,iz),ay=Fp.mul(y,iz),zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error("invZ was invalid");return{x:ax,y:ay}})),assertValidMemo=(0,utils_js_1.memoized)((p=>{if(p.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(p.py))return;throw new Error("bad point: ZERO")}const{x,y}=p.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error("bad point: x or y not FE");const left=Fp.sqr(y),right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error("bad point: equation left != right");if(!p.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class Point{constructor(px,py,pz){if(this.px=px,this.py=py,this.pz=pz,null==px||!Fp.isValid(px))throw new Error("x required");if(null==py||!Fp.isValid(py))throw new Error("y required");if(null==pz||!Fp.isValid(pz))throw new Error("z required");Object.freeze(this)}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error("invalid affine point");if(p instanceof Point)throw new Error("projective point not allowed");const is0=i=>Fp.eql(i,Fp.ZERO);return is0(x)&&is0(y)?Point.ZERO:new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map((p=>p.pz)));return points.map(((p,i)=>p.toAffine(toInv[i]))).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes((0,utils_js_1.ensureBytes)("pointHex",hex)));return P.assertValidity(),P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}static msm(points,scalars){return(0,curve_js_1.pippenger)(Point,Fn,points,scalars)}_setWindowSize(windowSize){wnaf.setWindowSize(this,windowSize)}assertValidity(){assertValidMemo(this)}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other,U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1)),U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE,b3=Fp.mul(b,_3n),{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO,t0=Fp.mul(X1,X1),t1=Fp.mul(Y1,Y1),t2=Fp.mul(Z1,Z1),t3=Fp.mul(X1,Y1);return t3=Fp.add(t3,t3),Z3=Fp.mul(X1,Z1),Z3=Fp.add(Z3,Z3),X3=Fp.mul(a,Z3),Y3=Fp.mul(b3,t2),Y3=Fp.add(X3,Y3),X3=Fp.sub(t1,Y3),Y3=Fp.add(t1,Y3),Y3=Fp.mul(X3,Y3),X3=Fp.mul(t3,X3),Z3=Fp.mul(b3,Z3),t2=Fp.mul(a,t2),t3=Fp.sub(t0,t2),t3=Fp.mul(a,t3),t3=Fp.add(t3,Z3),Z3=Fp.add(t0,t0),t0=Fp.add(Z3,t0),t0=Fp.add(t0,t2),t0=Fp.mul(t0,t3),Y3=Fp.add(Y3,t0),t2=Fp.mul(Y1,Z1),t2=Fp.add(t2,t2),t0=Fp.mul(t2,t3),X3=Fp.sub(X3,t0),Z3=Fp.mul(t2,t1),Z3=Fp.add(Z3,Z3),Z3=Fp.add(Z3,Z3),new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a,b3=Fp.mul(CURVE.b,_3n);let t0=Fp.mul(X1,X2),t1=Fp.mul(Y1,Y2),t2=Fp.mul(Z1,Z2),t3=Fp.add(X1,Y1),t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4),t4=Fp.add(t0,t1),t3=Fp.sub(t3,t4),t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);return t4=Fp.mul(t4,t5),t5=Fp.add(t0,t2),t4=Fp.sub(t4,t5),t5=Fp.add(Y1,Z1),X3=Fp.add(Y2,Z2),t5=Fp.mul(t5,X3),X3=Fp.add(t1,t2),t5=Fp.sub(t5,X3),Z3=Fp.mul(a,t4),X3=Fp.mul(b3,t2),Z3=Fp.add(X3,Z3),X3=Fp.sub(t1,Z3),Z3=Fp.add(t1,Z3),Y3=Fp.mul(X3,Z3),t1=Fp.add(t0,t0),t1=Fp.add(t1,t0),t2=Fp.mul(a,t2),t4=Fp.mul(b3,t4),t1=Fp.add(t1,t2),t2=Fp.sub(t0,t2),t2=Fp.mul(a,t2),t4=Fp.add(t4,t2),t0=Fp.mul(t1,t4),Y3=Fp.add(Y3,t0),t0=Fp.mul(t5,t4),X3=Fp.mul(t3,X3),X3=Fp.sub(X3,t0),t0=Fp.mul(t3,t1),Z3=Fp.mul(t5,Z3),Z3=Fp.add(Z3,t0),new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,n,Point.normalizeZ)}multiplyUnsafe(sc){const{endo,n:N}=CURVE;ut.aInRange("scalar",sc,_0n,N);const I=Point.ZERO;if(sc===_0n)return I;if(this.is0()||sc===_1n)return this;if(!endo||wnaf.hasPrecomputes(this))return wnaf.wNAFCachedUnsafe(this,sc,Point.normalizeZ);let{k1neg,k1,k2neg,k2}=endo.splitScalar(sc),k1p=I,k2p=I,d=this;for(;k1>_0n||k2>_0n;)k1&_1n&&(k1p=k1p.add(d)),k2&_1n&&(k2p=k2p.add(d)),d=d.double(),k1>>=_1n,k2>>=_1n;return k1neg&&(k1p=k1p.negate()),k2neg&&(k2p=k2p.negate()),k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz),k1p.add(k2p)}multiply(scalar){const{endo,n:N}=CURVE;let point,fake;if(ut.aInRange("scalar",scalar,_1n,N),endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(scalar);let{p:k1p,f:f1p}=this.wNAF(k1),{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p),k2p=wnaf.constTimeNegate(k2neg,k2p),k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz),point=k1p.add(k2p),fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(scalar);point=p,fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE,mul=(P,a)=>a!==_0n&&a!==_1n&&P.equals(G)?P.multiply(a):P.multiplyUnsafe(a),sum=mul(this,a).add(mul(Q,b));return sum.is0()?void 0:sum}toAffine(iz){return toAffineMemo(this,iz)}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n)return!0;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;return cofactor===_1n?this:clearCofactor?clearCofactor(Point,this):this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=!0){return(0,utils_js_1.abool)("isCompressed",isCompressed),this.assertValidity(),toBytes(Point,this,isCompressed)}toHex(isCompressed=!0){return(0,utils_js_1.abool)("isCompressed",isCompressed),ut.bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE),Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength,wnaf=(0,curve_js_1.wNAF)(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder:function(num){return ut.inRange(num,_1n,CURVE.n)}}}function SWUFpSqrtRatio(Fp,Z){const q=Fp.ORDER;let l=_0n;for(let o=q-_1n;o%_2n===_0n;o/=_2n)l+=_1n;const c1=l,_2n_pow_c1_1=_2n<<c1-_1n-_1n,_2n_pow_c1=_2n_pow_c1_1*_2n,c2=(q-_1n)/_2n_pow_c1,c3=(c2-_1n)/_2n,c4=_2n_pow_c1-_1n,c5=_2n_pow_c1_1,c6=Fp.pow(Z,c2),c7=Fp.pow(Z,(c2+_1n)/_2n);let sqrtRatio=(u,v)=>{let tv1=c6,tv2=Fp.pow(v,c4),tv3=Fp.sqr(tv2);tv3=Fp.mul(tv3,v);let tv5=Fp.mul(u,tv3);tv5=Fp.pow(tv5,c3),tv5=Fp.mul(tv5,tv2),tv2=Fp.mul(tv5,v),tv3=Fp.mul(tv5,u);let tv4=Fp.mul(tv3,tv2);tv5=Fp.pow(tv4,c5);let isQR=Fp.eql(tv5,Fp.ONE);tv2=Fp.mul(tv3,c7),tv5=Fp.mul(tv4,tv1),tv3=Fp.cmov(tv2,tv3,isQR),tv4=Fp.cmov(tv5,tv4,isQR);for(let i=c1;i>_1n;i--){let tv5=i-_2n;tv5=_2n<<tv5-_1n;let tvv5=Fp.pow(tv4,tv5);const e1=Fp.eql(tvv5,Fp.ONE);tv2=Fp.mul(tv3,tv1),tv1=Fp.mul(tv1,tv1),tvv5=Fp.mul(tv4,tv1),tv3=Fp.cmov(tv2,tv3,e1),tv4=Fp.cmov(tvv5,tv4,e1)}return{isValid:isQR,value:tv3}};if(Fp.ORDER%_4n===_3n){const c1=(Fp.ORDER-_3n)/_4n,c2=Fp.sqrt(Fp.neg(Z));sqrtRatio=(u,v)=>{let tv1=Fp.sqr(v);const tv2=Fp.mul(u,v);tv1=Fp.mul(tv1,tv2);let y1=Fp.pow(tv1,c1);y1=Fp.mul(y1,tv2);const y2=Fp.mul(y1,c2),tv3=Fp.mul(Fp.sqr(y1),v),isQR=Fp.eql(tv3,u);return{isValid:isQR,value:Fp.cmov(y2,y1,isQR)}}}return sqrtRatio}},92125:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},92306:(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.decodeRequest=void 0;var RpcMethods,_jsontokens=__webpack_require__(69057);!function(RpcMethods){RpcMethods.request="request"}(RpcMethods||(RpcMethods={}));exports.decodeRequest=function(request){return(0,_jsontokens.decodeToken)(request)}},92485:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SECP256K1Client=void 0;const hmac_1=__webpack_require__(13019),sha256_1=__webpack_require__(63139),secp=__webpack_require__(9598),ecdsaSigFormatter_1=__webpack_require__(96216),errors_1=__webpack_require__(68886),utils_1=__webpack_require__(37995);secp.utils.hmacSha256Sync=(key,...msgs)=>{const h=hmac_1.hmac.create(sha256_1.sha256,key);return msgs.forEach((msg=>h.update(msg))),h.digest()};class SECP256K1Client{static derivePublicKey(privateKey,compressed=!0){return 66===privateKey.length&&(privateKey=privateKey.slice(0,64)),privateKey.length<64&&(privateKey=privateKey.padStart(64,"0")),(0,utils_1.bytesToHex)(secp.getPublicKey(privateKey,compressed))}static signHash(signingInputHash,privateKey,format="jose"){if(!signingInputHash||!privateKey)throw new errors_1.MissingParametersError("a signing input hash and private key are all required");const derSignature=secp.signSync(signingInputHash,privateKey.slice(0,64),{der:!0,canonical:!1});if("der"===format)return(0,utils_1.bytesToHex)(derSignature);if("jose"===format)return(0,ecdsaSigFormatter_1.derToJose)(derSignature,"ES256");throw Error("Invalid signature format")}static loadSignature(joseSignature){return(0,ecdsaSigFormatter_1.joseToDer)(joseSignature,"ES256")}static verifyHash(signingInputHash,derSignatureBytes,publicKey){if(!signingInputHash||!derSignatureBytes||!publicKey)throw new errors_1.MissingParametersError("a signing input hash, der signature, and public key are all required");return secp.verify(derSignatureBytes,signingInputHash,publicKey,{strict:!1})}}exports.SECP256K1Client=SECP256K1Client,SECP256K1Client.algorithmName="ES256K"},92944:(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(prefix){return`${prefix?`${prefix}-`:""}${Date.now()}-${Math.floor(8999999999999*Math.random())+1e12}`}},93732:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},94325:module=>{"use strict";function zero(buf){let len=buf.length;for(;--len>=0;)buf[len]=0}const extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),static_ltree=new Array(576);zero(static_ltree);const static_dtree=new Array(60);zero(static_dtree);const _dist_code=new Array(512);zero(_dist_code);const _length_code=new Array(256);zero(_length_code);const base_length=new Array(29);zero(base_length);const base_dist=new Array(30);function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree,this.extra_bits=extra_bits,this.extra_base=extra_base,this.elems=elems,this.max_length=max_length,this.has_stree=static_tree&&static_tree.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree,this.max_code=0,this.stat_desc=stat_desc}zero(base_dist);const d_code=dist=>dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)],put_short=(s,w)=>{s.pending_buf[s.pending++]=255&w,s.pending_buf[s.pending++]=w>>>8&255},send_bits=(s,value,length)=>{s.bi_valid>16-length?(s.bi_buf|=value<<s.bi_valid&65535,put_short(s,s.bi_buf),s.bi_buf=value>>16-s.bi_valid,s.bi_valid+=length-16):(s.bi_buf|=value<<s.bi_valid&65535,s.bi_valid+=length)},send_code=(s,c,tree)=>{send_bits(s,tree[2*c],tree[2*c+1])},bi_reverse=(code,len)=>{let res=0;do{res|=1&code,code>>>=1,res<<=1}while(--len>0);return res>>>1},gen_codes=(tree,max_code,bl_count)=>{const next_code=new Array(16);let bits,n,code=0;for(bits=1;bits<=15;bits++)code=code+bl_count[bits-1]<<1,next_code[bits]=code;for(n=0;n<=max_code;n++){let len=tree[2*n+1];0!==len&&(tree[2*n]=bi_reverse(next_code[len]++,len))}},init_block=s=>{let n;for(n=0;n<286;n++)s.dyn_ltree[2*n]=0;for(n=0;n<30;n++)s.dyn_dtree[2*n]=0;for(n=0;n<19;n++)s.bl_tree[2*n]=0;s.dyn_ltree[512]=1,s.opt_len=s.static_len=0,s.sym_next=s.matches=0},bi_windup=s=>{s.bi_valid>8?put_short(s,s.bi_buf):s.bi_valid>0&&(s.pending_buf[s.pending++]=s.bi_buf),s.bi_buf=0,s.bi_valid=0},smaller=(tree,n,m,depth)=>{const _n2=2*n,_m2=2*m;return tree[_n2]<tree[_m2]||tree[_n2]===tree[_m2]&&depth[n]<=depth[m]},pqdownheap=(s,tree,k)=>{const v=s.heap[k];let j=k<<1;for(;j<=s.heap_len&&(j<s.heap_len&&smaller(tree,s.heap[j+1],s.heap[j],s.depth)&&j++,!smaller(tree,v,s.heap[j],s.depth));)s.heap[k]=s.heap[j],k=j,j<<=1;s.heap[k]=v},compress_block=(s,ltree,dtree)=>{let dist,lc,code,extra,sx=0;if(0!==s.sym_next)do{dist=255&s.pending_buf[s.sym_buf+sx++],dist+=(255&s.pending_buf[s.sym_buf+sx++])<<8,lc=s.pending_buf[s.sym_buf+sx++],0===dist?send_code(s,lc,ltree):(code=_length_code[lc],send_code(s,code+256+1,ltree),extra=extra_lbits[code],0!==extra&&(lc-=base_length[code],send_bits(s,lc,extra)),dist--,code=d_code(dist),send_code(s,code,dtree),extra=extra_dbits[code],0!==extra&&(dist-=base_dist[code],send_bits(s,dist,extra)))}while(sx<s.sym_next);send_code(s,256,ltree)},build_tree=(s,desc)=>{const tree=desc.dyn_tree,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,elems=desc.stat_desc.elems;let n,m,node,max_code=-1;for(s.heap_len=0,s.heap_max=573,n=0;n<elems;n++)0!==tree[2*n]?(s.heap[++s.heap_len]=max_code=n,s.depth[n]=0):tree[2*n+1]=0;for(;s.heap_len<2;)node=s.heap[++s.heap_len]=max_code<2?++max_code:0,tree[2*node]=1,s.depth[node]=0,s.opt_len--,has_stree&&(s.static_len-=stree[2*node+1]);for(desc.max_code=max_code,n=s.heap_len>>1;n>=1;n--)pqdownheap(s,tree,n);node=elems;do{n=s.heap[1],s.heap[1]=s.heap[s.heap_len--],pqdownheap(s,tree,1),m=s.heap[1],s.heap[--s.heap_max]=n,s.heap[--s.heap_max]=m,tree[2*node]=tree[2*n]+tree[2*m],s.depth[node]=(s.depth[n]>=s.depth[m]?s.depth[n]:s.depth[m])+1,tree[2*n+1]=tree[2*m+1]=node,s.heap[1]=node++,pqdownheap(s,tree,1)}while(s.heap_len>=2);s.heap[--s.heap_max]=s.heap[1],((s,desc)=>{const tree=desc.dyn_tree,max_code=desc.max_code,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,extra=desc.stat_desc.extra_bits,base=desc.stat_desc.extra_base,max_length=desc.stat_desc.max_length;let h,n,m,bits,xbits,f,overflow=0;for(bits=0;bits<=15;bits++)s.bl_count[bits]=0;for(tree[2*s.heap[s.heap_max]+1]=0,h=s.heap_max+1;h<573;h++)n=s.heap[h],bits=tree[2*tree[2*n+1]+1]+1,bits>max_length&&(bits=max_length,overflow++),tree[2*n+1]=bits,n>max_code||(s.bl_count[bits]++,xbits=0,n>=base&&(xbits=extra[n-base]),f=tree[2*n],s.opt_len+=f*(bits+xbits),has_stree&&(s.static_len+=f*(stree[2*n+1]+xbits)));if(0!==overflow){do{for(bits=max_length-1;0===s.bl_count[bits];)bits--;s.bl_count[bits]--,s.bl_count[bits+1]+=2,s.bl_count[max_length]--,overflow-=2}while(overflow>0);for(bits=max_length;0!==bits;bits--)for(n=s.bl_count[bits];0!==n;)m=s.heap[--h],m>max_code||(tree[2*m+1]!==bits&&(s.opt_len+=(bits-tree[2*m+1])*tree[2*m],tree[2*m+1]=bits),n--)}})(s,desc),gen_codes(tree,max_code,s.bl_count)},scan_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),tree[2*(max_code+1)+1]=65535,n=0;n<=max_code;n++)curlen=nextlen,nextlen=tree[2*(n+1)+1],++count<max_count&&curlen===nextlen||(count<min_count?s.bl_tree[2*curlen]+=count:0!==curlen?(curlen!==prevlen&&s.bl_tree[2*curlen]++,s.bl_tree[32]++):count<=10?s.bl_tree[34]++:s.bl_tree[36]++,count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4))},send_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),n=0;n<=max_code;n++)if(curlen=nextlen,nextlen=tree[2*(n+1)+1],!(++count<max_count&&curlen===nextlen)){if(count<min_count)do{send_code(s,curlen,s.bl_tree)}while(0!=--count);else 0!==curlen?(curlen!==prevlen&&(send_code(s,curlen,s.bl_tree),count--),send_code(s,16,s.bl_tree),send_bits(s,count-3,2)):count<=10?(send_code(s,17,s.bl_tree),send_bits(s,count-3,3)):(send_code(s,18,s.bl_tree),send_bits(s,count-11,7));count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4)}};let static_init_done=!1;const _tr_stored_block=(s,buf,stored_len,last)=>{send_bits(s,0+(last?1:0),3),bi_windup(s),put_short(s,stored_len),put_short(s,~stored_len),stored_len&&s.pending_buf.set(s.window.subarray(buf,buf+stored_len),s.pending),s.pending+=stored_len};module.exports._tr_init=s=>{static_init_done||((()=>{let n,bits,length,code,dist;const bl_count=new Array(16);for(length=0,code=0;code<28;code++)for(base_length[code]=length,n=0;n<1<<extra_lbits[code];n++)_length_code[length++]=code;for(_length_code[length-1]=code,dist=0,code=0;code<16;code++)for(base_dist[code]=dist,n=0;n<1<<extra_dbits[code];n++)_dist_code[dist++]=code;for(dist>>=7;code<30;code++)for(base_dist[code]=dist<<7,n=0;n<1<<extra_dbits[code]-7;n++)_dist_code[256+dist++]=code;for(bits=0;bits<=15;bits++)bl_count[bits]=0;for(n=0;n<=143;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(;n<=255;)static_ltree[2*n+1]=9,n++,bl_count[9]++;for(;n<=279;)static_ltree[2*n+1]=7,n++,bl_count[7]++;for(;n<=287;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(gen_codes(static_ltree,287,bl_count),n=0;n<30;n++)static_dtree[2*n+1]=5,static_dtree[2*n]=bi_reverse(n,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,257,286,15),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,30,15),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,19,7)})(),static_init_done=!0),s.l_desc=new TreeDesc(s.dyn_ltree,static_l_desc),s.d_desc=new TreeDesc(s.dyn_dtree,static_d_desc),s.bl_desc=new TreeDesc(s.bl_tree,static_bl_desc),s.bi_buf=0,s.bi_valid=0,init_block(s)},module.exports._tr_stored_block=_tr_stored_block,module.exports._tr_flush_block=(s,buf,stored_len,last)=>{let opt_lenb,static_lenb,max_blindex=0;s.level>0?(2===s.strm.data_type&&(s.strm.data_type=(s=>{let n,block_mask=4093624447;for(n=0;n<=31;n++,block_mask>>>=1)if(1&block_mask&&0!==s.dyn_ltree[2*n])return 0;if(0!==s.dyn_ltree[18]||0!==s.dyn_ltree[20]||0!==s.dyn_ltree[26])return 1;for(n=32;n<256;n++)if(0!==s.dyn_ltree[2*n])return 1;return 0})(s)),build_tree(s,s.l_desc),build_tree(s,s.d_desc),max_blindex=(s=>{let max_blindex;for(scan_tree(s,s.dyn_ltree,s.l_desc.max_code),scan_tree(s,s.dyn_dtree,s.d_desc.max_code),build_tree(s,s.bl_desc),max_blindex=18;max_blindex>=3&&0===s.bl_tree[2*bl_order[max_blindex]+1];max_blindex--);return s.opt_len+=3*(max_blindex+1)+5+5+4,max_blindex})(s),opt_lenb=s.opt_len+3+7>>>3,static_lenb=s.static_len+3+7>>>3,static_lenb<=opt_lenb&&(opt_lenb=static_lenb)):opt_lenb=static_lenb=stored_len+5,stored_len+4<=opt_lenb&&-1!==buf?_tr_stored_block(s,buf,stored_len,last):4===s.strategy||static_lenb===opt_lenb?(send_bits(s,2+(last?1:0),3),compress_block(s,static_ltree,static_dtree)):(send_bits(s,4+(last?1:0),3),((s,lcodes,dcodes,blcodes)=>{let rank;for(send_bits(s,lcodes-257,5),send_bits(s,dcodes-1,5),send_bits(s,blcodes-4,4),rank=0;rank<blcodes;rank++)send_bits(s,s.bl_tree[2*bl_order[rank]+1],3);send_tree(s,s.dyn_ltree,lcodes-1),send_tree(s,s.dyn_dtree,dcodes-1)})(s,s.l_desc.max_code+1,s.d_desc.max_code+1,max_blindex+1),compress_block(s,s.dyn_ltree,s.dyn_dtree)),init_block(s),last&&bi_windup(s)},module.exports._tr_tally=(s,dist,lc)=>(s.pending_buf[s.sym_buf+s.sym_next++]=dist,s.pending_buf[s.sym_buf+s.sym_next++]=dist>>8,s.pending_buf[s.sym_buf+s.sym_next++]=lc,0===dist?s.dyn_ltree[2*lc]++:(s.matches++,dist--,s.dyn_ltree[2*(_length_code[lc]+256+1)]++,s.dyn_dtree[2*d_code(dist)]++),s.sym_next===s.sym_end),module.exports._tr_align=s=>{send_bits(s,2,3),send_code(s,256,static_ltree),(s=>{16===s.bi_valid?(put_short(s,s.bi_buf),s.bi_buf=0,s.bi_valid=0):s.bi_valid>=8&&(s.pending_buf[s.pending++]=255&s.bi_buf,s.bi_buf>>=8,s.bi_valid-=8)})(s)}},95636:module=>{function _setPrototypeOf(t,e){return module.exports=_setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},module.exports.__esModule=!0,module.exports.default=module.exports,_setPrototypeOf(t,e)}module.exports=_setPrototypeOf,module.exports.__esModule=!0,module.exports.default=module.exports},96216:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.joseToDer=exports.derToJose=void 0;const base64_js_1=__webpack_require__(67526),base64Url_1=__webpack_require__(35921);function getParamSize(keySize){return(keySize/8|0)+(keySize%8==0?0:1)}const paramBytesForAlg={ES256:getParamSize(256),ES384:getParamSize(384),ES512:getParamSize(521)};function getParamBytesForAlg(alg){const paramBytes=paramBytesForAlg[alg];if(paramBytes)return paramBytes;throw new Error(`Unknown algorithm "${alg}"`)}function signatureAsBytes(signature){if(signature instanceof Uint8Array)return signature;if("string"==typeof signature)return(0,base64_js_1.toByteArray)((0,base64Url_1.pad)(signature));throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function countPadding(buf,start,stop){let padding=0;for(;start+padding<stop&&0===buf[start+padding];)++padding;return buf[start+padding]>=128&&--padding,padding}exports.derToJose=function(signature,alg){const signatureBytes=signatureAsBytes(signature),paramBytes=getParamBytesForAlg(alg),maxEncodedParamLength=paramBytes+1,inputLength=signatureBytes.length;let offset=0;if(48!==signatureBytes[offset++])throw new Error('Could not find expected "seq"');let seqLength=signatureBytes[offset++];if(129===seqLength&&(seqLength=signatureBytes[offset++]),inputLength-offset<seqLength)throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength-offset}" remaining`);if(2!==signatureBytes[offset++])throw new Error('Could not find expected "int" for "r"');const rLength=signatureBytes[offset++];if(inputLength-offset-2<rLength)throw new Error(`"r" specified length of "${rLength}", only "${inputLength-offset-2}" available`);if(maxEncodedParamLength<rLength)throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);const rOffset=offset;if(offset+=rLength,2!==signatureBytes[offset++])throw new Error('Could not find expected "int" for "s"');const sLength=signatureBytes[offset++];if(inputLength-offset!==sLength)throw new Error(`"s" specified length of "${sLength}", expected "${inputLength-offset}"`);if(maxEncodedParamLength<sLength)throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);const sOffset=offset;if(offset+=sLength,offset!==inputLength)throw new Error(`Expected to consume entire array, but "${inputLength-offset}" bytes remain`);const rPadding=paramBytes-rLength,sPadding=paramBytes-sLength,dst=new Uint8Array(rPadding+rLength+sPadding+sLength);for(offset=0;offset<rPadding;++offset)dst[offset]=0;dst.set(signatureBytes.subarray(rOffset+Math.max(-rPadding,0),rOffset+rLength),offset),offset=paramBytes;for(const o=offset;offset<o+sPadding;++offset)dst[offset]=0;return dst.set(signatureBytes.subarray(sOffset+Math.max(-sPadding,0),sOffset+sLength),offset),(0,base64Url_1.escape)((0,base64_js_1.fromByteArray)(dst))},exports.joseToDer=function(signature,alg){signature=signatureAsBytes(signature);const paramBytes=getParamBytesForAlg(alg),signatureBytes=signature.length;if(signatureBytes!==2*paramBytes)throw new TypeError(`"${alg}" signatures must be "${2*paramBytes}" bytes, saw "${signatureBytes}"`);const rPadding=countPadding(signature,0,paramBytes),sPadding=countPadding(signature,paramBytes,signature.length),rLength=paramBytes-rPadding,sLength=paramBytes-sPadding,rsBytes=2+rLength+1+1+sLength,shortLength=rsBytes<128,dst=new Uint8Array((shortLength?2:3)+rsBytes);let offset=0;return dst[offset++]=48,shortLength?dst[offset++]=rsBytes:(dst[offset++]=129,dst[offset++]=255&rsBytes),dst[offset++]=2,dst[offset++]=rLength,rPadding<0?(dst[offset++]=0,dst.set(signature.subarray(0,paramBytes),offset),offset+=paramBytes):(dst.set(signature.subarray(rPadding,paramBytes),offset),offset+=paramBytes-rPadding),dst[offset++]=2,dst[offset++]=sLength,sPadding<0?(dst[offset++]=0,dst.set(signature.subarray(paramBytes),offset)):dst.set(signature.subarray(paramBytes+sPadding),offset),dst}},96857:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},96949:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},97176:(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0})},97990:function(__unused_webpack_module,exports,__webpack_require__){"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P((function(resolve){resolve(value)}))).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.hashSha256Async=exports.hashSha256=void 0;const sha256_1=__webpack_require__(63139);function hashSha256(input){return(0,sha256_1.sha256)(input)}exports.hashSha256=hashSha256,exports.hashSha256Async=function(input){return __awaiter(this,void 0,void 0,(function*(){try{if("undefined"!=typeof crypto&&void 0!==crypto.subtle){const bytes="string"==typeof input?(new TextEncoder).encode(input):input,hash=yield crypto.subtle.digest("SHA-256",bytes);return new Uint8Array(hash)}{const nodeCrypto=__webpack_require__(32632);if(!nodeCrypto.createHash)throw new Error("`crypto` module does not contain `createHash`");return Promise.resolve(nodeCrypto.createHash("sha256").update(input).digest())}}catch(error){return Promise.resolve(hashSha256(input))}}))}},98748:(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _constants=__webpack_require__(8555);exports.default=`${_constants.BASE64_SVG_PREFIX}${btoa('<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <path\n        d="M62.705 13.9116C62.8359 14.1333 62.6621 14.407 62.4039 14.407C57.1807 14.407 52.9348 18.5427 52.8351 23.6817C51.0465 23.3477 49.1933 23.3226 47.3626 23.6311C47.2361 18.5156 43.0009 14.407 37.7948 14.407C37.5365 14.407 37.3625 14.1331 37.4935 13.9112C40.0217 9.62809 44.7204 6.75 50.0991 6.75C55.4781 6.75 60.1769 9.62826 62.705 13.9116Z"\n        fill="url(#paint0_linear_372_40259)" />\n    <path\n        d="M78.7606 45.8718C80.2725 46.3297 81.7025 45.0055 81.1714 43.5222C76.4137 30.2334 61.3911 24.8039 50.0277 24.8039C38.6442 24.8039 23.2868 30.407 18.8754 43.5912C18.3824 45.0645 19.8083 46.3446 21.2978 45.8881L48.872 37.4381C49.5331 37.2355 50.2399 37.2344 50.9017 37.4348L78.7606 45.8718Z"\n        fill="url(#paint1_linear_372_40259)" />\n    <path\n        d="M18.8132 48.1707L48.8935 39.0472C49.5506 38.8478 50.2524 38.8473 50.9098 39.0456L81.1781 48.1752C83.6912 48.9332 85.411 51.2483 85.411 53.8735V81.2233C85.2944 87.8991 79.2977 93.25 72.6245 93.25H61.5406C60.4449 93.25 59.5577 92.3637 59.5577 91.268V81.6789C59.5577 77.9031 61.7921 74.4855 65.2498 72.9729C69.8849 70.9454 75.3681 68.2028 76.3994 62.6992C76.7323 60.9229 75.5741 59.2094 73.8024 58.8573C69.3226 57.9667 64.3562 58.3107 60.1564 60.1893C55.3887 62.3219 54.1415 65.8694 53.6797 70.6337L53.1201 75.7662C52.9491 77.3349 51.4785 78.5366 49.9014 78.5366C48.2699 78.5366 47.0465 77.294 46.8696 75.6712L46.3204 70.6337C45.9249 66.5529 45.2079 62.5887 40.9895 60.7018C36.1776 58.5494 31.3419 57.8347 26.1976 58.8573C24.426 59.2094 23.2678 60.9229 23.6007 62.6992C24.641 68.2507 30.0812 70.9305 34.7503 72.9729C38.208 74.4855 40.4424 77.9031 40.4424 81.6789V91.2663C40.4424 92.362 39.5555 93.25 38.4599 93.25H27.3756C20.7024 93.25 14.7057 87.8991 14.5891 81.2233V53.8663C14.5891 51.2446 16.3045 48.9316 18.8132 48.1707Z"\n        fill="url(#paint2_linear_372_40259)" />\n    <defs>\n        <linearGradient id="paint0_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n        <linearGradient id="paint1_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n        <linearGradient id="paint2_linear_372_40259" x1="49.3057" y1="2.079" x2="80.3627" y2="93.6597"\n            gradientUnits="userSpaceOnUse">\n            <stop stop-color="#F5D45E" />\n            <stop offset="1" stop-color="#FF9600" />\n        </linearGradient>\n    </defs>\n</svg>')}`},99291:module=>{module.exports=function(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)},module.exports.__esModule=!0,module.exports.default=module.exports}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.exports}__webpack_require__.d=(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),__webpack_require__.r=exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})};var _interopRequireDefault=__webpack_require__(24994),_classCallCheck2=_interopRequireDefault(__webpack_require__(17383)),_createClass2=_interopRequireDefault(__webpack_require__(34579)),_inherits2=_interopRequireDefault(__webpack_require__(29511)),_possibleConstructorReturn2=_interopRequireDefault(__webpack_require__(28452)),_getPrototypeOf2=_interopRequireDefault(__webpack_require__(63072)),_StarknetWindowObject2=__webpack_require__(25516),_sameOriginListener=_interopRequireDefault(__webpack_require__(53435)),_dappRequests=_interopRequireDefault(__webpack_require__(53213));function _createSuper(t){var r=_isNativeReflectConstruct();return function(){var e,o=(0,_getPrototypeOf2.default)(t);if(r){var s=(0,_getPrototypeOf2.default)(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return(0,_possibleConstructorReturn2.default)(this,e)}}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}var ExtBitcoinWindowObject=function(_BitcoinWindowObject){(0,_inherits2.default)(ExtBitcoinWindowObject,_BitcoinWindowObject);var _super=_createSuper(ExtBitcoinWindowObject);function ExtBitcoinWindowObject(){var _this;return(0,_classCallCheck2.default)(this,ExtBitcoinWindowObject),_this=_super.call(this),(0,_sameOriginListener.default)((function(_ref){var message=_ref.data;_this.handleIncomingMessage(message).catch((function(err){}))})),_this}return(0,_createClass2.default)(ExtBitcoinWindowObject,[{key:"sendMessageFromInpageToContent",value:function(_msg){return new Promise((function(resolve){var msg=JSON.parse(JSON.stringify(_msg)),uid=_dappRequests.default.add(msg,resolve);window.postMessage(Object.assign({},msg,{uid,from:"braavos-inpage"}))}))}}]),ExtBitcoinWindowObject}(__webpack_require__(9750).BitcoinWindowObject),starknetWindowObject=new(function(_StarknetWindowObject){(0,_inherits2.default)(ExtStarknetWindowObject,_StarknetWindowObject);var _super2=_createSuper(ExtStarknetWindowObject);function ExtStarknetWindowObject(){var _this2;return(0,_classCallCheck2.default)(this,ExtStarknetWindowObject),_this2=_super2.call(this),(0,_sameOriginListener.default)((function(_ref2){var message=_ref2.data;_this2.handleIncomingMessage(message).catch((function(err){}))})),_this2}return(0,_createClass2.default)(ExtStarknetWindowObject,[{key:"sendMessageFromInpageToContent",value:function(_msg){return new Promise((function(resolve){var msg=JSON.parse(JSON.stringify(_msg)),uid=_dappRequests.default.add(msg,resolve);window.postMessage(Object.assign({},msg,{uid,from:"braavos-inpage"}))}))}}]),ExtStarknetWindowObject}(_StarknetWindowObject2.StarknetWindowObject)),validateAttached=(new ExtBitcoinWindowObject,function(){try{window.starknet_braavos=starknetWindowObject}catch(_unused){}try{window.starknet=starknetWindowObject}catch(_unused2){}});validateAttached(),window.addEventListener("load",(function(){return validateAttached()})),document.addEventListener("readystatechange",(function(){return validateAttached()})),document.addEventListener("DOMContentLoaded",(function(){return validateAttached()}))})();
//# sourceMappingURL=inpage.js.map